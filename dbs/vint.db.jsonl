{"prompt": " file path A: test/acceptance/test_cli.py | file path B: test/acceptance/test_cli.py\n\n@@ -29,7 +29,7 @@ class TestCLI(unittest.TestCase):\n \n     def test_exec_vint_with_valid_file_on_project_root(self):\n         valid_file = str(Path('test', 'fixture', 'cli', 'valid1.vim'))\n-        cmd = ['vint', valid_file]\n+        cmd = ['bin/vint', valid_file]\n \n         expected_output = ''\n \n@@ -38,7 +38,7 @@ class TestCLI(unittest.TestCase):\n \n     def test_exec_vint_with_valid_file_encoded_cp932_on_project_root(self):\n         valid_file = str(Path('test', 'fixture', 'cli', 'valid-cp932.vim'))\n-        cmd = ['vint', valid_file]\n+        cmd = ['bin/vint', valid_file]\n \n         expected_output = ''\n \n@@ -47,7 +47,7 @@ class TestCLI(unittest.TestCase):\n \n     def test_exec_vint_with_invalid_file_on_project_root(self):\n         invalid_file = str(Path('test', 'fixture', 'cli', 'invalid1.vim'))\n-        cmd = ['vint', invalid_file]\n+        cmd = ['bin/vint', invalid_file]\n \n         with self.assertRaises(subprocess.CalledProcessError) as context_manager:\n             subprocess.check_output(cmd, universal_newlines=True)\n@@ -59,7 +59,7 @@ class TestCLI(unittest.TestCase):\n \n \n     def test_exec_vint_with_no_args(self):\n-        cmd = ['vint']\n+        cmd = ['bin/vint']\n \n         with self.assertRaises(subprocess.CalledProcessError) as context_manager:\n             subprocess.check_output(cmd,\n@@ -73,7 +73,7 @@ class TestCLI(unittest.TestCase):\n \n \n     def test_exec_vint_with_unexistent_file(self):\n-        cmd = ['vint', '/path/to/unexistent']\n+        cmd = ['bin/vint', '/path/to/unexistent']\n \n         with self.assertRaises(subprocess.CalledProcessError) as context_manager:\n             subprocess.check_output(cmd,\n@@ -88,7 +88,7 @@ class TestCLI(unittest.TestCase):\n \n     def test_exec_vint_with_stat_flag(self):\n         invalid_file = str(Path('test', 'fixture', 'cli', 'invalid1.vim'))\n-        cmd = ['vint', '--stat', invalid_file]\n+        cmd = ['bin/vint', '--stat', invalid_file]\n \n         with self.assertRaises(subprocess.CalledProcessError) as context_manager:\n             subprocess.check_output(cmd,\n@@ -105,7 +105,7 @@ class TestCLI(unittest.TestCase):\n \n     def test_exec_vint_with_json_flag(self):\n         invalid_file = str(Path('test', 'fixture', 'cli', 'invalid1.vim'))\n-        cmd = ['vint', '--json', invalid_file]\n+        cmd = ['bin/vint', '--json', invalid_file]\n \n         with self.assertRaises(subprocess.CalledProcessError) as context_manager:\n             # We should not capture STRERR because coverage plugin use it.\n@@ -120,7 +120,7 @@ class TestCLI(unittest.TestCase):\n \n     def test_exec_vint_with_verbose_flag(self):\n         valid_file = str(Path('test', 'fixture', 'cli', 'valid1.vim'))\n-        cmd = ['vint', '--verbose', valid_file]\n+        cmd = ['bin/vint', '--verbose', valid_file]\n \n         got_output = subprocess.check_output(cmd,\n                                              universal_newlines=True,\n@@ -133,7 +133,7 @@ class TestCLI(unittest.TestCase):\n     @unittest.skip('Does drone.io not like ANSI color?')\n     def test_exec_vint_with_color_flag(self):\n         invalid_file = str(Path('test', 'fixture', 'cli', 'invalid1.vim'))\n-        cmd = ['vint', '--color', invalid_file]\n+        cmd = ['bin/vint', '--color', invalid_file]\n \n         with self.assertRaises(subprocess.CalledProcessError) as context_manager:\n             subprocess.check_output(cmd, universal_newlines=True)\n\n---\n file path A: test/acceptance/test_cli_vital.py | file path B: test/acceptance/test_cli_vital.py\n\n@@ -19,7 +19,7 @@ class TestVintDoNotDiedWhenLintingVital(unittest.TestCase):\n \n     def test_survive_after_linting(self):\n         vital_dir = str(Path('test', 'fixture', 'cli', 'vital.vim'))\n-        cmd = ['vint', vital_dir]\n+        cmd = ['bin/vint', vital_dir]\n \n         self.assertVintStillAlive(cmd)\n \n\n\n###\n\n", "completion": "tests: use 'bin/vint' in tests to avoid calling an installed vint copy (#<issue-num>)"}
{"prompt": " file path A: test/fixture/policy/prohibit_implicit_scope_variable_invalid.vim | file path B: test/fixture/policy/prohibit_implicit_scope_variable_invalid.vim\n\n@@ -11,3 +11,9 @@ function! ImplicitGlobalFunc(param)\n     \" Make fix missing a: easy\n     echo param\n endfunction\n+call ImplicitGlobalFunc(0)\n+\n+function! autoload#ImplicitGlobalAutoloadFunc(param)\n+    echo autoload#AnotherImplicitGlobalAutoloadFunc(param)\n+endfunction\n+call autoload#ImplicitGlobalAutoloadFunc(1)\n\n---\n file path A: test/fixture/policy/prohibit_implicit_scope_variable_valid.vim | file path B: test/fixture/policy/prohibit_implicit_scope_variable_valid.vim\n\n@@ -34,6 +34,10 @@ function! s:ScriptLocalFunc()\n endfunction\n call s:ScriptLocalFunc()\n \n+function! g:autoload#AutoloadFunc()\n+endfunction\n+call g:autoload#AutoloadFunc()\n+\n \" We can call buffer/window/tab local function references\n call b:BufferLocalFunc()\n call w:WindowLocalFunc()\n\n---\n file path A: test/integration/vint/linting/policy/test_prohibit_implicit_scope_variable.py | file path B: test/integration/vint/linting/policy/test_prohibit_implicit_scope_variable.py\n\n@@ -33,11 +33,33 @@ class TestProhibitImplicitScopeVariable(PolicyAssertion, unittest.TestCase):\n             self.create_violation(8, 5),\n             self.create_violation(10, 11),\n             self.create_violation(12, 10),\n+            self.create_violation(14, 6),\n+            self.create_violation(16, 11),\n+            self.create_violation(17, 10),\n+            self.create_violation(17, 53),\n+            self.create_violation(19, 6),\n         ]\n \n         self.assertFoundViolationsEqual(PATH_INVALID_VIM_SCRIPT,\n                                         ProhibitImplicitScopeVariable,\n                                         expected_violations)\n \n+\n+    def test_get_violation_if_found_when_autoloads_are_suppressed(self):\n+        expected_violations = [\n+            self.create_violation(2, 5),\n+            self.create_violation(4, 10),\n+            self.create_violation(8, 5),\n+            self.create_violation(10, 11),\n+            self.create_violation(12, 10),\n+            self.create_violation(14, 6),\n+            self.create_violation(17, 53),\n+        ]\n+\n+        self.assertFoundViolationsEqual(PATH_INVALID_VIM_SCRIPT,\n+                                        ProhibitImplicitScopeVariable,\n+                                        expected_violations,\n+                                        {'suppress_autoload': True})\n+\n if __name__ == '__main__':\n     unittest.main()\n\n\n###\n\n", "completion": "tests: cover ProhibitImplicitScopeVariable 'suppress_autoload' option"}
{"prompt": " file path A: test/asserting/policy.py | file path B: test/asserting/policy.py\n\n@@ -47,17 +47,20 @@ class PolicyAssertion(unittest.TestCase):\n             return self._config_dict\n \n \n-    def assertFoundNoViolations(self, path, Policy):\n-        self.assertFoundViolationsEqual(path, Policy, [])\n+    def assertFoundNoViolations(self, path, Policy, policy_options=None):\n+        self.assertFoundViolationsEqual(path, Policy, [], policy_options)\n \n \n-    def assertFoundViolationsEqual(self, path, Policy, expected_violations):\n+    def assertFoundViolationsEqual(self, path, Policy, expected_violations, policy_options=None):\n         policy_to_test = Policy()\n         policy_name = Policy.__name__\n \n         policy_set = PolicyAssertion.StubPolicySet(policy_to_test)\n         config = PolicyAssertion.StubConfigContainer(policy_name)\n \n+        if policy_options is not None:\n+            config.get_config_dict()['policies'][policy_name].update(policy_options)\n+\n         linter = Linter(policy_set, config.get_config_dict())\n         violations = linter.lint_file(path)\n \n\n\n###\n\n", "completion": "tests: make PolicyAssertion#assertFound* methods aware of policy options"}
{"prompt": " file path A: test/unit/vint/linting/policy/test_abstract_policy.py | file path B: test/unit/vint/linting/policy/test_abstract_policy.py\n\n@@ -42,6 +42,33 @@ class TestAbstractPolicy(unittest.TestCase):\n             policy.create_violation_report(node, env),\n             expected_violation)\n \n+    def test_get_policy_options(self):\n+        policy = ConcretePolicy()\n+\n+        expected_options = {}\n+        lint_context = {\n+            'config': {},\n+        }\n+        self.assertEqual(\n+            policy.get_policy_options(lint_context),\n+            expected_options)\n+\n+        expected_options = {}\n+        lint_context = {\n+            'config': {'policies': {}},\n+        }\n+        self.assertEqual(\n+            policy.get_policy_options(lint_context),\n+            expected_options)\n+\n+        expected_options = {'someoption': True}\n+        lint_context = {\n+            'config': {'policies': {'ConcretePolicy': expected_options}},\n+        }\n+        self.assertEqual(\n+            policy.get_policy_options(lint_context),\n+            expected_options)\n+\n \n if __name__ == '__main__':\n     unittest.main()\n\n\n###\n\n", "completion": "tests: cover AbstractPolicy#get_policy_options with unit tests"}
{"prompt": " file path A: test/asserting/policy.py | file path B: test/asserting/policy.py\n\n@@ -3,6 +3,7 @@ from pathlib import Path\n from pprint import pprint\n from compat.itertools import zip_longest\n from vint.linting.linter import Linter\n+from vint.linting.config.config_default_source import ConfigDefaultSource\n \n \n class PolicyAssertion(unittest.TestCase):\n@@ -22,11 +23,18 @@ class PolicyAssertion(unittest.TestCase):\n     class StubConfigContainer(object):\n         def __init__(self, policy_names_to_enable):\n \n-            policy_enabling_map = dict((policy_name, {'enabled': True})\n-                                       for policy_name in policy_names_to_enable)\n+            default_config_dict = ConfigDefaultSource(None).get_config_dict()\n+            policy_options = default_config_dict.get('policies', {})\n+\n+            for policy, options in policy_options.items():\n+                options['enabled'] = False\n+\n+            for policy in policy_names_to_enable:\n+                options = policy_options.setdefault(policy, {})\n+                options['enabled'] = True\n \n             self._config_dict = {\n-                'policies': policy_enabling_map\n+                'policies': policy_options,\n             }\n \n \n\n\n###\n\n", "completion": "tests: make StubConfigContainer source 'default_config.yaml'"}
