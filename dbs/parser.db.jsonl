{"prompt": " file path A: CHANGELOG.md | file path B: CHANGELOG.md\n\n@@ -1,5 +1,12 @@\n # Changelog\n \n+### [0.4.1](https://www.github.com/conventional-commits/parser/compare/v0.4.0...v0.4.1) (2021-01-07)\n+\n+\n+### Bug Fixes\n+\n+* **types:** add missing Newline types ([#35](https://www.github.com/conventional-commits/parser/issues/35)) ([6f3f696](https://www.github.com/conventional-commits/parser/commit/6f3f69622191711df1ea419c73ef0770d0b36ba7))\n+\n ## [0.4.0](https://www.github.com/conventional-commits/parser/compare/v0.3.0...v0.4.0) (2021-01-07)\n \n \n\n---\n file path A: package.json | file path B: package.json\n\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@conventional-commits/parser\",\n-  \"version\": \"0.4.0\",\n+  \"version\": \"0.4.1\",\n   \"description\": \"reference implementation of conventionalcommits.org spec\",\n   \"main\": \"index.js\",\n   \"files\": [\n\n\n###\n\n", "completion": "chore: release 0.4.1 (#<issue-num>)"}
{"prompt": " file path A: index.d.ts | file path B: index.d.ts\n\n@@ -67,7 +67,7 @@ export interface Parent extends Node {\n \n export interface Message extends Parent {\n   type: 'message';\n-  children: (Summary | Body)[];\n+  children: (Summary | Body | Newline | Footer)[];\n }\n \n export interface Text extends Literal {\n@@ -75,9 +75,14 @@ export interface Text extends Literal {\n   value: string;\n }\n \n+export interface Newline extends Literal {\n+  type: 'newline';\n+  value: string;\n+}\n+\n export interface BreakingChange extends Literal {\n   type: 'breaking-change';\n-  value: '!' | 'BREAKING CHANGE';\n+  value: '!' | 'BREAKING-CHANGE' | 'BREAKING CHANGE';\n }\n \n export interface Summary extends Parent {\n@@ -102,7 +107,7 @@ export interface Separator extends Literal {\n \n export interface Body extends Parent {\n   type: 'body';\n-  children: (Text | Footer)[];\n+  children: (Text | Newline)[];\n }\n \n export interface Footer extends Parent {\n@@ -122,5 +127,5 @@ export interface Value extends Parent {\n \n export interface Continuation extends Parent {\n   type: 'continuation';\n-  children: Text[];\n+  children: (Newline | Text)[];\n }\n\n\n###\n\n", "completion": "fix(types): add missing Newline types (#<issue-num>)"}
{"prompt": " file path A: CHANGELOG.md | file path B: CHANGELOG.md\n\n@@ -1,5 +1,12 @@\n # Changelog\n \n+## [0.4.0](https://www.github.com/conventional-commits/parser/compare/v0.3.0...v0.4.0) (2021-01-07)\n+\n+\n+### Features\n+\n+* add greedy newline tokenizer ([#25](https://www.github.com/conventional-commits/parser/issues/25)) ([5b12227](https://www.github.com/conventional-commits/parser/commit/5b12227426d8c2f0ec3c88eb58ba8cf76d76246a))\n+\n ## [0.3.0](https://www.github.com/conventional-commits/parser/compare/v0.2.0...v0.3.0) (2020-12-30)\n \n \n\n---\n file path A: package.json | file path B: package.json\n\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@conventional-commits/parser\",\n-  \"version\": \"0.3.0\",\n+  \"version\": \"0.4.0\",\n   \"description\": \"reference implementation of conventionalcommits.org spec\",\n   \"main\": \"index.js\",\n   \"files\": [\n\n\n###\n\n", "completion": "chore: release 0.4.0 (#<issue-num>)"}
{"prompt": " file path A: CHANGELOG.md | file path B: CHANGELOG.md\n\n@@ -1,5 +1,14 @@\n # Changelog\n \n+## [0.3.0](https://www.github.com/conventional-commits/parser/compare/v0.2.0...v0.3.0) (2020-12-30)\n+\n+\n+### Features\n+\n+* **conventional-changelog:** handle BREAKING CHANGE in footer and body ([#32](https://www.github.com/conventional-commits/parser/issues/32)) ([5ad6785](https://www.github.com/conventional-commits/parser/commit/5ad678567d429174e1ec1eb709a6dd6547f6f2a8))\n+* support BREAKING CHANGE in body ([#30](https://www.github.com/conventional-commits/parser/issues/30)) ([8f3f5c7](https://www.github.com/conventional-commits/parser/commit/8f3f5c77fec0bea267d92bd0ca71ed8b49edf5a9))\n+* **types:** add TypeScript definitions ([#29](https://www.github.com/conventional-commits/parser/issues/29)) ([2a2474b](https://www.github.com/conventional-commits/parser/commit/2a2474b1bfe700d693b495cb3498fa9163801d7a))\n+\n ## [0.2.0](https://www.github.com/conventional-commits/parser/compare/v0.1.0...v0.2.0) (2020-12-28)\n \n \n\n---\n file path A: package.json | file path B: package.json\n\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@conventional-commits/parser\",\n-  \"version\": \"0.2.0\",\n+  \"version\": \"0.3.0\",\n   \"description\": \"reference implementation of conventionalcommits.org spec\",\n   \"main\": \"index.js\",\n   \"files\": [\n\n\n###\n\n", "completion": "chore: release 0.3.0 (#<issue-num>)"}
{"prompt": " file path A: lib/utils.js | file path B: lib/utils.js\n\n@@ -1,22 +1,27 @@\n const visit = require('unist-util-visit')\n+const visitWithAncestors = require('unist-util-visit-parents')\n const NUMBER_REGEX = /^[0-9]+$/\n \n // Converts conventional commit AST into conventional-changelog's\n // output format, see: https://www.npmjs.com/package/conventional-commits-parser\n function toConventionalChangelogFormat (ast) {\n   const cc = {\n-    body: null,\n+    body: '',\n+    subject: '',\n+    type: '',\n+    scope: null,\n     notes: [],\n     references: [],\n     mentions: [],\n     merge: null,\n-    revert: null\n+    revert: null,\n+    header: '',\n+    footer: null\n   }\n-  let breaking\n-  let body\n-  let summary\n   // Separate the body and summary nodes, this simplifies the subsequent\n   // tree walking logic:\n+  let body\n+  let summary\n   visit(ast, ['body', 'summary'], (node) => {\n     switch (node.type) {\n       case 'body':\n@@ -25,54 +30,77 @@ function toConventionalChangelogFormat (ast) {\n       case 'summary':\n         summary = node\n         break\n-      default:\n-        break\n     }\n   })\n \n-  visit(summary, () => true, (node) => {\n+  // <type>, \"(\", <scope>, \")\", [\"!\"], \":\", <whitespace>*, <text>\n+  visit(summary, (node) => {\n     switch (node.type) {\n       case 'type':\n         cc.type = node.value\n+        cc.header += node.value\n         break\n       case 'scope':\n         cc.scope = node.value\n+        cc.header += `(${node.value})`\n+        break\n+      case 'breaking-change':\n+        cc.header += '!'\n         break\n       case 'text':\n         cc.subject = node.value\n-        break\n-      case 'breaking-change':\n-        breaking = {\n-          title: 'BREAKING CHANGE'\n-          // \"text\" node should be added with subject after walk.\n-        }\n+        cc.header += `: ${node.value}`\n         break\n       default:\n         break\n     }\n   })\n-  // The header contains the recombined components of the summary:\n-  cc.header = `${cc.type}${cc.scope ? `(${cc.scope})` : ''}${breaking ? '!' : ''}: ${cc.subject}`\n \n+  // [<any body-text except pre-footer>]\n   if (body) {\n-    let text = ''\n     visit(body, 'text', (node, _i, parent) => {\n-      if (parent.type !== 'body') return\n-      if (text !== '') text += '\\n'\n-      text += node.value\n+      // TODO(@bcoe): once we have \\n tokens in tree we can drop this:\n+      if (cc.body !== '') cc.body += '\\n'\n+      cc.body += node.value\n     })\n-    if (text !== '') cc.body = text\n   }\n \n-  // A breaking change note was found either in the body, the header, or\n-  // in one of the footers:\n-  // TODO(bcoe): if we refactor the grammar slightly, so that footer is a\n-  // direct parent of `breaking-change`, the logic for extracting a breaking\n-  // change would be easier.\n-  if (breaking) {\n-    if (!breaking.text) breaking.text = cc.subject\n-    cc.notes.push(breaking)\n+  // Extract BREAKING CHANGE notes, regardless of whether they fall in\n+  // summary, body, or footer:\n+  const breaking = {\n+    title: 'BREAKING CHANGE',\n+    text: '' // \"text\" will be populated if a BREAKING CHANGE token is parsed.\n   }\n+  visitWithAncestors(ast, ['breaking-change'], (node, ancestors) => {\n+    let parent = ancestors.pop()\n+    let startCollecting = false\n+    switch (parent.type) {\n+      case 'summary':\n+        breaking.text = cc.subject\n+        break\n+      case 'body':\n+        breaking.text = ''\n+        // We treat text from the BREAKING CHANGE marker forward as\n+        // the breaking change notes:\n+        visit(parent, ['text', 'breaking-change'], (node) => {\n+          // TODO(@bcoe): once we have \\n tokens in tree we can drop this:\n+          if (startCollecting && node.type === 'text') {\n+            if (breaking.text !== '') breaking.text += '\\n'\n+            breaking.text += node.value\n+          } else if (node.type === 'breaking-change') {\n+            startCollecting = true\n+          }\n+        })\n+        break\n+      case 'token':\n+        parent = ancestors.pop()\n+        visit(parent, 'text', (node) => {\n+          breaking.text = node.value\n+        })\n+        break\n+    }\n+  })\n+  if (breaking.text !== '') cc.notes.push(breaking)\n \n   // Populates references array from footers:\n   // references: [{\n@@ -109,8 +137,6 @@ function toConventionalChangelogFormat (ast) {\n             reference.issue = node.value\n           }\n           break\n-        default:\n-          break\n       }\n     })\n     // TODO(@bcoe): how should references like \"Refs: v8:8940\" work.\n\n---\n file path A: package.json | file path B: package.json\n\n@@ -44,6 +44,7 @@\n     \"yargs\": \"^16.2.0\"\n   },\n   \"dependencies\": {\n-    \"unist-util-visit\": \"^2.0.3\"\n+    \"unist-util-visit\": \"^2.0.3\",\n+    \"unist-util-visit-parents\": \"^3.1.1\"\n   }\n }\n\n---\n file path A: scripts/inspect.js | file path B: scripts/inspect.js\n\n@@ -1,12 +1,17 @@\n #!/usr/bin/env node\n \n-const { parser } = require('..')\n+const { parser, toConventionalChangelogFormat } = require('..')\n const inspect = require('unist-util-inspect')\n const { hideBin } = require('yargs/helpers')\n const yargs = require('yargs/yargs')(hideBin(process.argv))\n \n yargs\n-  .command('$0 <message>', 'Output the parsed syntax tree', () => {}, (argv) => {\n+  .command('$0 <message>', 'output the parsed syntax tree', () => {}, (argv) => {\n     console.log(inspect(parser(argv.message)))\n   })\n+  .command('cc <message>', 'output conventional changelog format commit', () => {}, (argv) => {\n+    const cc = toConventionalChangelogFormat(parser(argv.message))\n+    console.log('-----')\n+    console.log(JSON.stringify(cc, null, 2))\n+  })\n   .parse()\n\n---\n file path A: test/utils.js | file path B: test/utils.js\n\n@@ -17,13 +17,6 @@ describe('utils', () => {\n       const parsed = toConventionalChangelogFormat(parser('foo: bar\\n\\nthe body of commit\\nsecond line'))\n       assert.strictEqual(parsed.body, 'the body of commit\\nsecond line')\n     })\n-    it('extracts BREAKING CHANGE from header', () => {\n-      const parsed = toConventionalChangelogFormat(parser('foo!: hello world'))\n-      assert.strictEqual(parsed.notes.length, 1)\n-      const note = parsed.notes[0]\n-      assert.strictEqual(note.title, 'BREAKING CHANGE')\n-      assert.strictEqual(note.text, 'hello world')\n-    })\n     it('populates references entry from footer', () => {\n       const parsed = toConventionalChangelogFormat(parser('foo: summary\\n\\nRefs #34'))\n       assert.strictEqual(parsed.references.length, 1)\n@@ -40,5 +33,34 @@ describe('utils', () => {\n       const parsed = toConventionalChangelogFormat(parser('foo: summary\\n\\nRefs #batman'))\n       assert.strictEqual(parsed.references.length, 0)\n     })\n+    it('extracts BREAKING CHANGE from header', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo!: hello world'))\n+      assert.strictEqual(parsed.notes.length, 1)\n+      const note = parsed.notes[0]\n+      assert.strictEqual(note.title, 'BREAKING CHANGE')\n+      assert.strictEqual(note.text, 'hello world')\n+    })\n+    it('extracts BREAKING CHANGE from body', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo!: hello world\\n\\nBREAKING CHANGE: this change is breaking\\nsecond line'))\n+      assert.strictEqual(parsed.notes.length, 1)\n+      const note = parsed.notes[0]\n+      assert.strictEqual(note.title, 'BREAKING CHANGE')\n+      assert.strictEqual(note.text, 'this change is breaking\\nsecond line')\n+    })\n+    it('only extracts text after BREAKING CHANGE token in body', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo!: hello world\\n\\nstart of body\\nBREAKING CHANGE: this change is breaking\\nsecond line'))\n+      assert.strictEqual(parsed.notes.length, 1)\n+      const note = parsed.notes[0]\n+      assert.strictEqual(note.title, 'BREAKING CHANGE')\n+      assert.strictEqual(note.text, 'this change is breaking\\nsecond line')\n+    })\n+    it('extracts BREAKING CHANGE from footer', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo!: hello world\\n\\nthis is the body\\n\\nBREAKING CHANGE: this change is breaking'))\n+      assert.strictEqual(parsed.notes.length, 1)\n+      assert.strictEqual(parsed.body, 'this is the body')\n+      const note = parsed.notes[0]\n+      assert.strictEqual(note.title, 'BREAKING CHANGE')\n+      assert.strictEqual(note.text, 'this change is breaking')\n+    })\n   })\n })\n\n\n###\n\n", "completion": "feat(conventional-changelog): handle BREAKING CHANGE in footer and body (#<issue-num>)"}
{"prompt": " file path A: None | file path B: index.d.ts\n\n@@ -0,0 +1,126 @@\n+export function parser(commitText: string): Message;\n+\n+export interface Note {\n+  title: string,\n+  text: string\n+}\n+\n+export interface Reference {\n+  action: string;\n+  owner?: string;\n+  repository?: string;\n+  issue: string;\n+  raw?: string;\n+  prefix: string;\n+}\n+\n+export interface ConventionalChangelogCommit {\n+  type: string;\n+  scope: string | null;\n+  subject: string;\n+  merge: boolean | null;\n+  header: string;\n+  body: string | null;\n+  footer: string | null;\n+  notes: Note[];\n+  references: Reference[];\n+  mentions: string[];\n+  revert: boolean | null;\n+}\n+\n+export function toConventionalChangelogFormat(ast: Message): ConventionalChangelogCommit;\n+\n+// unist core - copied from @types/unist\n+\n+export interface Point {\n+  /** Line in a source file (1-indexed integer) */\n+  line: number;\n+  /** Column in a source file (1-indexed integer) */\n+  column: number;\n+  /** Character in a source file (0-indexed integer) */\n+  offset?: number;\n+}\n+\n+export interface Position {\n+  /** Place of the first character of the parsed source region */\n+  start: Point;\n+  /** Place of the first character after the parsed source region */\n+  end: Point;\n+}\n+\n+export interface Node {\n+  /** The semantic type of the node */\n+  type: string;\n+  /** Location of a node in a source document. Undefined when generated */\n+  position?: Position;\n+}\n+\n+export interface Literal extends Node {\n+  value: unknown;\n+}\n+\n+export interface Parent extends Node {\n+  children: unknown[];\n+}\n+\n+// unist conventional commits structure\n+\n+export interface Message extends Parent {\n+  type: 'message';\n+  children: (Summary | Body)[];\n+}\n+\n+export interface Text extends Literal {\n+  type: 'text';\n+  value: string;\n+}\n+\n+export interface BreakingChange extends Literal {\n+  type: 'breaking-change';\n+  value: '!' | 'BREAKING CHANGE';\n+}\n+\n+export interface Summary extends Parent {\n+  type: 'summary';\n+  children: (Type | Scope | Separator)[];\n+}\n+\n+export interface Type extends Literal {\n+  type: 'type';\n+  value: string;\n+}\n+\n+export interface Scope extends Literal {\n+  type: 'scope';\n+  value: string;\n+}\n+\n+export interface Separator extends Literal {\n+  type: 'separator';\n+  value: ':' | ' #';\n+}\n+\n+export interface Body extends Parent {\n+  type: 'body';\n+  children: (Text | Footer)[];\n+}\n+\n+export interface Footer extends Parent {\n+  type: 'footer';\n+  children: (Token | Separator | Value)[];\n+}\n+\n+export interface Token extends Parent {\n+  type: 'token';\n+  children: (Type | Scope | BreakingChange)[];\n+}\n+\n+export interface Value extends Parent {\n+  type: 'value';\n+  children: (Text | Continuation)[];\n+}\n+\n+export interface Continuation extends Parent {\n+  type: 'continuation';\n+  children: Text[];\n+}\n\n---\n file path A: package.json | file path B: package.json\n\n@@ -5,8 +5,10 @@\n   \"main\": \"index.js\",\n   \"files\": [\n     \"lib\",\n+    \"index.d.ts\",\n     \"index.js\"\n   ],\n+  \"types\": \"index.d.ts\",\n   \"scripts\": {\n     \"test\": \"c8 mocha ./test/*.js\",\n     \"test:snap\": \"CHAI_JEST_SNAPSHOT_UPDATE_ALL=true npm test\",\n\n\n###\n\n", "completion": "feat(types): add TypeScript definitions (#<issue-num>)"}
{"prompt": " file path A: package.json | file path B: package.json\n\n@@ -37,6 +37,8 @@\n     \"mocha\": \"^8.2.1\",\n     \"standard\": \"^16.0.3\",\n     \"unist-util-inspect\": \"^6.0.1\",\n+    \"unist-util-source\": \"^3.0.0\",\n+    \"unist-util-visit\": \"^2.0.3\",\n     \"yargs\": \"^16.2.0\"\n   },\n   \"dependencies\": {\n\n---\n file path A: test/parser.js | file path B: test/parser.js\n\n@@ -1,6 +1,8 @@\n const { describe, beforeEach, it } = require('mocha')\n-const { expect } = require('chai')\n+const { expect, assert } = require('chai')\n const chaiJestSnapshot = require('chai-jest-snapshot')\n+const source = require('unist-util-source')\n+const visit = require('unist-util-visit')\n const { parser } = require('../')\n \n require('chai')\n@@ -50,6 +52,9 @@ describe('<message>', () => {\n         parser('feat(foo: add support for scopes')\n       }).to.throw('unexpected token EOF at 1:33, valid tokens [)]')\n     })\n+    it('contains valid positions for summary with scope', () => {\n+      assertNodePositions('feat(parser): add support for scopes')\n+    })\n   })\n   describe('<footer>', () => {\n     it('parses simple token/separator/value form of footer', () => {\n@@ -72,6 +77,9 @@ describe('<message>', () => {\n       const parsed = parser('fix: address major bug\\nBREAKING CHANGE: first line of breaking change\\n second line of breaking change\\n third line of breaking change')\n       parsed.should.matchSnapshot()\n     })\n+    it('contains valid positions for multiline BREAKING CHANGES, via continuation', () => {\n+      assertNodePositions('fix: address major bug\\nBREAKING CHANGE: first line of breaking change\\n second line of breaking change\\n third line of breaking change')\n+    })\n     it('parses footer tokens with multiple whitespaces after separator', () => {\n       const parsed = parser('fix: some stuff\\n\\nExternal-Id:    1337')\n       parsed.should.matchSnapshot()\n@@ -90,6 +98,9 @@ describe('<message>', () => {\n       const parsed = parser('fix: address major bug\\n\\nthis is a free form body of text')\n       parsed.should.matchSnapshot()\n     })\n+    it('contains valid positions for multiple newlines between summary and body', () => {\n+      assertNodePositions('fix: address major bug\\n\\nthis is a free form body of text')\n+    })\n   })\n   describe('<body>, <newline>*, <footer>+', () => {\n     it('parses footer after body', () => {\n@@ -100,5 +111,18 @@ describe('<message>', () => {\n       const parsed = parser('fix: address major bug\\n\\nthis is the first line of the body\\n\\nthis is the second line of body\\n\\nAuthor: @bcoe\\nRefs #392')\n       parsed.should.matchSnapshot()\n     })\n+    it('contains valid positions for footer after multi-line body', () => {\n+      assertNodePositions('fix: address major bug\\n\\nthis is the first line of the body\\n\\nthis is the second line of body\\n\\nAuthor: @bcoe\\nRefs #392')\n+    })\n   })\n })\n+\n+function assertNodePositions (text) {\n+  visit(parser(text), node => {\n+    if (node.children) return\n+    const valueByPoint = source(node, text)\n+    const valueByOffset = text.substring(node.position.start.offset, node.position.end.offset)\n+    assert.strictEqual(valueByPoint, node.value, `line:column value doesn't match \"${node.type}\", received \"${valueByPoint}\"`)\n+    assert.strictEqual(valueByOffset, node.value, `offset value doesn't match \"${node.type}\", received \"${valueByOffset}\"`)\n+  })\n+}\n\n\n###\n\n", "completion": "test: add node value position lookup tests (#<issue-num>)"}
{"prompt": " file path A: lib/parser.js | file path B: lib/parser.js\n\n@@ -54,6 +54,7 @@ function message (commitText) {\n function summary (scanner) {\n   const node = scanner.enter('summary', [])\n \n+  // <type> ...\n   const t = type(scanner)\n   if (t instanceof Error) {\n     return t\n@@ -61,20 +62,12 @@ function summary (scanner) {\n     node.children.push(t)\n   }\n \n-  let s\n-  if (scanner.peek() === '(') {\n-    // <type> \"(\" <scope> \")\" ...\n-    scanner.next()\n-    s = scope(scanner)\n-    if (s instanceof Error) {\n-      return s\n-    } else {\n-      node.children.push(s)\n-    }\n-    if (scanner.peek() !== ')') {\n-      return scanner.abort(node, [')'])\n-    }\n-    scanner.next()\n+  // ... \"(\" <scope> \")\" ...\n+  let s = scope(scanner)\n+  if (s instanceof Error) {\n+    s = null\n+  } else {\n+    node.children.push(s)\n   }\n \n   // ... [\"!\"] ...\n@@ -139,10 +132,17 @@ function text (scanner) {\n }\n \n /*\n- * <scope>        ::= 1*<any UTF8-octets except newline or parens>\n+ * \"(\" <scope> \")\"        ::= 1*<any UTF8-octets except newline or parens>\n  */\n function scope (scanner) {\n+  if (scanner.peek() !== '(') {\n+    return scanner.abort(scanner.enter('scope', ''))\n+  } else {\n+    scanner.next()\n+  }\n+\n   const node = scanner.enter('scope', '')\n+\n   while (!scanner.eof()) {\n     const token = scanner.peek()\n     if (isParens(token) || isNewline(token)) {\n@@ -151,10 +151,17 @@ function scope (scanner) {\n     node.value += scanner.next()\n   }\n \n+  if (scanner.peek() !== ')') {\n+    throw scanner.abort(node, [')'])\n+  } else {\n+    scanner.exit(node)\n+    scanner.next()\n+  }\n+\n   if (node.value === '') {\n     return scanner.abort(node)\n   } else {\n-    return scanner.exit(node)\n+    return node\n   }\n }\n \n@@ -260,19 +267,10 @@ function token (scanner) {\n     return t\n   } else {\n     node.children.push(t)\n-    // <type> \"(\" <scope> \")\"\n-    if (scanner.peek() === '(') {\n-      scanner.next()\n-      const s = scope(scanner)\n-      if (s instanceof Error) {\n-        return s\n-      } else {\n-        node.children.push(s)\n-      }\n-      if (scanner.peek() !== ')') {\n-        return scanner.abort(node, [')'])\n-      }\n-      scanner.next()\n+    // \"(\" <scope> \")\"\n+    const s = scope(scanner)\n+    if (!(s instanceof Error)) {\n+      node.children.push(s)\n     }\n     // [\"!\"]\n     const b = breakingChange(scanner)\n\n\n###\n\n", "completion": "refactor: contain scope parsing in scope method only (#<issue-num>)"}
{"prompt": " file path A: .github/workflows/release-please.yml | file path B: .github/workflows/release-please.yml\n\n@@ -23,9 +23,9 @@ jobs:\n           node-version: 14\n           registry-url: 'https://external-dot-oss-automation.appspot.com'\n         if: ${{ steps.release.outputs.release_created }}\n-      - run: npm ci\n+      - run: npm i\n         if: ${{ steps.release.outputs.release_created }}\n-      - run: npm publish\n+      - run: npm publish --access=public\n         env:\n           NODE_AUTH_TOKEN: ${{secrets.NPM_TOKEN}}\n         if: ${{ steps.release.outputs.release_created }}\n\n\n###\n\n", "completion": "build: fix publish config"}
{"prompt": " file path A: None | file path B: CHANGELOG.md\n\n@@ -0,0 +1,27 @@\n+# Changelog\n+\n+## [0.2.0](https://www.github.com/conventional-commits/parser/compare/v0.1.0...v0.2.0) (2020-12-28)\n+\n+\n+### \u26a0 BREAKING CHANGES\n+\n+* add position info to nodes (#5)\n+* initial implementation of parser (#1)\n+\n+### Features\n+\n+* refactor footer to be part of message ([#26](https://www.github.com/conventional-commits/parser/issues/26)) ([e06eecb](https://www.github.com/conventional-commits/parser/commit/e06eecb3e8fe9b8418f4584c995cbfcbce4b0f08))\n+* **conventional-changelog:** populate references array ([#27](https://www.github.com/conventional-commits/parser/issues/27)) ([9fbcde2](https://www.github.com/conventional-commits/parser/commit/9fbcde234af26a2b6865d6d549dfe077fd14ce1b))\n+* add conventional-changelog utility ([#19](https://www.github.com/conventional-commits/parser/issues/19)) ([64f21a5](https://www.github.com/conventional-commits/parser/commit/64f21a583766704f35f0c2306c0b477bd6cc1900))\n+* add greedy whitespace tokenizer ([#24](https://www.github.com/conventional-commits/parser/issues/24)) ([b0c64f9](https://www.github.com/conventional-commits/parser/commit/b0c64f9adfb93b29d9e0d522a63cf6e97c22a97f))\n+* add inspect command to debug trees ([#9](https://www.github.com/conventional-commits/parser/issues/9)) ([2967cc4](https://www.github.com/conventional-commits/parser/commit/2967cc48febd88a6a6a3b4c9fb0e8707cfc0ae99))\n+* add node helpers to scanner ([#15](https://www.github.com/conventional-commits/parser/issues/15)) ([ef8a6ca](https://www.github.com/conventional-commits/parser/commit/ef8a6ca2fc965487324747a6c88ba3129218482b))\n+* add position info to nodes ([#5](https://www.github.com/conventional-commits/parser/issues/5)) ([3bbca45](https://www.github.com/conventional-commits/parser/commit/3bbca4556d2561d4031f10e45c0481c15a639ec5))\n+* implement body/footer parsing ([#11](https://www.github.com/conventional-commits/parser/issues/11)) ([e00dcb4](https://www.github.com/conventional-commits/parser/commit/e00dcb472a9e9dcf8f1fb8df7b85fae9a2998656))\n+* **grammar:** ran grammar through linter ([#8](https://www.github.com/conventional-commits/parser/issues/8)) ([1ee86a7](https://www.github.com/conventional-commits/parser/commit/1ee86a7ad82374e46f33c0b865114bb914db5481))\n+* initial implementation of parser ([#1](https://www.github.com/conventional-commits/parser/issues/1)) ([3716f40](https://www.github.com/conventional-commits/parser/commit/3716f40f1f193d24cebe6a1e9e3efb301191cddd))\n+\n+\n+### Bug Fixes\n+\n+* use new parser export name in inspect script ([#23](https://www.github.com/conventional-commits/parser/issues/23)) ([41a2939](https://www.github.com/conventional-commits/parser/commit/41a293961bde9d3ec7d4dca2d2196810acd6ab06))\n\n---\n file path A: package.json | file path B: package.json\n\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@conventional-commits/parser\",\n-  \"version\": \"0.1.0\",\n+  \"version\": \"0.2.0\",\n   \"description\": \"reference implementation of conventionalcommits.org spec\",\n   \"main\": \"index.js\",\n   \"files\": [\n\n\n###\n\n", "completion": "chore: release 0.2.0 (#<issue-num>)"}
{"prompt": " file path A: lib/utils.js | file path B: lib/utils.js\n\n@@ -1,4 +1,5 @@\n const visit = require('unist-util-visit')\n+const NUMBER_REGEX = /^[0-9]+$/\n \n // Converts conventional commit AST into conventional-changelog's\n // output format, see: https://www.npmjs.com/package/conventional-commits-parser\n@@ -16,9 +17,7 @@ function toConventionalChangelogFormat (ast) {\n   let summary\n   // Separate the body and summary nodes, this simplifies the subsequent\n   // tree walking logic:\n-  visit(ast, (node) => {\n-    if (node.type === 'summary' || node.type === 'body') return true\n-  }, (node) => {\n+  visit(ast, ['body', 'summary'], (node) => {\n     switch (node.type) {\n       case 'body':\n         body = node\n@@ -75,6 +74,51 @@ function toConventionalChangelogFormat (ast) {\n     cc.notes.push(breaking)\n   }\n \n+  // Populates references array from footers:\n+  // references: [{\n+  //    action: 'Closes',\n+  //    owner: null,\n+  //    repository: null,\n+  //    issue: '1', raw: '#1',\n+  //    prefix: '#'\n+  // }]\n+  visit(ast, ['footer'], (node) => {\n+    const reference = {\n+      prefix: '#'\n+    }\n+    let hasRefSepartor = false\n+    visit(node, ['type', 'separator', 'text'], (node) => {\n+      switch (node.type) {\n+        case 'type':\n+          // refs, closes, etc:\n+          // TODO(@bcoe): conventional-changelog does not currently use\n+          // \"reference.action\" in its templates:\n+          reference.action = node.value\n+          break\n+        case 'separator':\n+          // Footer of the form \"Refs #99\":\n+          if (node.value.includes('#')) hasRefSepartor = true\n+          break\n+        case 'text':\n+          // Footer of the form \"Refs: #99\"\n+          if (node.value.charAt(0) === '#') {\n+            hasRefSepartor = true\n+            reference.issue = node.value.substring(1)\n+          // TODO(@bcoe): what about references like \"Refs: #99, #102\"?\n+          } else {\n+            reference.issue = node.value\n+          }\n+          break\n+        default:\n+          break\n+      }\n+    })\n+    // TODO(@bcoe): how should references like \"Refs: v8:8940\" work.\n+    if (hasRefSepartor && reference.issue.match(NUMBER_REGEX)) {\n+      cc.references.push(reference)\n+    }\n+  })\n+\n   return cc\n }\n \n\n---\n file path A: test/utils.js | file path B: test/utils.js\n\n@@ -24,5 +24,21 @@ describe('utils', () => {\n       assert.strictEqual(note.title, 'BREAKING CHANGE')\n       assert.strictEqual(note.text, 'hello world')\n     })\n+    it('populates references entry from footer', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo: summary\\n\\nRefs #34'))\n+      assert.strictEqual(parsed.references.length, 1)\n+      const reference = parsed.references[0]\n+      assert.strictEqual(reference.issue, '34')\n+    })\n+    it('populates reference with \":\" separator', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo: summary\\n\\nRefs: #34'))\n+      assert.strictEqual(parsed.references.length, 1)\n+      const reference = parsed.references[0]\n+      assert.strictEqual(reference.issue, '34')\n+    })\n+    it('does not populate reference if it is not numeric', () => {\n+      const parsed = toConventionalChangelogFormat(parser('foo: summary\\n\\nRefs #batman'))\n+      assert.strictEqual(parsed.references.length, 0)\n+    })\n   })\n })\n\n\n###\n\n", "completion": "feat(conventional-changelog): populate references array (#<issue-num>)"}
{"prompt": " file path A: .github/workflows/release-please.yml | file path B: .github/workflows/release-please.yml\n\n@@ -12,6 +12,7 @@ jobs:\n         with:\n           token: ${{ secrets.GITHUB_TOKEN }}\n           release-type: node\n+          bump-minor-pre-major: true\n       # The logic below handles the npm publication:\n       - uses: actions/checkout@v2\n         # these if statements ensure that a publication only occurs when\n\n\n###\n\n", "completion": "build: do not bump major yet"}
{"prompt": " file path A: lib/utils.js | file path B: lib/utils.js\n\n@@ -1,5 +1,4 @@\n const visit = require('unist-util-visit')\n-const parser = require('./parser')\n \n // Converts conventional commit AST into conventional-changelog's\n // output format, see: https://www.npmjs.com/package/conventional-commits-parser\n@@ -79,9 +78,6 @@ function toConventionalChangelogFormat (ast) {\n   return cc\n }\n \n-const ast = parser('feat(hello world)!: this is an awesome feature\\n\\nthis is the body text\\n\\nsecond line of body\\nmoar body')\n-toConventionalChangelogFormat(ast)\n-\n module.exports = {\n   toConventionalChangelogFormat\n }\n\n---\n file path A: scripts/inspect.js | file path B: scripts/inspect.js\n\n@@ -1,12 +1,12 @@\n #!/usr/bin/env node\n \n-const parse = require('..')\n+const { parser } = require('..')\n const inspect = require('unist-util-inspect')\n const { hideBin } = require('yargs/helpers')\n const yargs = require('yargs/yargs')(hideBin(process.argv))\n \n yargs\n   .command('$0 <message>', 'Output the parsed syntax tree', () => {}, (argv) => {\n-    console.log(inspect(parse(argv.message)))\n+    console.log(inspect(parser(argv.message)))\n   })\n   .parse()\n\n\n###\n\n", "completion": "fix: use new parser export name in inspect script (#<issue-num>)"}
{"prompt": " file path A: .github/workflows/ci.yaml | file path B: .github/workflows/ci.yaml\n\n@@ -28,3 +28,12 @@ jobs:\n           node-version: 14\n       - run: npm install\n       - run: npm test\n+  coverage:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/setup-node@v1\n+        with:\n+          node-version: 14\n+      - run: npm install\n+      - run: npm run coverage\n\n---\n file path A: None | file path B: .github/workflows/release-please.yml\n\n@@ -0,0 +1,30 @@\n+on:\n+  push:\n+    branches:\n+      - main\n+name: release-please\n+jobs:\n+  release-please:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: GoogleCloudPlatform/release-please-action@v2\n+        id: release\n+        with:\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+          release-type: node\n+      # The logic below handles the npm publication:\n+      - uses: actions/checkout@v2\n+        # these if statements ensure that a publication only occurs when\n+        # a new release is created:\n+        if: ${{ steps.release.outputs.release_created }}\n+      - uses: actions/setup-node@v1\n+        with:\n+          node-version: 14\n+          registry-url: 'https://external-dot-oss-automation.appspot.com'\n+        if: ${{ steps.release.outputs.release_created }}\n+      - run: npm ci\n+        if: ${{ steps.release.outputs.release_created }}\n+      - run: npm publish\n+        env:\n+          NODE_AUTH_TOKEN: ${{secrets.NPM_TOKEN}}\n+        if: ${{ steps.release.outputs.release_created }}\n\n---\n file path A: None | file path B: .nycrc\n\n@@ -0,0 +1,9 @@\n+{\n+  \"reporter\": [\n+    \"html\",\n+    \"text\"\n+  ],\n+  \"lines\": 96,\n+  \"branches\": \"89\",\n+  \"statements\": \"96\"\n+}\n\n---\n file path A: README.md | file path B: README.md\n\n@@ -1,5 +1,9 @@\n ## Conventional Commits Parser\n \n+![ci](https://github.com/conventional-commits/parser/workflows/ci/badge.svg)\n+![nycrc config on GitHub](https://img.shields.io/nycrc/conventional-commits/parser)\n+[![Conventional Commits](https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg)](https://conventionalcommits.org)\n+\n Reference implementation of Conventional Commits specification.\n \n Outputs a tree structure based on the\n\n---\n file path A: package.json | file path B: package.json\n\n@@ -10,6 +10,7 @@\n   \"scripts\": {\n     \"test\": \"c8 mocha ./test/*.js\",\n     \"test:snap\": \"CHAI_JEST_SNAPSHOT_UPDATE_ALL=true npm test\",\n+    \"coverage\": \"c8 --check-coverage mocha --timeout=8000 ./test/*.js\",\n     \"posttest\": \"standard\",\n     \"fix\": \"standard --fix\",\n     \"inspect\": \"./scripts/inspect.js\"\n\n\n###\n\n", "completion": "build: configure automated releases (#<issue-num>)"}
{"prompt": " file path A: index.js | file path B: index.js\n\n@@ -7,11 +7,8 @@ const { isWhitespace, isNewline, isParens } = require('./lib/type-checks')\n  */\n function message (commitText) {\n   const scanner = new Scanner(commitText.trim())\n-  const start = scanner.position()\n-  const node = {\n-    type: 'message',\n-    children: []\n-  }\n+  const node = scanner.enter('message', [])\n+\n   // <summary>\n   const s = summary(scanner)\n   if (s instanceof Error) {\n@@ -20,8 +17,7 @@ function message (commitText) {\n     node.children.push(s)\n   }\n   if (scanner.eof()) {\n-    node.position = { start, end: scanner.position() }\n-    return node\n+    return scanner.exit(node)\n   }\n \n   // <summary> <newline>* <body>\n@@ -30,11 +26,10 @@ function message (commitText) {\n       scanner.next()\n     }\n   } else {\n-    throw invalidToken(scanner, ['none'])\n+    throw scanner.abort(node)\n   }\n   node.children.push(body(scanner))\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n@@ -43,11 +38,7 @@ function message (commitText) {\n  *\n  */\n function summary (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'summary',\n-    children: []\n-  }\n+  const node = scanner.enter('summary', [])\n \n   const t = type(scanner)\n   if (t instanceof Error) {\n@@ -67,7 +58,7 @@ function summary (scanner) {\n       node.children.push(s)\n     }\n     if (scanner.peek() !== ')') {\n-      return invalidToken(scanner, [')'])\n+      return scanner.abort(node, [')'])\n     }\n     scanner.next()\n   }\n@@ -83,25 +74,20 @@ function summary (scanner) {\n   // ... \": \" <text>\n   const sep = separator(scanner)\n   if (sep instanceof Error) {\n-    return invalidToken(scanner, [!s && '(', !b && '!', ':'])\n+    return scanner.abort(node, [!s && '(', !b && '!', ':'])\n   } else {\n     node.children.push(sep)\n   }\n \n   node.children.push(text(scanner))\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n  * <type>         ::= 1*<any UTF8-octets except newline or parens or [\"!\"] \":\" or whitespace>\n  */\n function type (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'type',\n-    value: ''\n-  }\n+  const node = scanner.enter('type', '')\n   while (!scanner.eof()) {\n     const token = scanner.peek()\n     if (isParens(token) || isWhitespace(token) || isNewline(token) || token === '!' || token === ':') {\n@@ -110,10 +96,9 @@ function type (scanner) {\n     node.value += scanner.next()\n   }\n   if (node.value === '') {\n-    return invalidToken(scanner, ['type'])\n+    return scanner.abort(node)\n   } else {\n-    node.position = { start, end: scanner.position() }\n-    return node\n+    return scanner.exit(node)\n   }\n }\n \n@@ -121,11 +106,7 @@ function type (scanner) {\n  * <text>         ::= 1*<any UTF8-octets except newline>\n  */\n function text (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'text',\n-    value: ''\n-  }\n+  const node = scanner.enter('text', '')\n   while (!scanner.eof()) {\n     const token = scanner.peek()\n     if (isNewline(token)) {\n@@ -133,19 +114,14 @@ function text (scanner) {\n     }\n     node.value += scanner.next()\n   }\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n  * <scope>        ::= 1*<any UTF8-octets except newline or parens>\n  */\n function scope (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'scope',\n-    value: ''\n-  }\n+  const node = scanner.enter('scope', '')\n   while (!scanner.eof()) {\n     const token = scanner.peek()\n     if (isParens(token) || isNewline(token)) {\n@@ -155,10 +131,9 @@ function scope (scanner) {\n   }\n \n   if (node.value === '') {\n-    return invalidToken(scanner, ['scope'])\n+    return scanner.abort(node)\n   } else {\n-    node.position = { start, end: scanner.position() }\n-    return node\n+    return scanner.exit(node)\n   }\n }\n \n@@ -168,16 +143,12 @@ function scope (scanner) {\n  *                  | [<text>]\n  */\n function body (scanner) {\n-  const node = {\n-    type: 'body',\n-    children: []\n-  }\n-  const start = scanner.position()\n+  const node = scanner.enter('body', [])\n   // 1*<footer>\n   while (!scanner.eof()) {\n     const f = footer(scanner)\n     if (f instanceof Error) {\n-      scanner.rewind(start)\n+      scanner.abort(node)\n       node.children = []\n       // [<text>], <newline>, <body>*\n       const t = text(scanner)\n@@ -198,19 +169,14 @@ function body (scanner) {\n       node.children.push(f)\n     }\n   }\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n  * <footer>       ::= <token> <separator> *<whitespace> <value> <newline>?\n */\n function footer (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'footer',\n-    children: []\n-  }\n+  const node = scanner.enter('footer', [])\n   // <token>\n   const t = token(scanner)\n   if (t instanceof Error) {\n@@ -238,8 +204,7 @@ function footer (scanner) {\n   if (isNewline(scanner.peek())) {\n     scanner.next()\n   }\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n@@ -248,20 +213,14 @@ function footer (scanner) {\n  *                 |  <type>\n  */\n function token (scanner) {\n-  const node = {\n-    type: 'token',\n-    children: []\n-  }\n-\n+  const node = scanner.enter('token', [])\n   // \"BREAKING CHANGE\"\n-  const start = scanner.position()\n   const b = breakingChange(scanner)\n   if (b instanceof Error) {\n-    scanner.rewind(start)\n+    scanner.abort(node)\n   } else {\n     node.children.push(b)\n-    node.position = { start, end: scanner.position() }\n-    return node\n+    return scanner.exit(node)\n   }\n \n   // <type>\n@@ -279,7 +238,9 @@ function token (scanner) {\n       } else {\n         node.children.push(s)\n       }\n-      if (scanner.peek() !== ')') return invalidToken(scanner, [')'])\n+      if (scanner.peek() !== ')') {\n+        return scanner.abort(node, [')'])\n+      }\n       scanner.next()\n     }\n     // [\"!\"]\n@@ -288,29 +249,23 @@ function token (scanner) {\n       node.children.push(b)\n     }\n   }\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n  * <breaking-change> ::= \"!\" | \"BREAKING CHANGE\"\n  */\n function breakingChange (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'breaking-change',\n-    value: ''\n-  }\n+  const node = scanner.enter('breaking-change', '')\n   if (scanner.peek() === '!') {\n     node.value = scanner.next()\n   } else if (scanner.peekLiteral('BREAKING CHANGE')) {\n     node.value = scanner.next('BREAKING CHANGE'.length)\n   }\n   if (node.value === '') {\n-    return invalidToken(scanner, ['BREAKING CHANGE'])\n+    return scanner.abort(node, ['BREAKING CHANGE'])\n   } else {\n-    node.position = { start, end: scanner.position() }\n-    return node\n+    return scanner.exit(node)\n   }\n }\n \n@@ -319,66 +274,49 @@ function breakingChange (scanner) {\n  *                 |  <text>\n  */\n function value (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'value',\n-    children: []\n-  }\n+  const node = scanner.enter('value', [])\n   node.children.push(text(scanner))\n   let c\n   // 1*<continuation>\n   while (!((c = continuation(scanner)) instanceof Error)) {\n     node.children.push(c)\n   }\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n  * <newline> <whitespace> <text>\n  */\n function continuation (scanner) {\n-  const node = {\n-    type: 'continuation',\n-    children: []\n-  }\n-  const start = scanner.position()\n+  const node = scanner.enter('continuation', [])\n   if (isNewline(scanner.peek())) {\n     scanner.next()\n     if (isWhitespace(scanner.peek())) {\n       scanner.next()\n       node.children.push(text(scanner))\n     } else {\n-      scanner.rewind(start)\n-      return invalidToken(scanner, ['continuation'])\n+      return scanner.abort(node)\n     }\n   } else {\n-    return invalidToken(scanner, ['continuation'])\n+    return scanner.abort(node)\n   }\n-  node.position = { start, end: scanner.position() }\n-  return node\n+  return scanner.exit(node)\n }\n \n /*\n  * <separator>    ::= \": \" | \" #\"\n  */\n function separator (scanner) {\n-  const start = scanner.position()\n-  const node = {\n-    type: 'separator',\n-    value: ''\n-  }\n-\n+  const node = scanner.enter('separator', '')\n   // ': '\n   if (scanner.peek() === ':') {\n     scanner.next()\n     if (scanner.peek() === ' ') {\n       node.value = ': '\n       scanner.next()\n-      node.position = { start, end: scanner.position() }\n-      return node\n+      return scanner.exit(node)\n     } else {\n-      return invalidToken(scanner, ['separator'])\n+      return scanner.abort(node)\n     }\n   }\n \n@@ -388,25 +326,13 @@ function separator (scanner) {\n     if (scanner.peek() === '#') {\n       scanner.next()\n       node.value = ' #'\n-      node.position = { start, end: scanner.position() }\n+      return scanner.exit(node)\n     } else {\n-      scanner.rewind(start)\n-      return invalidToken(scanner, ['separator'])\n+      return scanner.abort(node)\n     }\n-  } else {\n-    return invalidToken(scanner, ['separator'])\n   }\n-  return node\n-}\n \n-function invalidToken (scanner, expected) {\n-  const validTokens = expected.filter(Boolean).join(', ')\n-  if (scanner.eof()) {\n-    return Error(`unexpected token EOF valid tokens [${validTokens}]`)\n-  } else {\n-    const pos = scanner.position()\n-    return Error(`unexpected token '${scanner.peek()}' at position ${pos.line}:${pos.column} valid tokens [${validTokens}]`)\n-  }\n+  return scanner.abort(node)\n }\n \n module.exports = message\n\n---\n file path A: lib/scanner.js | file path B: lib/scanner.js\n\n@@ -27,12 +27,6 @@ class Scanner {\n     return token\n   }\n \n-  nextIgnoreWhitespace () {\n-    this.consumeWhitespace()\n-    this.next()\n-    this.consumeWhitespace()\n-  }\n-\n   consumeWhitespace () {\n     while (isWhitespace(this.peek())) {\n       this.next()\n@@ -60,6 +54,32 @@ class Scanner {\n   rewind (pos) {\n     this.pos = pos\n   }\n+\n+  enter (type, content) {\n+    const position = { start: this.position() }\n+    return Array.isArray(content)\n+      ? { type, children: content, position }\n+      : { type, value: content, position }\n+  }\n+\n+  exit (node) {\n+    node.position.end = this.position()\n+    return node\n+  }\n+\n+  abort (node, expectedTokens) {\n+    const position = `${this.pos.line}:${this.pos.column}`\n+    const validTokens = expectedTokens\n+      ? expectedTokens.filter(Boolean).join(', ')\n+      : `<${node.type}>`\n+\n+    const error = this.eof()\n+      ? Error(`unexpected token EOF at ${position}, valid tokens [${validTokens}]`)\n+      : Error(`unexpected token '${this.peek()}' at ${position}, valid tokens [${validTokens}]`)\n+\n+    this.rewind(node.position.start)\n+    return error\n+  }\n }\n \n module.exports = Scanner\n\n---\n file path A: test.js | file path B: test.js\n\n@@ -29,18 +29,18 @@ describe('<message>', () => {\n     it('throws error when \":\" token is missing', () => {\n       expect(() => {\n         parser('feat add support for scopes')\n-      }).to.throw(\"unexpected token ' ' at position 1:5 valid tokens [(, !, :]\")\n+      }).to.throw(\"unexpected token ' ' at 1:5, valid tokens [(, !, :]\")\n       expect(() => {\n         parser('feat( foo ) add support for scopes')\n-      }).to.throw(\"unexpected token ' ' at position 1:12 valid tokens [!, :]\")\n+      }).to.throw(\"unexpected token ' ' at 1:12, valid tokens [!, :]\")\n       expect(() => {\n         parser('feat(bar)! add support for breaking change')\n-      }).to.throw(\"unexpected token ' ' at position 1:11 valid tokens [:]\")\n+      }).to.throw(\"unexpected token ' ' at 1:11, valid tokens [:]\")\n     })\n     it('throws error when closing \")\" token is missing', () => {\n       expect(() => {\n         parser('feat(foo: add support for scopes')\n-      }).to.throw('unexpected token EOF valid tokens [)]')\n+      }).to.throw('unexpected token EOF at 1:33, valid tokens [)]')\n     })\n   })\n   describe('<footer>', () => {\n\n---\n file path A: test.js.snap | file path B: test.js.snap\n\n@@ -315,9 +315,9 @@ Object {\n                   \"offset\": 44,\n                 },\n                 \"start\": Object {\n-                  \"column\": 37,\n+                  \"column\": 12,\n                   \"line\": 2,\n-                  \"offset\": 69,\n+                  \"offset\": 44,\n                 },\n               },\n               \"type\": \"token\",\n@@ -749,9 +749,9 @@ Object {\n                   \"offset\": 29,\n                 },\n                 \"start\": Object {\n-                  \"column\": 18,\n+                  \"column\": 7,\n                   \"line\": 2,\n-                  \"offset\": 40,\n+                  \"offset\": 29,\n                 },\n               },\n               \"type\": \"token\",\n@@ -1873,9 +1873,9 @@ Object {\n                   \"offset\": 63,\n                 },\n                 \"start\": Object {\n-                  \"column\": 1,\n-                  \"line\": 5,\n-                  \"offset\": 71,\n+                  \"column\": 7,\n+                  \"line\": 4,\n+                  \"offset\": 63,\n                 },\n               },\n               \"type\": \"token\",\n@@ -1972,9 +1972,9 @@ Object {\n                   \"offset\": 75,\n                 },\n                 \"start\": Object {\n-                  \"column\": 10,\n+                  \"column\": 5,\n                   \"line\": 5,\n-                  \"offset\": 80,\n+                  \"offset\": 75,\n                 },\n               },\n               \"type\": \"token\",\n@@ -2237,9 +2237,9 @@ Object {\n                   \"offset\": 99,\n                 },\n                 \"start\": Object {\n-                  \"column\": 1,\n-                  \"line\": 8,\n-                  \"offset\": 107,\n+                  \"column\": 7,\n+                  \"line\": 7,\n+                  \"offset\": 99,\n                 },\n               },\n               \"type\": \"token\",\n@@ -2336,9 +2336,9 @@ Object {\n                   \"offset\": 111,\n                 },\n                 \"start\": Object {\n-                  \"column\": 10,\n+                  \"column\": 5,\n                   \"line\": 8,\n-                  \"offset\": 116,\n+                  \"offset\": 111,\n                 },\n               },\n               \"type\": \"token\",\n\n\n###\n\n", "completion": "feat: add node helpers to scanner (#<issue-num>)"}
{"prompt": " file path A: package.json | file path B: package.json\n\n@@ -3,6 +3,10 @@\n   \"version\": \"0.1.0\",\n   \"description\": \"reference implementation of conventionalcommits.org spec\",\n   \"main\": \"index.js\",\n+  \"files\": [\n+    \"lib\",\n+    \"index.js\"\n+  ],\n   \"scripts\": {\n     \"test\": \"c8 mocha test.js\",\n     \"test:snap\": \"CHAI_JEST_SNAPSHOT_UPDATE_ALL=true npm test\",\n\n\n###\n\n", "completion": "chore: limit files included in npm tarball (#<issue-num>)"}
{"prompt": " file path A: inspect.js | file path B: None\n\n@@ -1,16 +0,0 @@\n-const parse = require('.')\n-const inspect = require('unist-util-inspect')\n-const { hideBin } = require('yargs/helpers')\n-const yargs = require('yargs/yargs')(hideBin(process.argv))\n-\n-const argv = yargs\n-  .command('$0', 'Output the parsed syntax tree\\n\\nUsage: npm run inspect <message>')\n-  .argv\n-\n-const message = argv._[0]\n-\n-if (message) {\n-  console.log(inspect(parse(message)))\n-} else {\n-  yargs.showHelp()\n-}\n\n---\n file path A: package.json | file path B: package.json\n\n@@ -8,7 +8,7 @@\n     \"test:snap\": \"CHAI_JEST_SNAPSHOT_UPDATE_ALL=true npm test\",\n     \"posttest\": \"standard\",\n     \"fix\": \"standard --fix\",\n-    \"inspect\": \"node inspect.js\"\n+    \"inspect\": \"./scripts/inspect.js\"\n   },\n   \"repository\": {\n     \"type\": \"git\",\n\n---\n file path A: None | file path B: scripts/inspect.js\n\n@@ -0,0 +1,12 @@\n+#!/usr/bin/env node\n+\n+const parse = require('..')\n+const inspect = require('unist-util-inspect')\n+const { hideBin } = require('yargs/helpers')\n+const yargs = require('yargs/yargs')(hideBin(process.argv))\n+\n+yargs\n+  .command('$0 <message>', 'Output the parsed syntax tree', () => {}, (argv) => {\n+    console.log(inspect(parse(argv.message)))\n+  })\n+  .parse()\n\n\n###\n\n", "completion": "refactor: use yargs' command feature"}
{"prompt": " file path A: None | file path B: inspect.js\n\n@@ -0,0 +1,16 @@\n+const parse = require('.')\n+const inspect = require('unist-util-inspect')\n+const { hideBin } = require('yargs/helpers')\n+const yargs = require('yargs/yargs')(hideBin(process.argv))\n+\n+const argv = yargs\n+  .command('$0', 'Output the parsed syntax tree\\n\\nUsage: npm run inspect <message>')\n+  .argv\n+\n+const message = argv._[0]\n+\n+if (message) {\n+  console.log(inspect(parse(message)))\n+} else {\n+  yargs.showHelp()\n+}\n\n---\n file path A: package.json | file path B: package.json\n\n@@ -7,7 +7,8 @@\n     \"test\": \"c8 mocha test.js\",\n     \"test:snap\": \"CHAI_JEST_SNAPSHOT_UPDATE_ALL=true npm test\",\n     \"posttest\": \"standard\",\n-    \"fix\": \"standard --fix\"\n+    \"fix\": \"standard --fix\",\n+    \"inspect\": \"node inspect.js\"\n   },\n   \"repository\": {\n     \"type\": \"git\",\n@@ -29,6 +30,8 @@\n     \"chai\": \"^4.2.0\",\n     \"chai-jest-snapshot\": \"^2.0.0\",\n     \"mocha\": \"^8.2.1\",\n-    \"standard\": \"^16.0.3\"\n+    \"standard\": \"^16.0.3\",\n+    \"unist-util-inspect\": \"^6.0.1\",\n+    \"yargs\": \"^16.2.0\"\n   }\n }\n\n\n###\n\n", "completion": "feat: add inspect command to debug trees (#<issue-num>)"}
{"prompt": " file path A: README.md | file path B: README.md\n\n@@ -17,45 +17,50 @@ parser('feat(parser): add support for scopes')\n This parsing library is based on the following grammar. An effort will be made\n to keep this in sync with the written specification on conventionalcommits.org.\n \n-```bnf\n-# See: https://tools.ietf.org/html/rfc3629#section-4\n-<UTF8-octets>  ::= 1*<UTF8-char>\n-<CR>           ::= \"0x000D\"\n-<LF>           ::= \"0x000A\"\n-<newline>      ::= <CR>? <LF>\n-<parens>       ::= \"(\" | \")\"\n-<ZWNBSP>       ::= \"U+FEFF\"\n-<TAB>          ::= \"U+0009\"\n-<VT>           ::= \"U+000B\"\n-<FF>           ::= \"U+000C\"\n-<SP>           ::= \"U+0020\"\n-<NBSP>         ::= \"U+00A0\"\n-# See: https://www.ecma-international.org/ecma-262/11.0/index.html#sec-white-space\n-<USP>          ::= \"Any other Unicode \u201cSpace_Separator\u201d code point\"\n-<whitespace>   ::= <ZWNBSP> | <TAB> | <VT> | <FF> | <SP> | <NBSP> | <USP>\n-\n-<message>      ::= <summary> <newline> <body-footer>\n-                |  <summary>\n-\n-<summary>      ::= <type> \"(\" <scope> \")\" <summary-sep> <text>\n-                |  <type> <summary-sep> <text>\n-<type>         ::= 1*<any UTF8-octets except newline or parens or \":\" or \"!:\" or whitespace>\n-<scope>        ::= 1*<any UTF8-octets except newline or parens>\n-<text>         ::= 1*<any UTF8-octets except newline>\n-<summary-sep>  ::= \"!\"? \":\" *<whitespace>\n-\n-<body-footer>  ::= 1*<footer>\n-               ::= <body> <newline> 1*<body-footer>\n-               ::= <body>\n-\n-<footer>       ::= <token> <separator> *<whitespace> <value> <newline>?\n-<token>        ::= \"BREAKING CHANGE\"\n-                |  <type> \"(\" <scope> \")\"\n-                |  <type>\n-<separator>    ::= <summary-sep> | ' #'\n-<value>        ::= <text> 1*<continuation>\n-                |  <text>\n-<continuation> ::= <newline> <whitespace> <text>\n-\n-<body>         ::= <text>? <newline>\n+```ebnf\n+/* See: https://tools.ietf.org/html/rfc3629#section-4 */\n+<UTF8-char>     ::= \"Placeholder for UTF-8 grammar\"\n+<UTF8-octets>   ::= <UTF8char>+\n+\n+<CR>            ::= \"0x000D\"\n+<LF>            ::= \"0x000A\"\n+<newline>       ::= [<CR>], <LF>\n+<parens>        ::= \"(\" | \")\"\n+<ZWNBSP>        ::= \"U+FEFF\"\n+<TAB>           ::= \"U+0009\"\n+<VT>            ::= \"U+000B\"\n+<FF>            ::= \"U+000C\"\n+<SP>            ::= \"U+0020\"\n+<NBSP>          ::= \"U+00A0\"\n+/* See: https://www.ecma-international.org/ecma-262/11.0/index.html#sec-white-space */\n+<USP>           ::= \"Any other Unicode 'Space_Separator' code point\"\n+/* Any non-newline whitespace: */\n+<whitespace>    ::= <ZWNBSP> | <TAB> | <VT> | <FF> | <SP> | <NBSP> | <USP>\n+\n+<message>       ::= <summary>, <newline>, <bodyfooter>\n+                 |  <summary>\n+\n+<summary>       ::= <type>, \"(\", <scope>, \")\", [\"!\"], \":\", <whitespace>*, <text>\n+                 |  <type>, [\"!\"], \":\", <whitespace>*, <text>\n+<type>          ::= <any UTF8-octets except newline or parens or \":\" or \"!:\" or whitespace>+\n+<scope>         ::= <any UTF8-octets except newline or parens>+\n+<text>          ::= <any UTF8-octets except newline>+\n+\n+/*\n+ * Note: if the first <body> node starts with \"BREAKING CHANGE:\" this should\n+ * be treated by parsers as a breaking change marker upstream:\n+ */\n+<body-footer>   ::= <footer>+\n+                 | <body>, <newline>, <body-footer>*\n+                 | <body>\n+<body>          ::= [<text>]\n+\n+<footer>        ::= <token>, <separator>, <whitespace>*, <value>, [<newline>]\n+<token>         ::= \"BREAKING CHANGE\"\n+                 |  <type>, \"(\" <scope> \")\", [\"!\"]\n+                 |  <type>, [\"!\"]\n+<separator>     ::= \":\" | \" #\"\n+<value>         ::= <text>, <continuation>+\n+                 | <text>\n+<continuation> ::= <newline>, <whitespace>, <text>\n ```\n\n\n###\n\n", "completion": "feat(grammar): ran grammar through linter (#<issue-num>)"}
