{"prompt": " file path A: src/txmempool.cpp | file path B: src/txmempool.cpp\n\n@@ -260,8 +260,8 @@ CTxMemPool::setEntries CTxMemPool::AssumeCalculateMemPoolAncestors(\n     const Limits& limits,\n     bool fSearchForParents /* = true */) const\n {\n-    auto result{Assume(CalculateMemPoolAncestors(entry, limits, fSearchForParents))};\n-    if (!result) {\n+    auto result{CalculateMemPoolAncestors(entry, limits, fSearchForParents)};\n+    if (!Assume(result)) {\n         LogPrintLevel(BCLog::MEMPOOL, BCLog::Level::Error, \"%s: CalculateMemPoolAncestors failed unexpectedly, continuing with empty ancestor set (%s)\\n\",\n                       calling_fn_name, util::ErrorString(result).original);\n     }\n\n\n###\n\n", "completion": "refactor: Work around Werror=free-nonheap-object in AssumeCalculateMemPoolAncestors"}
{"prompt": " file path A: test/functional/feature_startupnotify.py | file path B: test/functional/feature_startupnotify.py\n\n@@ -29,9 +29,14 @@ class StartupNotifyTest(BitcoinTestFramework):\n         self.wait_until(lambda: os.path.exists(tmpdir_file))\n \n         self.log.info(\"Test -startupnotify is executed once\")\n-        with open(tmpdir_file, \"r\", encoding=\"utf8\") as f:\n-            file_content = f.read()\n-            assert_equal(file_content.count(FILE_NAME), 1)\n+\n+        def get_count():\n+            with open(tmpdir_file, \"r\", encoding=\"utf8\") as f:\n+                file_content = f.read()\n+                return file_content.count(FILE_NAME)\n+\n+        self.wait_until(lambda: get_count() > 0)\n+        assert_equal(get_count(), 1)\n \n         self.log.info(\"Test node is fully started\")\n         assert_equal(self.nodes[0].getblockcount(), 200)\n\n\n###\n\n", "completion": "test: Fix feature_startupnotify intermittent issue"}
{"prompt": " file path A: src/bench/coin_selection.cpp | file path B: src/bench/coin_selection.cpp\n\n@@ -99,9 +99,9 @@ static CAmount make_hard_case(int utxos, std::vector<OutputGroup>& utxo_pool)\n     utxo_pool.clear();\n     CAmount target = 0;\n     for (int i = 0; i < utxos; ++i) {\n-        target += (CAmount)1 << (utxos+i);\n-        add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n-        add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n+        target += CAmount{1} << (utxos+i);\n+        add_coin(CAmount{1} << (utxos+i), 2*i, utxo_pool);\n+        add_coin((CAmount{1} << (utxos+i)) + (CAmount{1} << (utxos-1-i)), 2*i + 1, utxo_pool);\n     }\n     return target;\n }\n\n---\n file path A: src/crypto/siphash.cpp | file path B: src/crypto/siphash.cpp\n\n@@ -119,10 +119,10 @@ uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n     SIPROUND;\n     SIPROUND;\n     v0 ^= d;\n-    v3 ^= ((uint64_t)4) << 59;\n+    v3 ^= (uint64_t{4}) << 59;\n     SIPROUND;\n     SIPROUND;\n-    v0 ^= ((uint64_t)4) << 59;\n+    v0 ^= (uint64_t{4}) << 59;\n     v2 ^= 0xFF;\n     SIPROUND;\n     SIPROUND;\n@@ -159,7 +159,7 @@ uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint3\n     SIPROUND;\n     SIPROUND;\n     v0 ^= d;\n-    d = (((uint64_t)36) << 56) | extra;\n+    d = ((uint64_t{36}) << 56) | extra;\n     v3 ^= d;\n     SIPROUND;\n     SIPROUND;\n\n---\n file path A: src/cuckoocache.h | file path B: src/cuckoocache.h\n\n@@ -344,7 +344,7 @@ public:\n         collection_flags.setup(size);\n         epoch_flags.resize(size);\n         // Set to 45% as described above\n-        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        epoch_size = std::max(uint32_t{1}, (45 * size) / 100);\n         // Initially set to wait for a whole epoch\n         epoch_heuristic_counter = epoch_size;\n         return size;\n\n---\n file path A: src/random.h | file path B: src/random.h\n\n@@ -200,7 +200,7 @@ public:\n             return rand64() >> (64 - bits);\n         } else {\n             if (bitbuf_size < bits) FillBitBuffer();\n-            uint64_t ret = bitbuf & (~(uint64_t)0 >> (64 - bits));\n+            uint64_t ret = bitbuf & (~uint64_t{0} >> (64 - bits));\n             bitbuf >>= bits;\n             bitbuf_size -= bits;\n             return ret;\n\n---\n file path A: src/script/interpreter.cpp | file path B: src/script/interpreter.cpp\n\n@@ -1303,7 +1303,7 @@ public:\n         // Serialize the nSequence\n         if (nInput != nIn && (fHashSingle || fHashNone))\n             // let the others update at will\n-            ::Serialize(s, (int)0);\n+            ::Serialize(s, int{0});\n         else\n             ::Serialize(s, txTo.vin[nInput].nSequence);\n     }\n\n---\n file path A: src/test/checkqueue_tests.cpp | file path B: src/test/checkqueue_tests.cpp\n\n@@ -194,7 +194,7 @@ static void Correct_Queue_range(std::vector<size_t> range)\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n {\n     std::vector<size_t> range;\n-    range.push_back((size_t)0);\n+    range.push_back(size_t{0});\n     Correct_Queue_range(range);\n }\n /** Test that 1 check is correct\n@@ -202,7 +202,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n {\n     std::vector<size_t> range;\n-    range.push_back((size_t)1);\n+    range.push_back(size_t{1});\n     Correct_Queue_range(range);\n }\n /** Test that MAX check is correct\n\n---\n file path A: src/test/crypto_tests.cpp | file path B: src/test/crypto_tests.cpp\n\n@@ -723,14 +723,14 @@ BOOST_AUTO_TEST_CASE(countbits_tests)\n             // Check handling of zero.\n             BOOST_CHECK_EQUAL(CountBits(0), 0U);\n         } else if (i < 10) {\n-            for (uint64_t j = (uint64_t)1 << (i - 1); (j >> i) == 0; ++j) {\n+            for (uint64_t j = uint64_t{1} << (i - 1); (j >> i) == 0; ++j) {\n                 // Exhaustively test up to 10 bits\n                 BOOST_CHECK_EQUAL(CountBits(j), i);\n             }\n         } else {\n             for (int k = 0; k < 1000; k++) {\n                 // Randomly test 1000 samples of each length above 10 bits.\n-                uint64_t j = ((uint64_t)1) << (i - 1) | ctx.randbits(i - 1);\n+                uint64_t j = (uint64_t{1}) << (i - 1) | ctx.randbits(i - 1);\n                 BOOST_CHECK_EQUAL(CountBits(j), i);\n             }\n         }\n\n---\n file path A: src/test/fuzz/p2p_transport_serialization.cpp | file path B: src/test/fuzz/p2p_transport_serialization.cpp\n\n@@ -24,7 +24,7 @@ void initialize_p2p_transport_serialization()\n FUZZ_TARGET_INIT(p2p_transport_serialization, initialize_p2p_transport_serialization)\n {\n     // Construct deserializer, with a dummy NodeId\n-    V1TransportDeserializer deserializer{Params(), (NodeId)0, SER_NETWORK, INIT_PROTO_VERSION};\n+    V1TransportDeserializer deserializer{Params(), NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n     V1TransportSerializer serializer{};\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n \n\n---\n file path A: src/test/fuzz/versionbits.cpp | file path B: src/test/fuzz/versionbits.cpp\n\n@@ -55,7 +55,7 @@ public:\n \n     bool Condition(int32_t version) const\n     {\n-        uint32_t mask = ((uint32_t)1) << m_bit;\n+        uint32_t mask = (uint32_t{1}) << m_bit;\n         return (((version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) && (version & mask) != 0);\n     }\n \n\n---\n file path A: src/test/merkle_tests.cpp | file path B: src/test/merkle_tests.cpp\n\n@@ -50,7 +50,7 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n         // For each of the lower bits in count that are 0, do 1 step. Each\n         // corresponds to an inner value that existed before processing the\n         // current leaf, and each needs a hash to combine it.\n-        for (level = 0; !(count & (((uint32_t)1) << level)); level++) {\n+        for (level = 0; !(count & ((uint32_t{1}) << level)); level++) {\n             if (pbranch) {\n                 if (matchh) {\n                     pbranch->push_back(inner[level]);\n@@ -74,12 +74,12 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n     int level = 0;\n     // As long as bit number level in count is zero, skip it. It means there\n     // is nothing left at this level.\n-    while (!(count & (((uint32_t)1) << level))) {\n+    while (!(count & ((uint32_t{1}) << level))) {\n         level++;\n     }\n     uint256 h = inner[level];\n     bool matchh = matchlevel == level;\n-    while (count != (((uint32_t)1) << level)) {\n+    while (count != ((uint32_t{1}) << level)) {\n         // If we reach this point, h is an inner value that is not the top.\n         // We combine it with itself (Bitcoin's special rule for odd levels in\n         // the tree) to produce a higher level one.\n@@ -89,10 +89,10 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n         CHash256().Write(h).Write(h).Finalize(h);\n         // Increment count to the value it would have if two entries at this\n         // level had existed.\n-        count += (((uint32_t)1) << level);\n+        count += ((uint32_t{1}) << level);\n         level++;\n         // And propagate the result upwards accordingly.\n-        while (!(count & (((uint32_t)1) << level))) {\n+        while (!(count & ((uint32_t{1}) << level))) {\n             if (pbranch) {\n                 if (matchh) {\n                     pbranch->push_back(inner[level]);\n\n---\n file path A: src/test/random_tests.cpp | file path B: src/test/random_tests.cpp\n\n@@ -94,7 +94,7 @@ BOOST_AUTO_TEST_CASE(fastrandom_randbits)\n         for (int j = 0; j < 1000; ++j) {\n             uint64_t rangebits = ctx1.randbits(bits);\n             BOOST_CHECK_EQUAL(rangebits >> bits, 0U);\n-            uint64_t range = ((uint64_t)1) << bits | rangebits;\n+            uint64_t range = (uint64_t{1}) << bits | rangebits;\n             uint64_t rand = ctx2.randrange(range);\n             BOOST_CHECK(rand < range);\n         }\n\n---\n file path A: src/test/serialize_tests.cpp | file path B: src/test/serialize_tests.cpp\n\n@@ -123,17 +123,17 @@ BOOST_AUTO_TEST_CASE(varints_bitpatterns)\n     CDataStream ss(SER_DISK, 0);\n     ss << VARINT_MODE(0, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"00\"); ss.clear();\n     ss << VARINT_MODE(0x7f, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n-    ss << VARINT_MODE((int8_t)0x7f, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n+    ss << VARINT_MODE(int8_t{0x7f}, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n     ss << VARINT_MODE(0x80, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n-    ss << VARINT((uint8_t)0x80); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n+    ss << VARINT(uint8_t{0x80}); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n     ss << VARINT_MODE(0x1234, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n-    ss << VARINT_MODE((int16_t)0x1234, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n+    ss << VARINT_MODE(int16_t{0x1234}, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n     ss << VARINT_MODE(0xffff, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n-    ss << VARINT((uint16_t)0xffff); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n+    ss << VARINT(uint16_t{0xffff}); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n     ss << VARINT_MODE(0x123456, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n-    ss << VARINT_MODE((int32_t)0x123456, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n+    ss << VARINT_MODE(int32_t{0x123456}, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n     ss << VARINT(0x80123456U); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n-    ss << VARINT((uint32_t)0x80123456U); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n+    ss << VARINT(uint32_t{0x80123456U}); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n     ss << VARINT(0xffffffff); BOOST_CHECK_EQUAL(HexStr(ss), \"8efefefe7f\"); ss.clear();\n     ss << VARINT_MODE(0x7fffffffffffffffLL, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"fefefefefefefefe7f\"); ss.clear();\n     ss << VARINT(0xffffffffffffffffULL); BOOST_CHECK_EQUAL(HexStr(ss), \"80fefefefefefefefe7f\"); ss.clear();\n\n---\n file path A: src/test/streams_tests.cpp | file path B: src/test/streams_tests.cpp\n\n@@ -144,10 +144,10 @@ BOOST_AUTO_TEST_CASE(bitstream_reader_writer)\n     CDataStream data_copy(data);\n     uint32_t serialized_int1;\n     data >> serialized_int1;\n-    BOOST_CHECK_EQUAL(serialized_int1, (uint32_t)0x7700C35A); // NOTE: Serialized as LE\n+    BOOST_CHECK_EQUAL(serialized_int1, uint32_t{0x7700C35A}); // NOTE: Serialized as LE\n     uint16_t serialized_int2;\n     data >> serialized_int2;\n-    BOOST_CHECK_EQUAL(serialized_int2, (uint16_t)0x1072); // NOTE: Serialized as LE\n+    BOOST_CHECK_EQUAL(serialized_int2, uint16_t{0x1072}); // NOTE: Serialized as LE\n \n     BitStreamReader<CDataStream> bit_reader(data_copy);\n     BOOST_CHECK_EQUAL(bit_reader.Read(1), 0U);\n\n---\n file path A: src/test/util_tests.cpp | file path B: src/test/util_tests.cpp\n\n@@ -810,8 +810,8 @@ BOOST_AUTO_TEST_CASE(test_ParseInt64)\n     BOOST_CHECK(ParseInt64(\"01234\", &n) && n == 1234LL); // no octal\n     BOOST_CHECK(ParseInt64(\"2147483647\", &n) && n == 2147483647LL);\n     BOOST_CHECK(ParseInt64(\"-2147483648\", &n) && n == -2147483648LL);\n-    BOOST_CHECK(ParseInt64(\"9223372036854775807\", &n) && n == (int64_t)9223372036854775807);\n-    BOOST_CHECK(ParseInt64(\"-9223372036854775808\", &n) && n == (int64_t)-9223372036854775807-1);\n+    BOOST_CHECK(ParseInt64(\"9223372036854775807\", &n) && n == int64_t{9223372036854775807});\n+    BOOST_CHECK(ParseInt64(\"-9223372036854775808\", &n) && n == int64_t{-9223372036854775807-1});\n     BOOST_CHECK(ParseInt64(\"-1234\", &n) && n == -1234LL);\n     // Invalid values\n     BOOST_CHECK(!ParseInt64(\"\", &n));\n@@ -907,8 +907,8 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n     BOOST_CHECK(ParseUInt32(\"1234\", &n) && n == 1234);\n     BOOST_CHECK(ParseUInt32(\"01234\", &n) && n == 1234); // no octal\n     BOOST_CHECK(ParseUInt32(\"2147483647\", &n) && n == 2147483647);\n-    BOOST_CHECK(ParseUInt32(\"2147483648\", &n) && n == (uint32_t)2147483648);\n-    BOOST_CHECK(ParseUInt32(\"4294967295\", &n) && n == (uint32_t)4294967295);\n+    BOOST_CHECK(ParseUInt32(\"2147483648\", &n) && n == uint32_t{2147483648});\n+    BOOST_CHECK(ParseUInt32(\"4294967295\", &n) && n == uint32_t{4294967295});\n     BOOST_CHECK(ParseUInt32(\"+1234\", &n) && n == 1234);\n     BOOST_CHECK(ParseUInt32(\"00000000000000001234\", &n) && n == 1234);\n     BOOST_CHECK(ParseUInt32(\"00000000000000000000\", &n) && n == 0);\n\n---\n file path A: src/test/validation_chainstate_tests.cpp | file path B: src/test/validation_chainstate_tests.cpp\n\n@@ -32,7 +32,7 @@ BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n         COutPoint outp{txid, 0};\n         newcoin.nHeight = 1;\n         newcoin.out.nValue = InsecureRand32();\n-        newcoin.out.scriptPubKey.assign((uint32_t)56, 1);\n+        newcoin.out.scriptPubKey.assign(uint32_t{56}, 1);\n         coins_view.AddCoin(outp, std::move(newcoin), false);\n \n         return outp;\n\n---\n file path A: src/test/validation_flush_tests.cpp | file path B: src/test/validation_flush_tests.cpp\n\n@@ -31,7 +31,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         COutPoint outp{txid, 0};\n         newcoin.nHeight = 1;\n         newcoin.out.nValue = InsecureRand32();\n-        newcoin.out.scriptPubKey.assign((uint32_t)56, 1);\n+        newcoin.out.scriptPubKey.assign(uint32_t{56}, 1);\n         coins_view.AddCoin(outp, std::move(newcoin), false);\n \n         return outp;\n\n---\n file path A: src/util/moneystr.cpp | file path B: src/util/moneystr.cpp\n\n@@ -34,7 +34,7 @@ std::string FormatMoney(const CAmount n)\n         str.erase(str.size()-nTrim, nTrim);\n \n     if (n < 0)\n-        str.insert((unsigned int)0, 1, '-');\n+        str.insert(uint32_t{0}, 1, '-');\n     return str;\n }\n \n\n---\n file path A: src/versionbits.cpp | file path B: src/versionbits.cpp\n\n@@ -195,7 +195,7 @@ protected:\n \n public:\n     explicit VersionBitsConditionChecker(Consensus::DeploymentPos id_) : id(id_) {}\n-    uint32_t Mask(const Consensus::Params& params) const { return ((uint32_t)1) << params.vDeployments[id].bit; }\n+    uint32_t Mask(const Consensus::Params& params) const { return (uint32_t{1}) << params.vDeployments[id].bit; }\n };\n \n } // namespace\n\n---\n file path A: src/wallet/bdb.cpp | file path B: src/wallet/bdb.cpp\n\n@@ -100,7 +100,7 @@ void BerkeleyEnvironment::Close()\n     if (ret != 0)\n         LogPrintf(\"BerkeleyEnvironment::Close: Error %d closing database environment: %s\\n\", ret, DbEnv::strerror(ret));\n     if (!fMockDb)\n-        DbEnv((uint32_t)0).remove(strPath.c_str(), 0);\n+        DbEnv(uint32_t{0}).remove(strPath.c_str(), 0);\n \n     if (error_file) fclose(error_file);\n \n\n---\n file path A: src/wallet/scriptpubkeyman.cpp | file path B: src/wallet/scriptpubkeyman.cpp\n\n@@ -2123,7 +2123,7 @@ bool DescriptorScriptPubKeyMan::TopUp(unsigned int size)\n     if (size > 0) {\n         target_size = size;\n     } else {\n-        target_size = std::max(gArgs.GetIntArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 1);\n+        target_size = std::max(gArgs.GetIntArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), int64_t{1});\n     }\n \n     // Calculate the new range_end\n\n---\n file path A: src/wallet/spend.cpp | file path B: src/wallet/spend.cpp\n\n@@ -667,7 +667,7 @@ util::Result<SelectionResult> AutomaticCoinSelection(const CWallet& wallet, Coin\n         // possible) if we cannot fund the transaction otherwise.\n         if (wallet.m_spend_zero_conf_change) {\n             ordered_filters.push_back({CoinEligibilityFilter(0, 1, 2)});\n-            ordered_filters.push_back({CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3))});\n+            ordered_filters.push_back({CoinEligibilityFilter(0, 1, std::min(size_t{4}, max_ancestors/3), std::min(size_t{4}, max_descendants/3))});\n             ordered_filters.push_back({CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2)});\n             // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n             // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n\n---\n file path A: src/wallet/test/coinselector_tests.cpp | file path B: src/wallet/test/coinselector_tests.cpp\n\n@@ -121,9 +121,9 @@ static CAmount make_hard_case(int utxos, std::vector<COutput>& utxo_pool)\n     utxo_pool.clear();\n     CAmount target = 0;\n     for (int i = 0; i < utxos; ++i) {\n-        target += (CAmount)1 << (utxos+i);\n-        add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n-        add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n+        target += CAmount{1} << (utxos+i);\n+        add_coin(CAmount{1} << (utxos+i), 2*i, utxo_pool);\n+        add_coin((CAmount{1} << (utxos+i)) + (CAmount{1} << (utxos-1-i)), 2*i + 1, utxo_pool);\n     }\n     return target;\n }\n\n---\n file path A: src/wallet/test/wallet_tests.cpp | file path B: src/wallet/test/wallet_tests.cpp\n\n@@ -736,10 +736,10 @@ BOOST_FIXTURE_TEST_CASE(wallet_descriptor_test, BasicTestingSetup)\n     std::vector<unsigned char> malformed_record;\n     CVectorWriter vw(0, 0, malformed_record, 0);\n     vw << std::string(\"notadescriptor\");\n-    vw << (uint64_t)0;\n-    vw << (int32_t)0;\n-    vw << (int32_t)0;\n-    vw << (int32_t)1;\n+    vw << uint64_t{0};\n+    vw << int32_t{0};\n+    vw << int32_t{0};\n+    vw << int32_t{1};\n \n     SpanReader vr{0, 0, malformed_record};\n     WalletDescriptor w_desc;\n\n\n###\n\n", "completion": "refactor: use braced init for integer constants instead of c style casts"}
{"prompt": " file path A: test/functional/wallet_crosschain.py | file path B: test/functional/wallet_crosschain.py\n\n@@ -36,20 +36,28 @@ class WalletCrossChain(BitcoinTestFramework):\n         self.log.info(\"Creating wallets\")\n \n         node0_wallet = os.path.join(self.nodes[0].datadir, 'node0_wallet')\n+        node0_wallet_backup = os.path.join(self.nodes[0].datadir, 'node0_wallet.bak')\n         self.nodes[0].createwallet(node0_wallet)\n+        self.nodes[0].backupwallet(node0_wallet_backup)\n         self.nodes[0].unloadwallet(node0_wallet)\n         node1_wallet = os.path.join(self.nodes[1].datadir, 'node1_wallet')\n+        node1_wallet_backup = os.path.join(self.nodes[0].datadir, 'node1_wallet.bak')\n         self.nodes[1].createwallet(node1_wallet)\n+        self.nodes[1].backupwallet(node1_wallet_backup)\n         self.nodes[1].unloadwallet(node1_wallet)\n \n-        self.log.info(\"Loading wallets into nodes with a different genesis blocks\")\n+        self.log.info(\"Loading/restoring wallets into nodes with a different genesis block\")\n \n         if self.options.descriptors:\n             assert_raises_rpc_error(-18, 'Wallet file verification failed.', self.nodes[0].loadwallet, node1_wallet)\n             assert_raises_rpc_error(-18, 'Wallet file verification failed.', self.nodes[1].loadwallet, node0_wallet)\n+            assert_raises_rpc_error(-18, 'Wallet file verification failed.', self.nodes[0].restorewallet, 'w', node1_wallet_backup)\n+            assert_raises_rpc_error(-18, 'Wallet file verification failed.', self.nodes[1].restorewallet, 'w', node0_wallet_backup)\n         else:\n             assert_raises_rpc_error(-4, 'Wallet files should not be reused across chains.', self.nodes[0].loadwallet, node1_wallet)\n             assert_raises_rpc_error(-4, 'Wallet files should not be reused across chains.', self.nodes[1].loadwallet, node0_wallet)\n+            assert_raises_rpc_error(-4, 'Wallet files should not be reused across chains.', self.nodes[0].restorewallet, 'w', node1_wallet_backup)\n+            assert_raises_rpc_error(-4, 'Wallet files should not be reused across chains.', self.nodes[1].restorewallet, 'w', node0_wallet_backup)\n \n         if not self.options.descriptors:\n             self.log.info(\"Override cross-chain wallet load protection\")\n\n\n###\n\n", "completion": "test: add coverage for cross-chain wallet restore"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -29,6 +29,7 @@ base_template: &BASE_TEMPLATE\n     - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n     - git fetch $CIRRUS_REPO_CLONE_URL \"pull/${CIRRUS_PR}/merge\"\n     - git checkout FETCH_HEAD  # Use merged changes to detect silent merge conflicts\n+                               # Also, the merge commit is used to lint COMMIT_RANGE=\"HEAD~..HEAD\"\n \n main_template: &MAIN_TEMPLATE\n   timeout_in: 120m  # https://cirrus-ci.org/faq/#instance-timed-out\n\n---\n file path A: ci/lint/06_script.sh | file path B: ci/lint/06_script.sh\n\n@@ -6,9 +6,8 @@\n \n export LC_ALL=C\n \n-GIT_HEAD=$(git rev-parse HEAD)\n if [ -n \"$CIRRUS_PR\" ]; then\n-  COMMIT_RANGE=\"${CIRRUS_BASE_SHA}..$GIT_HEAD\"\n+  COMMIT_RANGE=\"HEAD~..HEAD\"\n   echo\n   git log --no-merges --oneline \"$COMMIT_RANGE\"\n   echo\n\n\n###\n\n", "completion": "ci: Properly set COMMIT_RANGE in lint task"}
{"prompt": " file path A: ci/test/00_setup_env_native_tsan.sh | file path B: ci/test/00_setup_env_native_tsan.sh\n\n@@ -11,4 +11,4 @@ export DOCKER_NAME_TAG=ubuntu:22.04\n export PACKAGES=\"clang-13 llvm-13 libc++abi-13-dev libc++-13-dev python3-zmq\"\n export DEP_OPTS=\"CC=clang-13 CXX='clang++-13 -stdlib=libc++'\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-zmq CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER -DDEBUG_LOCKCONTENTION' CXXFLAGS='-g' --with-sanitizers=thread CC=clang-13 CXX='clang++-13 -stdlib=libc++'\"\n+export BITCOIN_CONFIG=\"--enable-zmq CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER -DDEBUG_LOCKCONTENTION' CXXFLAGS='-g' --with-sanitizers=thread\"\n\n\n###\n\n", "completion": "ci: Remove duplicate CC and CXX from tsan task"}
{"prompt": " file path A: ci/test/00_setup_env_native_asan.sh | file path B: ci/test/00_setup_env_native_asan.sh\n\n@@ -23,4 +23,4 @@ export PACKAGES=\"systemtap-sdt-dev clang llvm python3-zmq qtbase5-dev qttools5-d\n export DOCKER_NAME_TAG=ubuntu:22.04\n export NO_DEPENDS=1\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-usdt --enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=address,integer,undefined CC=clang CXX=clang++\"\n+export BITCOIN_CONFIG=\"--enable-c++20 --enable-usdt --enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=address,integer,undefined CC=clang CXX=clang++\"\n\n---\n file path A: ci/test/00_setup_env_native_tidy.sh | file path B: ci/test/00_setup_env_native_tidy.sh\n\n@@ -15,5 +15,5 @@ export RUN_FUNCTIONAL_TESTS=false\n export RUN_FUZZ_TESTS=false\n export RUN_TIDY=true\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"CC=clang CXX=clang++ --enable-c++20 --with-incompatible-bdb --disable-hardening CFLAGS='-O0 -g0' CXXFLAGS='-O0 -g0'\"\n+export BITCOIN_CONFIG=\"CC=clang CXX=clang++ --with-incompatible-bdb --disable-hardening CFLAGS='-O0 -g0' CXXFLAGS='-O0 -g0'\"\n export CCACHE_SIZE=200M\n\n\n###\n\n", "completion": "ci: Move `--enable-c++20` from \"tidy\" task back to \"ASan...\" one"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -228,10 +228,10 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_native_qt5.sh\"\n \n task:\n-  name: '[TSan, depends, gui] [jammy]'\n+  name: '[TSan, depends] [bookworm]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n-    image: ubuntu:jammy\n+    image: debian:bookworm\n     cpu: 6  # Increase CPU and Memory to avoid timeout\n     memory: 24G\n   env:\n\n---\n file path A: ci/test/00_setup_env_native_tsan.sh | file path B: ci/test/00_setup_env_native_tsan.sh\n\n@@ -7,8 +7,8 @@\n export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_native_tsan\n-export DOCKER_NAME_TAG=ubuntu:22.04\n-export PACKAGES=\"clang-13 llvm-13 libc++abi-13-dev libc++-13-dev python3-zmq\"\n-export DEP_OPTS=\"CC=clang-13 CXX='clang++-13 -stdlib=libc++'\"\n+export DOCKER_NAME_TAG=debian:bookworm  # For clang-15\n+export PACKAGES=\"clang-15 llvm-15 libc++abi-15-dev libc++-15-dev python3-zmq\"\n+export DEP_OPTS=\"CC=clang-15 CXX='clang++-15 -stdlib=libc++' NO_QR=1\"  # qr disabled due to libqrencode 3.4.4 compile failure, https://github.com/bitcoin/bitcoin/pull/26768#issuecomment-1367403430\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-zmq CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER -DDEBUG_LOCKCONTENTION' CXXFLAGS='-g' --with-sanitizers=thread CC=clang-13 CXX='clang++-13 -stdlib=libc++'\"\n+export BITCOIN_CONFIG=\"--enable-zmq CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER -DDEBUG_LOCKCONTENTION' CXXFLAGS='-g' --with-sanitizers=thread\"\n\n\n###\n\n", "completion": "ci: Use clang-15 in tsan task"}
{"prompt": " file path A: test/functional/wallet_migration.py | file path B: test/functional/wallet_migration.py\n\n@@ -258,7 +258,7 @@ class WalletMigrationTest(BitcoinTestFramework):\n         self.log.info(\"Test migration of a wallet with watchonly imports\")\n         imports0 = self.create_legacy_wallet(\"imports0\")\n \n-        # Exteranl address label\n+        # External address label\n         imports0.setlabel(default.getnewaddress(), \"external\")\n \n         # Normal non-watchonly tx\n@@ -311,6 +311,13 @@ class WalletMigrationTest(BitcoinTestFramework):\n         assert_raises_rpc_error(-5, \"Invalid or non-wallet transaction id\", watchonly.gettransaction, received_txid)\n         assert_equal(len(watchonly.listtransactions(include_watchonly=True)), 3)\n \n+        # Check that labels were migrated and persisted to watchonly wallet\n+        self.nodes[0].unloadwallet(\"imports0_watchonly\")\n+        self.nodes[0].loadwallet(\"imports0_watchonly\")\n+        labels = watchonly.listlabels()\n+        assert \"external\" in labels\n+        assert \"imported\" in labels\n+\n     def test_no_privkeys(self):\n         default = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n \n\n\n###\n\n", "completion": "test: wallet: check that labels are migrated to watchonly wallet"}
{"prompt": " file path A: test/sanitizer_suppressions/tsan | file path B: test/sanitizer_suppressions/tsan\n\n@@ -35,8 +35,5 @@ race:libzmq\n # https://github.com/bitcoin/bitcoin/issues/20618\n race:CZMQAbstractPublishNotifier::SendZmqMessage\n \n-# https://github.com/bitcoin/bitcoin/pull/20218, https://github.com/bitcoin/bitcoin/pull/20745\n-race:epoll_ctl\n-\n # https://github.com/bitcoin/bitcoin/issues/23366\n race:std::__1::ios_base::*\n\n\n###\n\n", "completion": "test: Drop no longer needed `race:epoll_ctl` TSan suppression"}
{"prompt": " file path A: test/functional/wallet_avoidreuse.py | file path B: test/functional/wallet_avoidreuse.py\n\n@@ -120,6 +120,8 @@ class AvoidReuseTest(BitcoinTestFramework):\n         assert_raises_rpc_error(-8, \"Wallet flag is already set to false\", self.nodes[0].setwalletflag, 'avoid_reuse', False)\n         assert_raises_rpc_error(-8, \"Wallet flag is already set to true\", self.nodes[1].setwalletflag, 'avoid_reuse', True)\n \n+        assert_raises_rpc_error(-8, \"Unknown wallet flag: abc\", self.nodes[0].setwalletflag, 'abc', True)\n+\n         # Create a wallet with avoid reuse, and test that disabling it afterwards persists\n         self.nodes[1].createwallet(wallet_name=\"avoid_reuse_persist\", avoid_reuse=True)\n         w = self.nodes[1].get_wallet_rpc(\"avoid_reuse_persist\")\n\n\n###\n\n", "completion": "test: add coverage for unknown wallet flag in `setwalletflag`"}
{"prompt": " file path A: ci/test/00_setup_env_native_fuzz_with_msan.sh | file path B: ci/test/00_setup_env_native_fuzz_with_msan.sh\n\n@@ -17,7 +17,7 @@ export PACKAGES=\"clang-12 llvm-12 cmake\"\n # BDB generates false-positives and will be removed in future\n export DEP_OPTS=\"NO_BDB=1 NO_QT=1 CC='clang' CXX='clang++' CFLAGS='${MSAN_FLAGS}' CXXFLAGS='${MSAN_AND_LIBCXX_FLAGS}' libevent_cflags='${MSAN_FLAGS}' sqlite_cflags='${MSAN_FLAGS}' zeromq_cxxflags='-std=c++17 ${MSAN_AND_LIBCXX_FLAGS}'\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-fuzz --with-sanitizers=fuzzer,memory --disable-hardening --with-asm=no --prefix=${DEPENDS_DIR}/x86_64-pc-linux-gnu/ CC=clang CXX=clang++ CFLAGS='${MSAN_FLAGS}' CXXFLAGS='${MSAN_AND_LIBCXX_FLAGS}'\"\n+export BITCOIN_CONFIG=\"--enable-fuzz --with-sanitizers=fuzzer,memory --disable-hardening --with-asm=no CC=clang CXX=clang++ CFLAGS='${MSAN_FLAGS}' CXXFLAGS='${MSAN_AND_LIBCXX_FLAGS}'\"\n export USE_MEMORY_SANITIZER=\"true\"\n export RUN_UNIT_TESTS=\"false\"\n export RUN_FUNCTIONAL_TESTS=\"false\"\n\n---\n file path A: ci/test/00_setup_env_native_msan.sh | file path B: ci/test/00_setup_env_native_msan.sh\n\n@@ -17,7 +17,7 @@ export PACKAGES=\"clang-12 llvm-12 cmake\"\n # BDB generates false-positives and will be removed in future\n export DEP_OPTS=\"NO_BDB=1 NO_QT=1 CC='clang' CXX='clang++' CFLAGS='${MSAN_FLAGS}' CXXFLAGS='${MSAN_AND_LIBCXX_FLAGS}' libevent_cflags='${MSAN_FLAGS}' sqlite_cflags='${MSAN_FLAGS}' zeromq_cxxflags='-std=c++17 ${MSAN_AND_LIBCXX_FLAGS}'\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--with-sanitizers=memory --disable-hardening --with-asm=no --prefix=${DEPENDS_DIR}/x86_64-pc-linux-gnu/ CC=clang CXX=clang++ CFLAGS='${MSAN_FLAGS}' CXXFLAGS='${MSAN_AND_LIBCXX_FLAGS}'\"\n+export BITCOIN_CONFIG=\"--with-sanitizers=memory --disable-hardening --with-asm=no CC=clang CXX=clang++ CFLAGS='${MSAN_FLAGS}' CXXFLAGS='${MSAN_AND_LIBCXX_FLAGS}'\"\n export USE_MEMORY_SANITIZER=\"true\"\n export RUN_FUNCTIONAL_TESTS=\"false\"\n export CCACHE_SIZE=250M\n\n\n###\n\n", "completion": "ci: remove --prefix from msan job"}
{"prompt": " file path A: test/get_previous_releases.py | file path B: test/get_previous_releases.py\n\n@@ -148,7 +148,8 @@ def download_binary(tag, args) -> int:\n     ret = subprocess.run(['tar', '-zxf', tarball, '-C', tag,\n                           '--strip-components=1',\n                           'bitcoin-{tag}'.format(tag=tag[1:])]).returncode\n-    if ret:\n+    if ret != 0:\n+        print(f\"Failed to extract the {tag} tarball\")\n         return ret\n \n     Path(tarball).unlink()\n\n\n###\n\n", "completion": "test: improve error msg on previous release tarball extraction failure"}
{"prompt": " file path A: test/get_previous_releases.py | file path B: test/get_previous_releases.py\n\n@@ -152,6 +152,34 @@ def download_binary(tag, args) -> int:\n         return ret\n \n     Path(tarball).unlink()\n+\n+    if tag >= \"v23\" and platform == \"arm64-apple-darwin\":\n+        # Starting with v23 there are arm64 binaries for ARM (e.g. M1, M2) macs, but they have to be signed to run\n+        binary_path = f'{os.getcwd()}/{tag}/bin/'\n+\n+        for arm_binary in os.listdir(binary_path):\n+            # Is it already signed?\n+            ret = subprocess.run(\n+                ['codesign', '-v', binary_path + arm_binary],\n+                stderr=subprocess.DEVNULL,  # Suppress expected stderr output\n+            ).returncode\n+            if ret == 1:\n+                # Have to self-sign the binary\n+                ret = subprocess.run(\n+                    ['codesign', '-s', '-', binary_path + arm_binary]\n+                ).returncode\n+                if ret != 0:\n+                    print(f\"Failed to self-sign {tag} {arm_binary} arm64 binary\")\n+                    return 1\n+\n+                # Confirm success\n+                ret = subprocess.run(\n+                    ['codesign', '-v', binary_path + arm_binary]\n+                ).returncode\n+                if ret != 0:\n+                    print(f\"Failed to verify the self-signed {tag} {arm_binary} arm64 binary\")\n+                    return 1\n+\n     return 0\n \n \n\n\n###\n\n", "completion": "test: self-sign previous release binaries for arm64 macOS"}
{"prompt": " file path A: test/functional/wallet_fundrawtransaction.py | file path B: test/functional/wallet_fundrawtransaction.py\n\n@@ -983,6 +983,8 @@ class RawTransactionsTest(BitcoinTestFramework):\n         # are selected, the transaction will end up being too large, so it\n         # shouldn't use BnB and instead fall back to Knapsack but that behavior\n         # is not implemented yet. For now we just check that we get an error.\n+        # First, force the wallet to bulk-generate the addresses we'll need.\n+        recipient.keypoolrefill(1500)\n         for _ in range(1500):\n             outputs[recipient.getnewaddress()] = 0.1\n         wallet.sendmany(\"\", outputs)\n\n---\n file path A: test/functional/wallet_sendall.py | file path B: test/functional/wallet_sendall.py\n\n@@ -320,6 +320,10 @@ class SendallTest(BitcoinTestFramework):\n     # This tests needs to be the last one otherwise @cleanup will fail with \"Transaction too large\" error\n     def sendall_fails_with_transaction_too_large(self):\n         self.log.info(\"Test that sendall fails if resulting transaction is too large\")\n+\n+        # Force the wallet to bulk-generate the addresses we'll need\n+        self.wallet.keypoolrefill(1600)\n+\n         # create many inputs\n         outputs = {self.wallet.getnewaddress(): 0.000025 for _ in range(1600)}\n         self.def_wallet.sendmany(amounts=outputs)\n\n\n###\n\n", "completion": "test: speed up wallet_fundrawtransaction.py and wallet_sendall.py"}
{"prompt": " file path A: test/functional/wallet_keypool.py | file path B: test/functional/wallet_keypool.py\n\n@@ -204,6 +204,9 @@ class KeyPoolTest(BitcoinTestFramework):\n         res = w2.walletcreatefundedpsbt(inputs=[], outputs=[{destination: 0.00010000}], options={\"subtractFeeFromOutputs\": [0], \"feeRate\": 0.00010, \"changeAddress\": addr.pop()})\n         assert_equal(\"psbt\" in res, True)\n \n+        if not self.options.descriptors:\n+            msg = \"Error: Private keys are disabled for this wallet\"\n+            assert_raises_rpc_error(-4, msg, w2.keypoolrefill, 100)\n \n if __name__ == '__main__':\n     KeyPoolTest().main()\n\n\n###\n\n", "completion": "test: call `keypoolrefill` with private keys disabled should throw an error"}
{"prompt": " file path A: test/lint/check-doc.py | file path B: test/lint/check-doc.py\n\n@@ -15,7 +15,7 @@ import re\n \n FOLDER_GREP = 'src'\n FOLDER_TEST = 'src/test/'\n-REGEX_ARG = r'(?:ForceSet|SoftSet|Get|Is)(?:Bool)?Args?(?:Set)?\\(\"(-[^\"]+)\"'\n+REGEX_ARG = r'\\b(?:GetArg|GetArgs|GetBoolArg|GetIntArg|GetPathArg|IsArgSet|get_net)\\(\"(-[^\"]+)\"'\n REGEX_DOC = r'AddArg\\(\"(-[^\"=]+?)(?:=|\")'\n CMD_ROOT_DIR = '$(git rev-parse --show-toplevel)/{}'.format(FOLDER_GREP)\n CMD_GREP_ARGS = r\"git grep --perl-regexp '{}' -- {} ':(exclude){}'\".format(REGEX_ARG, CMD_ROOT_DIR, FOLDER_TEST)\n\n\n###\n\n", "completion": "test: Improve `check-doc.py` pattern"}
{"prompt": " file path A: test/functional/feature_pruning.py | file path B: test/functional/feature_pruning.py\n\n@@ -11,6 +11,7 @@ This test takes 30 mins or more (up to 2 hours)\n import os\n \n from test_framework.blocktools import (\n+    MIN_BLOCKS_TO_KEEP,\n     create_block,\n     create_coinbase,\n )\n@@ -333,7 +334,7 @@ class PruneTest(BitcoinTestFramework):\n         assert has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n \n         # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n-        self.generate(node, 288, sync_fun=self.no_op)\n+        self.generate(node, MIN_BLOCKS_TO_KEEP, sync_fun=self.no_op)\n         prune(1000)\n         assert not has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n         assert not has_block(3), \"blk00003.dat is still there, should be pruned by now\"\n\n---\n file path A: test/functional/test_framework/blocktools.py | file path B: test/functional/test_framework/blocktools.py\n\n@@ -61,6 +61,7 @@ WITNESS_COMMITMENT_HEADER = b\"\\xaa\\x21\\xa9\\xed\"\n \n NORMAL_GBT_REQUEST_PARAMS = {\"rules\": [\"segwit\"]}\n VERSIONBITS_LAST_OLD_BLOCK_VERSION = 4\n+MIN_BLOCKS_TO_KEEP = 288\n \n \n def create_block(hashprev=None, coinbase=None, ntime=None, *, version=None, tmpl=None, txlist=None):\n\n\n###\n\n", "completion": "test: Introduce MIN_BLOCKS_TO_KEEP constant"}
{"prompt": " file path A: test/functional/feature_pruning.py | file path B: test/functional/feature_pruning.py\n\n@@ -10,8 +10,10 @@ This test takes 30 mins or more (up to 2 hours)\n \"\"\"\n import os\n \n-from test_framework.blocktools import create_coinbase\n-from test_framework.messages import CBlock\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n from test_framework.script import (\n     CScript,\n     OP_NOP,\n@@ -48,21 +50,7 @@ def mine_large_blocks(node, n):\n     previousblockhash = int(best_block[\"hash\"], 16)\n \n     for _ in range(n):\n-        # Build the coinbase transaction (with large scriptPubKey)\n-        coinbase_tx = create_coinbase(height)\n-        coinbase_tx.vin[0].nSequence = 2 ** 32 - 1\n-        coinbase_tx.vout[0].scriptPubKey = big_script\n-        coinbase_tx.rehash()\n-\n-        # Build the block\n-        block = CBlock()\n-        block.nVersion = best_block[\"version\"]\n-        block.hashPrevBlock = previousblockhash\n-        block.nTime = mine_large_blocks.nTime\n-        block.nBits = int('207fffff', 16)\n-        block.nNonce = 0\n-        block.vtx = [coinbase_tx]\n-        block.hashMerkleRoot = block.calc_merkle_root()\n+        block = create_block(hashprev=previousblockhash, ntime=mine_large_blocks.nTime, coinbase=create_coinbase(height, script_pubkey=big_script))\n         block.solve()\n \n         # Submit to the node\n\n---\n file path A: test/functional/test_framework/blocktools.py | file path B: test/functional/test_framework/blocktools.py\n\n@@ -120,7 +120,7 @@ def script_BIP34_coinbase_height(height):\n     return CScript([CScriptNum(height)])\n \n \n-def create_coinbase(height, pubkey=None, extra_output_script=None, fees=0, nValue=50):\n+def create_coinbase(height, pubkey=None, *, script_pubkey=None, extra_output_script=None, fees=0, nValue=50):\n     \"\"\"Create a coinbase transaction.\n \n     If pubkey is passed in, the coinbase output will be a P2PK output;\n@@ -138,6 +138,8 @@ def create_coinbase(height, pubkey=None, extra_output_script=None, fees=0, nValu\n         coinbaseoutput.nValue += fees\n     if pubkey is not None:\n         coinbaseoutput.scriptPubKey = key_to_p2pk_script(pubkey)\n+    elif script_pubkey is not None:\n+        coinbaseoutput.scriptPubKey = script_pubkey\n     else:\n         coinbaseoutput.scriptPubKey = CScript([OP_TRUE])\n     coinbase.vout = [coinbaseoutput]\n\n---\n file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -85,6 +85,7 @@ EXTENDED_SCRIPTS = [\n     'feature_pruning.py',\n     'feature_dbcrash.py',\n     'feature_index_prune.py',\n+    'wallet_pruning.py --legacy-wallet',\n ]\n \n BASE_SCRIPTS = [\n\n---\n file path A: None | file path B: test/functional/wallet_pruning.py\n\n@@ -0,0 +1,158 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test wallet import on pruned node.\"\"\"\n+import os\n+\n+from test_framework.util import assert_equal, assert_raises_rpc_error\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    create_block\n+)\n+from test_framework.blocktools import create_coinbase\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+from test_framework.script import (\n+    CScript,\n+    OP_RETURN,\n+    OP_TRUE,\n+)\n+\n+class WalletPruningTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, descriptors=False)\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.wallet_names = []\n+        self.extra_args = [\n+            [], # node dedicated to mining\n+            ['-prune=550'], # node dedicated to testing pruning\n+        ]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_bdb()\n+\n+    def mine_large_blocks(self, node, n):\n+        # Get the block parameters for the first block\n+        best_block = node.getblock(node.getbestblockhash())\n+        height = int(best_block[\"height\"]) + 1\n+        self.nTime = max(self.nTime, int(best_block[\"time\"])) + 1\n+        previousblockhash = int(best_block[\"hash\"], 16)\n+        big_script = CScript([OP_RETURN] + [OP_TRUE] * 950000)\n+        for _ in range(n):\n+            block = create_block(hashprev=previousblockhash, ntime=self.nTime, coinbase=create_coinbase(height, script_pubkey=big_script))\n+            block.solve()\n+\n+            # Submit to the node\n+            node.submitblock(block.serialize().hex())\n+\n+            previousblockhash = block.sha256\n+            height += 1\n+\n+            # Simulate 10 minutes of work time per block\n+            # Important for matching a timestamp with a block +- some window\n+            self.nTime += 600\n+            for n in self.nodes:\n+                if n.running:\n+                    n.setmocktime(self.nTime) # Update node's time to accept future blocks\n+        self.sync_all()\n+\n+    def test_wallet_import_pruned(self, wallet_name):\n+        self.log.info(\"Make sure we can import wallet when pruned and required blocks are still available\")\n+\n+        wallet_file = wallet_name + \".dat\"\n+        wallet_birthheight = self.get_birthheight(wallet_file)\n+\n+        # Verify that the block at wallet's birthheight is available at the pruned node\n+        self.nodes[1].getblock(self.nodes[1].getblockhash(wallet_birthheight))\n+\n+        # Import wallet into pruned node\n+        self.nodes[1].createwallet(wallet_name=\"wallet_pruned\", descriptors=False, load_on_startup=True)\n+        self.nodes[1].importwallet(os.path.join(self.nodes[0].datadir, wallet_file))\n+\n+        # Make sure that prune node's wallet correctly accounts for balances\n+        assert_equal(self.nodes[1].getbalance(), self.nodes[0].getbalance())\n+\n+        self.log.info(\"- Done\")\n+\n+    def test_wallet_import_pruned_with_missing_blocks(self, wallet_name):\n+        self.log.info(\"Make sure we cannot import wallet when pruned and required blocks are not available\")\n+\n+        wallet_file = wallet_name + \".dat\"\n+        wallet_birthheight = self.get_birthheight(wallet_file)\n+\n+        # Verify that the block at wallet's birthheight is not available at the pruned node\n+        assert_raises_rpc_error(-1, \"Block not available (pruned data)\", self.nodes[1].getblock, self.nodes[1].getblockhash(wallet_birthheight))\n+\n+        # Make sure wallet cannot be imported because of missing blocks\n+        # This will try to rescan blocks `TIMESTAMP_WINDOW` (2h) before the wallet birthheight.\n+        # There are 6 blocks an hour, so 11 blocks (excluding birthheight).\n+        assert_raises_rpc_error(-4, f\"Pruned blocks from height {wallet_birthheight - 11} required to import keys. Use RPC call getblockchaininfo to determine your pruned height.\", self.nodes[1].importwallet, os.path.join(self.nodes[0].datadir, wallet_file))\n+        self.log.info(\"- Done\")\n+\n+    def get_birthheight(self, wallet_file):\n+        \"\"\"Gets birthheight of a wallet on node0\"\"\"\n+        with open(os.path.join(self.nodes[0].datadir, wallet_file), 'r', encoding=\"utf8\") as f:\n+            for line in f:\n+                if line.startswith('# * Best block at time of backup'):\n+                    wallet_birthheight = int(line.split(' ')[9])\n+                    return wallet_birthheight\n+\n+    def has_block(self, block_index):\n+        \"\"\"Checks if the pruned node has the specific blk0000*.dat file\"\"\"\n+        return os.path.isfile(os.path.join(self.nodes[1].datadir, self.chain, \"blocks\", f\"blk{block_index:05}.dat\"))\n+\n+    def create_wallet(self, wallet_name, *, unload=False):\n+        \"\"\"Creates and dumps a wallet on the non-pruned node0 to be later import by the pruned node\"\"\"\n+        self.nodes[0].createwallet(wallet_name=wallet_name, descriptors=False, load_on_startup=True)\n+        self.nodes[0].dumpwallet(os.path.join(self.nodes[0].datadir, wallet_name + \".dat\"))\n+        if (unload):\n+            self.nodes[0].unloadwallet(wallet_name)\n+\n+    def run_test(self):\n+        self.nTime = 0\n+        self.log.info(\"Warning! This test requires ~1.3GB of disk space\")\n+\n+        self.log.info(\"Generating a long chain of blocks...\")\n+\n+        # A blk*.dat file is 128MB\n+        # Generate 250 light blocks\n+        self.generate(self.nodes[0], 250, sync_fun=self.no_op)\n+        # Generate 50MB worth of large blocks in the blk00000.dat file\n+        self.mine_large_blocks(self.nodes[0], 50)\n+\n+        # Create a wallet which birth's block is in the blk00000.dat file\n+        wallet_birthheight_1 = \"wallet_birthheight_1\"\n+        assert_equal(self.has_block(1), False)\n+        self.create_wallet(wallet_birthheight_1, unload=True)\n+\n+        # Generate enough large blocks to reach pruning disk limit\n+        # Not pruning yet because we are still below PruneAfterHeight\n+        self.mine_large_blocks(self.nodes[0], 600)\n+        self.log.info(\"- Long chain created\")\n+\n+        # Create a wallet with birth height > wallet_birthheight_1\n+        wallet_birthheight_2 = \"wallet_birthheight_2\"\n+        self.create_wallet(wallet_birthheight_2)\n+\n+        # Fund wallet to later verify that importwallet correctly accounts for balances\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY + 1, self.nodes[0].getnewaddress(), sync_fun=self.no_op)\n+\n+        # We've reached pruning storage & height limit but\n+        # pruning doesn't run until another chunk (blk*.dat file) is allocated.\n+        # That's why we are generating another 5 large blocks\n+        self.mine_large_blocks(self.nodes[0], 5)\n+\n+        # blk00000.dat file is now pruned from node1\n+        assert_equal(self.has_block(0), False)\n+\n+        self.test_wallet_import_pruned(wallet_birthheight_2)\n+        self.test_wallet_import_pruned_with_missing_blocks(wallet_birthheight_1)\n+\n+if __name__ == '__main__':\n+    WalletPruningTest().main()\n\n\n###\n\n", "completion": "test: Wallet imports on pruned nodes"}
{"prompt": " file path A: depends/packages/boost.mk | file path B: depends/packages/boost.mk\n\n@@ -1,8 +1,8 @@\n package=boost\n-$(package)_version=1.80.0\n+$(package)_version=1.81.0\n $(package)_download_path=https://boostorg.jfrog.io/artifactory/main/release/$($(package)_version)/source/\n $(package)_file_name=boost_$(subst .,_,$($(package)_version)).tar.bz2\n-$(package)_sha256_hash=1e19565d82e43bc59209a168f5ac899d3ba471d55c7610c677d4ccf2c9c500c0\n+$(package)_sha256_hash=71feeed900fbccca04a3b4f2f84a7c217186f28a940ed8b7ed4725986baf99fa\n \n define $(package)_stage_cmds\n   mkdir -p $($(package)_staging_prefix_dir)/include && \\\n\n\n###\n\n", "completion": "build: Update Boost to 1.81.0 in depends"}
{"prompt": " file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -174,7 +174,6 @@ BITCOIN_TESTS += \\\n   wallet/test/wallet_crypto_tests.cpp \\\n   wallet/test/wallet_transaction_tests.cpp \\\n   wallet/test/coinselector_tests.cpp \\\n-  wallet/test/availablecoins_tests.cpp \\\n   wallet/test/init_tests.cpp \\\n   wallet/test/ismine_tests.cpp \\\n   wallet/test/rpc_util_tests.cpp \\\n\n---\n file path A: src/wallet/test/availablecoins_tests.cpp | file path B: None\n\n@@ -1,99 +0,0 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n-\n-#include <validation.h>\n-#include <wallet/coincontrol.h>\n-#include <wallet/spend.h>\n-#include <wallet/test/util.h>\n-#include <wallet/test/wallet_test_fixture.h>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-namespace wallet {\n-BOOST_FIXTURE_TEST_SUITE(availablecoins_tests, WalletTestingSetup)\n-class AvailableCoinsTestingSetup : public TestChain100Setup\n-{\n-public:\n-    AvailableCoinsTestingSetup()\n-    {\n-        CreateAndProcessBlock({}, {});\n-        wallet = CreateSyncedWallet(*m_node.chain, m_node.chainman->ActiveChain(), m_args, coinbaseKey);\n-    }\n-\n-    ~AvailableCoinsTestingSetup()\n-    {\n-        wallet.reset();\n-    }\n-    CWalletTx& AddTx(CRecipient recipient)\n-    {\n-        CTransactionRef tx;\n-        CCoinControl dummy;\n-        {\n-            constexpr int RANDOM_CHANGE_POSITION = -1;\n-            auto res = CreateTransaction(*wallet, {recipient}, RANDOM_CHANGE_POSITION, dummy);\n-            BOOST_CHECK(res);\n-            tx = res->tx;\n-        }\n-        wallet->CommitTransaction(tx, {}, {});\n-        CMutableTransaction blocktx;\n-        {\n-            LOCK(wallet->cs_wallet);\n-            blocktx = CMutableTransaction(*wallet->mapWallet.at(tx->GetHash()).tx);\n-        }\n-        CreateAndProcessBlock({CMutableTransaction(blocktx)}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-\n-        LOCK(wallet->cs_wallet);\n-        LOCK(m_node.chainman->GetMutex());\n-        wallet->SetLastBlockProcessed(wallet->GetLastBlockHeight() + 1, m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n-        auto it = wallet->mapWallet.find(tx->GetHash());\n-        BOOST_CHECK(it != wallet->mapWallet.end());\n-        it->second.m_state = TxStateConfirmed{m_node.chainman->ActiveChain().Tip()->GetBlockHash(), m_node.chainman->ActiveChain().Height(), /*index=*/1};\n-        return it->second;\n-    }\n-\n-    std::unique_ptr<CWallet> wallet;\n-};\n-\n-void TestCoinsResult(AvailableCoinsTestingSetup& context, OutputType out_type, CAmount amount,\n-                     std::map<OutputType, size_t>& expected_coins_sizes)\n-{\n-    LOCK(context.wallet->cs_wallet);\n-    util::Result<CTxDestination> dest = Assert(context.wallet->GetNewDestination(out_type, \"\"));\n-    CWalletTx& wtx = context.AddTx(CRecipient{{GetScriptForDestination(*dest)}, amount, /*fSubtractFeeFromAmount=*/true});\n-    CoinFilterParams filter;\n-    filter.skip_locked = false;\n-    CoinsResult available_coins = AvailableCoins(*context.wallet, nullptr, std::nullopt, filter);\n-    // Lock outputs so they are not spent in follow-up transactions\n-    for (uint32_t i = 0; i < wtx.tx->vout.size(); i++) context.wallet->LockCoin({wtx.GetHash(), i});\n-    for (const auto& [type, size] : expected_coins_sizes) BOOST_CHECK_EQUAL(size, available_coins.coins[type].size());\n-}\n-\n-BOOST_FIXTURE_TEST_CASE(BasicOutputTypesTest, AvailableCoinsTestingSetup)\n-{\n-    std::map<OutputType, size_t> expected_coins_sizes;\n-    for (const auto& out_type : OUTPUT_TYPES) { expected_coins_sizes[out_type] = 0U; }\n-\n-    // Verify our wallet has one usable coinbase UTXO before starting\n-    // This UTXO is a P2PK, so it should show up in the Other bucket\n-    expected_coins_sizes[OutputType::UNKNOWN] = 1U;\n-    CoinsResult available_coins = WITH_LOCK(wallet->cs_wallet, return AvailableCoins(*wallet));\n-    BOOST_CHECK_EQUAL(available_coins.Size(), expected_coins_sizes[OutputType::UNKNOWN]);\n-    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::UNKNOWN].size(), expected_coins_sizes[OutputType::UNKNOWN]);\n-\n-    // We will create a self transfer for each of the OutputTypes and\n-    // verify it is put in the correct bucket after running GetAvailablecoins\n-    //\n-    // For each OutputType, We expect 2 UTXOs in our wallet following the self transfer:\n-    //   1. One UTXO as the recipient\n-    //   2. One UTXO from the change, due to payment address matching logic\n-\n-    for (const auto& out_type : OUTPUT_TYPES) {\n-        if (out_type == OutputType::UNKNOWN) continue;\n-        expected_coins_sizes[out_type] = 2U;\n-        TestCoinsResult(*this, out_type, 1 * COIN, expected_coins_sizes);\n-    }\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()\n-} // namespace wallet\n\n---\n file path A: src/wallet/test/wallet_tests.cpp | file path B: src/wallet/test/wallet_tests.cpp\n\n@@ -622,6 +622,46 @@ BOOST_FIXTURE_TEST_CASE(ListCoinsTest, ListCoinsTestingSetup)\n     BOOST_CHECK_EQUAL(list.begin()->second.size(), 2U);\n }\n \n+void TestCoinsResult(ListCoinsTest& context, OutputType out_type, CAmount amount,\n+                     std::map<OutputType, size_t>& expected_coins_sizes)\n+{\n+    LOCK(context.wallet->cs_wallet);\n+    util::Result<CTxDestination> dest = Assert(context.wallet->GetNewDestination(out_type, \"\"));\n+    CWalletTx& wtx = context.AddTx(CRecipient{{GetScriptForDestination(*dest)}, amount, /*fSubtractFeeFromAmount=*/true});\n+    CoinFilterParams filter;\n+    filter.skip_locked = false;\n+    CoinsResult available_coins = AvailableCoins(*context.wallet, nullptr, std::nullopt, filter);\n+    // Lock outputs so they are not spent in follow-up transactions\n+    for (uint32_t i = 0; i < wtx.tx->vout.size(); i++) context.wallet->LockCoin({wtx.GetHash(), i});\n+    for (const auto& [type, size] : expected_coins_sizes) BOOST_CHECK_EQUAL(size, available_coins.coins[type].size());\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(BasicOutputTypesTest, ListCoinsTest)\n+{\n+    std::map<OutputType, size_t> expected_coins_sizes;\n+    for (const auto& out_type : OUTPUT_TYPES) { expected_coins_sizes[out_type] = 0U; }\n+\n+    // Verify our wallet has one usable coinbase UTXO before starting\n+    // This UTXO is a P2PK, so it should show up in the Other bucket\n+    expected_coins_sizes[OutputType::UNKNOWN] = 1U;\n+    CoinsResult available_coins = WITH_LOCK(wallet->cs_wallet, return AvailableCoins(*wallet));\n+    BOOST_CHECK_EQUAL(available_coins.Size(), expected_coins_sizes[OutputType::UNKNOWN]);\n+    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::UNKNOWN].size(), expected_coins_sizes[OutputType::UNKNOWN]);\n+\n+    // We will create a self transfer for each of the OutputTypes and\n+    // verify it is put in the correct bucket after running GetAvailablecoins\n+    //\n+    // For each OutputType, We expect 2 UTXOs in our wallet following the self transfer:\n+    //   1. One UTXO as the recipient\n+    //   2. One UTXO from the change, due to payment address matching logic\n+\n+    for (const auto& out_type : OUTPUT_TYPES) {\n+        if (out_type == OutputType::UNKNOWN) continue;\n+        expected_coins_sizes[out_type] = 2U;\n+        TestCoinsResult(*this, out_type, 1 * COIN, expected_coins_sizes);\n+    }\n+}\n+\n BOOST_FIXTURE_TEST_CASE(wallet_disableprivkeys, TestChain100Setup)\n {\n     {\n\n\n###\n\n", "completion": "test: move coins result test to wallet_tests.cpp"}
{"prompt": " file path A: src/wallet/test/availablecoins_tests.cpp | file path B: src/wallet/test/availablecoins_tests.cpp\n\n@@ -55,17 +55,31 @@ public:\n     std::unique_ptr<CWallet> wallet;\n };\n \n+void TestCoinsResult(AvailableCoinsTestingSetup& context, OutputType out_type, CAmount amount,\n+                     std::map<OutputType, size_t>& expected_coins_sizes)\n+{\n+    LOCK(context.wallet->cs_wallet);\n+    util::Result<CTxDestination> dest = Assert(context.wallet->GetNewDestination(out_type, \"\"));\n+    CWalletTx& wtx = context.AddTx(CRecipient{{GetScriptForDestination(*dest)}, amount, /*fSubtractFeeFromAmount=*/true});\n+    CoinFilterParams filter;\n+    filter.skip_locked = false;\n+    CoinsResult available_coins = AvailableCoins(*context.wallet, nullptr, std::nullopt, filter);\n+    // Lock outputs so they are not spent in follow-up transactions\n+    for (uint32_t i = 0; i < wtx.tx->vout.size(); i++) context.wallet->LockCoin({wtx.GetHash(), i});\n+    for (const auto& [type, size] : expected_coins_sizes) BOOST_CHECK_EQUAL(size, available_coins.coins[type].size());\n+}\n+\n BOOST_FIXTURE_TEST_CASE(BasicOutputTypesTest, AvailableCoinsTestingSetup)\n {\n-    CoinsResult available_coins;\n-    util::Result<CTxDestination> dest{util::Error{}};\n-    LOCK(wallet->cs_wallet);\n+    std::map<OutputType, size_t> expected_coins_sizes;\n+    for (const auto& out_type : OUTPUT_TYPES) { expected_coins_sizes[out_type] = 0U; }\n \n     // Verify our wallet has one usable coinbase UTXO before starting\n     // This UTXO is a P2PK, so it should show up in the Other bucket\n-    available_coins = AvailableCoins(*wallet);\n-    BOOST_CHECK_EQUAL(available_coins.Size(), 1U);\n-    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::UNKNOWN].size(), 1U);\n+    expected_coins_sizes[OutputType::UNKNOWN] = 1U;\n+    CoinsResult available_coins = WITH_LOCK(wallet->cs_wallet, return AvailableCoins(*wallet));\n+    BOOST_CHECK_EQUAL(available_coins.Size(), expected_coins_sizes[OutputType::UNKNOWN]);\n+    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::UNKNOWN].size(), expected_coins_sizes[OutputType::UNKNOWN]);\n \n     // We will create a self transfer for each of the OutputTypes and\n     // verify it is put in the correct bucket after running GetAvailablecoins\n@@ -74,33 +88,11 @@ BOOST_FIXTURE_TEST_CASE(BasicOutputTypesTest, AvailableCoinsTestingSetup)\n     //   1. One UTXO as the recipient\n     //   2. One UTXO from the change, due to payment address matching logic\n \n-    // Bech32m\n-    dest = wallet->GetNewDestination(OutputType::BECH32M, \"\");\n-    BOOST_ASSERT(dest);\n-    AddTx(CRecipient{{GetScriptForDestination(*dest)}, 1 * COIN, /*fSubtractFeeFromAmount=*/true});\n-    available_coins = AvailableCoins(*wallet);\n-    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::BECH32M].size(), 2U);\n-\n-    // Bech32\n-    dest = wallet->GetNewDestination(OutputType::BECH32, \"\");\n-    BOOST_ASSERT(dest);\n-    AddTx(CRecipient{{GetScriptForDestination(*dest)}, 2 * COIN, /*fSubtractFeeFromAmount=*/true});\n-    available_coins = AvailableCoins(*wallet);\n-    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::BECH32].size(), 2U);\n-\n-    // P2SH-SEGWIT\n-    dest = wallet->GetNewDestination(OutputType::P2SH_SEGWIT, \"\");\n-    BOOST_ASSERT(dest);\n-    AddTx(CRecipient{{GetScriptForDestination(*dest)}, 3 * COIN, /*fSubtractFeeFromAmount=*/true});\n-    available_coins = AvailableCoins(*wallet);\n-    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::P2SH_SEGWIT].size(), 2U);\n-\n-    // Legacy (P2PKH)\n-    dest = wallet->GetNewDestination(OutputType::LEGACY, \"\");\n-    BOOST_ASSERT(dest);\n-    AddTx(CRecipient{{GetScriptForDestination(*dest)}, 4 * COIN, /*fSubtractFeeFromAmount=*/true});\n-    available_coins = AvailableCoins(*wallet);\n-    BOOST_CHECK_EQUAL(available_coins.coins[OutputType::LEGACY].size(), 2U);\n+    for (const auto& out_type : OUTPUT_TYPES) {\n+        if (out_type == OutputType::UNKNOWN) continue;\n+        expected_coins_sizes[out_type] = 2U;\n+        TestCoinsResult(*this, out_type, 1 * COIN, expected_coins_sizes);\n+    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: extend and simplify availablecoins_tests"}
{"prompt": " file path A: test/functional/test_framework/test_shell.py | file path B: test/functional/test_framework/test_shell.py\n\n@@ -16,6 +16,9 @@ class TestShell:\n     start a single TestShell at a time.\"\"\"\n \n     class __TestShell(BitcoinTestFramework):\n+        def add_options(self, parser):\n+            self.add_wallet_options(parser)\n+\n         def set_test_params(self):\n             pass\n \n\n\n###\n\n", "completion": "test: add add_wallet_options to TestShell"}
{"prompt": " file path A: ci/test/06_script_a.sh | file path B: ci/test/06_script_a.sh\n\n@@ -6,7 +6,10 @@\n \n export LC_ALL=C.UTF-8\n \n-BITCOIN_CONFIG_ALL=\"--enable-suppress-external-warnings --disable-dependency-tracking --prefix=$DEPENDS_DIR/$HOST\"\n+BITCOIN_CONFIG_ALL=\"--enable-suppress-external-warnings --disable-dependency-tracking\"\n+if [ -z \"$NO_DEPENDS\" ]; then\n+  BITCOIN_CONFIG_ALL=\"${BITCOIN_CONFIG_ALL} CONFIG_SITE=$DEPENDS_DIR/$HOST/share/config.site\"\n+fi\n if [ -z \"$NO_WERROR\" ]; then\n   BITCOIN_CONFIG_ALL=\"${BITCOIN_CONFIG_ALL} --enable-werror\"\n fi\n@@ -23,7 +26,7 @@ if [ -n \"$ANDROID_TOOLS_URL\" ]; then\n   exit 0\n fi\n \n-BITCOIN_CONFIG_ALL=\"${BITCOIN_CONFIG_ALL} --enable-external-signer --bindir=$BASE_OUTDIR/bin --libdir=$BASE_OUTDIR/lib\"\n+BITCOIN_CONFIG_ALL=\"${BITCOIN_CONFIG_ALL} --enable-external-signer --prefix=$BASE_OUTDIR\"\n \n if [ -n \"$CONFIG_SHELL\" ]; then\n   CI_EXEC \"$CONFIG_SHELL\" -c \"./autogen.sh\"\n\n\n###\n\n", "completion": "ci: Use `CONFIG_SITE` variable and `--prefix` option properly"}
{"prompt": " file path A: src/httpserver.cpp | file path B: src/httpserver.cpp\n\n@@ -198,9 +198,10 @@ std::string RequestMethodString(HTTPRequest::RequestMethod m)\n         return \"HEAD\";\n     case HTTPRequest::PUT:\n         return \"PUT\";\n-    default:\n+    case HTTPRequest::UNKNOWN:\n         return \"unknown\";\n-    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n }\n \n /** HTTP request callback */\n\n\n###\n\n", "completion": "refactor: Refactored RequestMethodString function to follow developer notes"}
{"prompt": " file path A: src/httpserver.cpp | file path B: src/httpserver.cpp\n\n@@ -192,16 +192,12 @@ std::string RequestMethodString(HTTPRequest::RequestMethod m)\n     switch (m) {\n     case HTTPRequest::GET:\n         return \"GET\";\n-        break;\n     case HTTPRequest::POST:\n         return \"POST\";\n-        break;\n     case HTTPRequest::HEAD:\n         return \"HEAD\";\n-        break;\n     case HTTPRequest::PUT:\n         return \"PUT\";\n-        break;\n     default:\n         return \"unknown\";\n     }\n@@ -626,19 +622,14 @@ HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n     switch (evhttp_request_get_command(req)) {\n     case EVHTTP_REQ_GET:\n         return GET;\n-        break;\n     case EVHTTP_REQ_POST:\n         return POST;\n-        break;\n     case EVHTTP_REQ_HEAD:\n         return HEAD;\n-        break;\n     case EVHTTP_REQ_PUT:\n         return PUT;\n-        break;\n     default:\n         return UNKNOWN;\n-        break;\n     }\n }\n \n\n\n###\n\n", "completion": "refactor: Deleted unreachable code in httpserver.cpp"}
{"prompt": " file path A: src/test/rpc_tests.cpp | file path B: src/test/rpc_tests.cpp\n\n@@ -84,7 +84,7 @@ BOOST_FIXTURE_TEST_SUITE(rpc_tests, RPCTestingSetup)\n \n BOOST_AUTO_TEST_CASE(rpc_namedparams)\n {\n-    const std::vector<std::string> arg_names{{\"arg1\", \"arg2\", \"arg3\", \"arg4\", \"arg5\"}};\n+    const std::vector<std::string> arg_names{\"arg1\", \"arg2\", \"arg3\", \"arg4\", \"arg5\"};\n \n     // Make sure named arguments are transformed into positional arguments in correct places separated by nulls\n     BOOST_CHECK_EQUAL(TransformParams(JSON(R\"({\"arg2\": 2, \"arg4\": 4})\"), arg_names).write(), \"[null,2,null,4]\");\n@@ -104,7 +104,7 @@ BOOST_AUTO_TEST_CASE(rpc_namedparams)\n     BOOST_CHECK_EXCEPTION(TransformParams(JSON(R\"({\"args\": [1,2,3], \"arg4\": 4, \"arg2\": 2})\"), arg_names), UniValue,\n                           HasJSON(R\"({\"code\":-8,\"message\":\"Parameter arg2 specified twice both as positional and named argument\"})\"));\n \n-    // Make sure extra positional arguments can be passed through to the method implemenation, as long as they don't overlap with named arguments.\n+    // Make sure extra positional arguments can be passed through to the method implementation, as long as they don't overlap with named arguments.\n     BOOST_CHECK_EQUAL(TransformParams(JSON(R\"({\"args\": [1,2,3,4,5,6,7,8,9,10]})\"), arg_names).write(), \"[1,2,3,4,5,6,7,8,9,10]\");\n     BOOST_CHECK_EQUAL(TransformParams(JSON(R\"([1,2,3,4,5,6,7,8,9,10])\"), arg_names).write(), \"[1,2,3,4,5,6,7,8,9,10]\");\n }\n\n\n###\n\n", "completion": "test: Suggested cleanups for rpc_namedparams test"}
{"prompt": " file path A: depends/packages/libmultiprocess.mk | file path B: depends/packages/libmultiprocess.mk\n\n@@ -24,5 +24,5 @@ define $(package)_build_cmds\n endef\n \n define $(package)_stage_cmds\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n+  $(MAKE) DESTDIR=$($(package)_staging_dir) install-lib\n endef\n\n---\n file path A: depends/packages/native_libmultiprocess.mk | file path B: depends/packages/native_libmultiprocess.mk\n\n@@ -1,8 +1,8 @@\n package=native_libmultiprocess\n-$(package)_version=d576d975debdc9090bd2582f83f49c76c0061698\n+$(package)_version=1af83d15239ccfa7e47b8764029320953dd7fdf1\n $(package)_download_path=https://github.com/chaincodelabs/libmultiprocess/archive\n $(package)_file_name=$($(package)_version).tar.gz\n-$(package)_sha256_hash=9f8b055c8bba755dc32fe799b67c20b91e7b13e67cadafbc54c0f1def057a370\n+$(package)_sha256_hash=e5587d3feedc7f8473f178a89b94163a11076629825d664964799bbbd5844da5\n $(package)_dependencies=native_capnp\n \n define $(package)_config_cmds\n@@ -14,5 +14,5 @@ define $(package)_build_cmds\n endef\n \n define $(package)_stage_cmds\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n+  $(MAKE) DESTDIR=$($(package)_staging_dir) install-bin\n endef\n\n\n###\n\n", "completion": "build: Update `libmultiprocess` library"}
{"prompt": " file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -98,8 +98,8 @@ BASE_SCRIPTS = [\n     'mining_getblocktemplate_longpoll.py',\n     'feature_maxuploadtarget.py',\n     'feature_block.py',\n-    'rpc_fundrawtransaction.py --legacy-wallet',\n-    'rpc_fundrawtransaction.py --descriptors',\n+    'wallet_fundrawtransaction.py --legacy-wallet',\n+    'wallet_fundrawtransaction.py --descriptors',\n     'p2p_compactblocks.py',\n     'p2p_compactblocks_blocksonly.py',\n     'feature_segwit.py --legacy-wallet',\n\n---\n file path A: test/functional/rpc_fundrawtransaction.py | file path B: test/functional/wallet_fundrawtransaction.py\n\n\n\n###\n\n", "completion": "test: Move rpc_fundrawtransaction.py to wallet_fundrawtransaction.py"}
{"prompt": " file path A: test/functional/test_framework/test_node.py | file path B: test/functional/test_framework/test_node.py\n\n@@ -337,7 +337,7 @@ class TestNode():\n             return\n         self.log.debug(\"Stopping node\")\n         try:\n-            # Do not use wait argument when testing older nodes, e.g. in feature_backwards_compatibility.py\n+            # Do not use wait argument when testing older nodes, e.g. in wallet_backwards_compatibility.py\n             if self.version_is_at_least(180000):\n                 self.stop(wait=wait)\n             else:\n\n---\n file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -226,8 +226,8 @@ BASE_SCRIPTS = [\n     'wallet_txn_doublespend.py --legacy-wallet',\n     'wallet_multisig_descriptor_psbt.py --descriptors',\n     'wallet_txn_doublespend.py --descriptors',\n-    'feature_backwards_compatibility.py --legacy-wallet',\n-    'feature_backwards_compatibility.py --descriptors',\n+    'wallet_backwards_compatibility.py --legacy-wallet',\n+    'wallet_backwards_compatibility.py --descriptors',\n     'wallet_txn_clone.py --mineblock',\n     'feature_notifications.py',\n     'rpc_getblockfilter.py',\n\n---\n file path A: test/functional/feature_backwards_compatibility.py | file path B: test/functional/wallet_backwards_compatibility.py\n\n@@ -7,10 +7,6 @@\n Test various backwards compatibility scenarios. Requires previous releases binaries,\n see test/README.md.\n \n-v0.15.2 is not required by this test, but it is used in wallet_upgradewallet.py.\n-Due to a hardfork in regtest, it can't be used to sync nodes.\n-\n-\n Due to RPC changes introduced in various versions the below tests\n won't work for older versions without some patches or workarounds.\n \n\n\n###\n\n", "completion": "test: Move feature_backwards_compatibility.py to wallet_backwards_compatibility.py"}
{"prompt": " file path A: test/functional/feature_txindex_compatibility.py | file path B: test/functional/feature_txindex_compatibility.py\n\n@@ -14,7 +14,7 @@ from test_framework.test_framework import BitcoinTestFramework\n from test_framework.wallet import MiniWallet\n \n \n-class MempoolCompatibilityTest(BitcoinTestFramework):\n+class TxindexCompatibilityTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 3\n         self.extra_args = [\n@@ -33,7 +33,7 @@ class MempoolCompatibilityTest(BitcoinTestFramework):\n             versions=[\n                 160300,  # Last release with legacy txindex\n                 None,  # For MiniWallet, without migration code\n-                200100,  # Any release with migration code (0.17.x - 22.x)\n+                220000,  # Last release with migration code (0.17.x - 22.x)\n             ],\n         )\n         self.start_nodes()\n@@ -89,4 +89,4 @@ class MempoolCompatibilityTest(BitcoinTestFramework):\n \n \n if __name__ == \"__main__\":\n-    MempoolCompatibilityTest().main()\n+    TxindexCompatibilityTest().main()\n\n---\n file path A: test/functional/mempool_compatibility.py | file path B: test/functional/mempool_compatibility.py\n\n@@ -7,7 +7,7 @@\n NOTE: The test is designed to prevent cases when compatibility is broken accidentally.\n In case we need to break mempool compatibility we can continue to use the test by just bumping the version number.\n \n-The previous release v0.19.1 is required by this test, see test/README.md.\n+Previous releases are required by this test, see test/README.md.\n \"\"\"\n \n import os\n@@ -29,7 +29,7 @@ class MempoolCompatibilityTest(BitcoinTestFramework):\n \n     def setup_network(self):\n         self.add_nodes(self.num_nodes, versions=[\n-            190100,  # oldest version with getmempoolinfo.loaded (used to avoid intermittent issues)\n+            200100,  # Last release with previous mempool format\n             None,\n         ])\n         self.start_nodes()\n@@ -38,6 +38,7 @@ class MempoolCompatibilityTest(BitcoinTestFramework):\n         self.log.info(\"Test that mempool.dat is compatible between versions\")\n \n         old_node, new_node = self.nodes\n+        assert \"unbroadcastcount\" not in old_node.getmempoolinfo()\n         new_wallet = MiniWallet(new_node, mode=MiniWalletMode.RAW_P2PK)\n         self.generate(new_wallet, 1, sync_fun=self.no_op)\n         self.generate(new_node, COINBASE_MATURITY, sync_fun=self.no_op)\n\n\n###\n\n", "completion": "test: Use last release in compatibility tests"}
{"prompt": " file path A: test/functional/feature_assumevalid.py | file path B: test/functional/feature_assumevalid.py\n\n@@ -83,8 +83,6 @@ class AssumeValidTest(BitcoinTestFramework):\n                 break\n \n     def run_test(self):\n-        p2p0 = self.nodes[0].add_p2p_connection(BaseNode())\n-\n         # Build the blockchain\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n         self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n@@ -139,28 +137,23 @@ class AssumeValidTest(BitcoinTestFramework):\n             self.block_time += 1\n             height += 1\n \n-        self.nodes[0].disconnect_p2ps()\n-\n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n         self.start_node(1, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n         self.start_node(2, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n \n         p2p0 = self.nodes[0].add_p2p_connection(BaseNode())\n-        p2p1 = self.nodes[1].add_p2p_connection(BaseNode())\n-        p2p2 = self.nodes[2].add_p2p_connection(BaseNode())\n-\n-        # send header lists to all three nodes\n         p2p0.send_header_for_blocks(self.blocks[0:2000])\n         p2p0.send_header_for_blocks(self.blocks[2000:])\n-        p2p1.send_header_for_blocks(self.blocks[0:2000])\n-        p2p1.send_header_for_blocks(self.blocks[2000:])\n-        p2p2.send_header_for_blocks(self.blocks[0:200])\n \n         # Send blocks to node0. Block 102 will be rejected.\n         self.send_blocks_until_disconnected(p2p0)\n         self.wait_until(lambda: self.nodes[0].getblockcount() >= COINBASE_MATURITY + 1)\n         assert_equal(self.nodes[0].getblockcount(), COINBASE_MATURITY + 1)\n \n+        p2p1 = self.nodes[1].add_p2p_connection(BaseNode())\n+        p2p1.send_header_for_blocks(self.blocks[0:2000])\n+        p2p1.send_header_for_blocks(self.blocks[2000:])\n+\n         # Send all blocks to node1. All blocks will be accepted.\n         for i in range(2202):\n             p2p1.send_message(msg_block(self.blocks[i]))\n@@ -168,6 +161,9 @@ class AssumeValidTest(BitcoinTestFramework):\n         p2p1.sync_with_ping(960)\n         assert_equal(self.nodes[1].getblock(self.nodes[1].getbestblockhash())['height'], 2202)\n \n+        p2p2 = self.nodes[2].add_p2p_connection(BaseNode())\n+        p2p2.send_header_for_blocks(self.blocks[0:200])\n+\n         # Send blocks to node2. Block 102 will be rejected.\n         self.send_blocks_until_disconnected(p2p2)\n         self.wait_until(lambda: self.nodes[2].getblockcount() >= COINBASE_MATURITY + 1)\n\n\n###\n\n", "completion": "test: Avoid intermittent timeout in feature_assumevalid.py"}
{"prompt": " file path A: test/functional/feature_backwards_compatibility.py | file path B: test/functional/feature_backwards_compatibility.py\n\n@@ -274,6 +274,7 @@ class BackwardsCompatibilityTest(BitcoinTestFramework):\n             assert_equal(info[\"desc\"], descsum_create(descriptor))\n \n             # Now copy that same wallet back to 0.16 to make sure no automatic upgrade breaks it\n+            node_master.unloadwallet(\"u1_v16\")\n             os.remove(os.path.join(node_v16_wallets_dir, \"wallets/u1_v16\"))\n             shutil.copyfile(\n                 os.path.join(node_master_wallets_dir, \"u1_v16\"),\n\n\n###\n\n", "completion": "test: Fix backwards compatibility intermittent failure"}
{"prompt": " file path A: src/rpc/rawtransaction.cpp | file path B: src/rpc/rawtransaction.cpp\n\n@@ -304,7 +304,7 @@ static RPCHelpMan createrawtransaction()\n \n     std::optional<bool> rbf;\n     if (!request.params[3].isNull()) {\n-        rbf = request.params[3].isTrue();\n+        rbf = request.params[3].get_bool();\n     }\n     CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf);\n \n@@ -1449,7 +1449,7 @@ static RPCHelpMan createpsbt()\n \n     std::optional<bool> rbf;\n     if (!request.params[3].isNull()) {\n-        rbf = request.params[3].isTrue();\n+        rbf = request.params[3].get_bool();\n     }\n     CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf);\n \n\n\n###\n\n", "completion": "refactor: Replace isTrue with get_bool"}
{"prompt": " file path A: depends/funcs.mk | file path B: depends/funcs.mk\n\n@@ -137,6 +137,7 @@ $(1)_config_env+=$($(1)_config_env_$(host_arch)_$(host_os)) $($(1)_config_env_$(\n \n $(1)_config_env+=PKG_CONFIG_LIBDIR=$($($(1)_type)_prefix)/lib/pkgconfig\n $(1)_config_env+=PKG_CONFIG_PATH=$($($(1)_type)_prefix)/share/pkgconfig\n+$(1)_config_env+=PKG_CONFIG_SYSROOT_DIR=/\n $(1)_config_env+=CMAKE_MODULE_PATH=$($($(1)_type)_prefix)/lib/cmake\n $(1)_config_env+=PATH=$(build_prefix)/bin:$(PATH)\n $(1)_build_env+=PATH=$(build_prefix)/bin:$(PATH)\n\n---\n file path A: depends/packages/qt.mk | file path B: depends/packages/qt.mk\n\n@@ -33,6 +33,7 @@ $(package)_extra_sources  = $($(package)_qttranslations_file_name)\n $(package)_extra_sources += $($(package)_qttools_file_name)\n \n define $(package)_set_vars\n+$(package)_config_env = QT_MAC_SDK_NO_VERSION_CHECK=1\n $(package)_config_opts_release = -release\n $(package)_config_opts_release += -silent\n $(package)_config_opts_debug = -debug\n@@ -261,9 +262,6 @@ define $(package)_preprocess_cmds\n endef\n \n define $(package)_config_cmds\n-  export PKG_CONFIG_SYSROOT_DIR=/ && \\\n-  export PKG_CONFIG_LIBDIR=$(host_prefix)/lib/pkgconfig && \\\n-  export QT_MAC_SDK_NO_VERSION_CHECK=1 && \\\n   cd qtbase && \\\n   ./configure -top-level $($(package)_config_opts)\n endef\n\n\n###\n\n", "completion": "build: Move environment variables into `$(package)_config_env`"}
{"prompt": " file path A: depends/funcs.mk | file path B: depends/funcs.mk\n\n@@ -87,9 +87,9 @@ $(1)_download_path_fixed=$(subst :,\\:,$$($(1)_download_path))\n $(1)_fetch_cmds ?= $(call fetch_file,$(1),$(subst \\:,:,$$($(1)_download_path_fixed)),$$($(1)_download_file),$($(1)_file_name),$($(1)_sha256_hash))\n $(1)_extract_cmds ?= mkdir -p $$($(1)_extract_dir) && echo \"$$($(1)_sha256_hash)  $$($(1)_source)\" > $$($(1)_extract_dir)/.$$($(1)_file_name).hash &&  $(build_SHA256SUM) -c $$($(1)_extract_dir)/.$$($(1)_file_name).hash && $(build_TAR) --no-same-owner --strip-components=1 -xf $$($(1)_source)\n $(1)_preprocess_cmds ?= true\n-$(1)_build_cmds ?=\n-$(1)_config_cmds ?=\n-$(1)_stage_cmds ?=\n+$(1)_build_cmds ?= true\n+$(1)_config_cmds ?= true\n+$(1)_stage_cmds ?= true\n $(1)_set_vars ?=\n \n \n@@ -214,17 +214,17 @@ $($(1)_configured): | $($(1)_dependencies) $($(1)_preprocessed)\n \techo Configuring $(1)...\n \trm -rf $(host_prefix); mkdir -p $(host_prefix)/lib; cd $(host_prefix); $(foreach package,$($(1)_all_dependencies), $(build_TAR) --no-same-owner -xf $($(package)_cached); )\n \tmkdir -p $$(@D)\n-\t+{ cd $$(@D); $($(1)_config_env) $($(1)_config_cmds); } $$($(1)_logging)\n+\t+{ cd $$(@D); export $($(1)_config_env); $($(1)_config_cmds); } $$($(1)_logging)\n \ttouch $$@\n $($(1)_built): | $($(1)_configured)\n \techo Building $(1)...\n \tmkdir -p $$(@D)\n-\t+{ cd $$(@D); $($(1)_build_env) $($(1)_build_cmds); } $$($(1)_logging)\n+\t+{ cd $$(@D); export $($(1)_build_env); $($(1)_build_cmds); } $$($(1)_logging)\n \ttouch $$@\n $($(1)_staged): | $($(1)_built)\n \techo Staging $(1)...\n \tmkdir -p $($(1)_staging_dir)/$(host_prefix)\n-\t+{ cd $($(1)_build_dir); $($(1)_stage_env) $($(1)_stage_cmds); } $$($(1)_logging)\n+\t+{ cd $($(1)_build_dir); export $($(1)_stage_env); $($(1)_stage_cmds); } $$($(1)_logging)\n \trm -rf $($(1)_extract_dir)\n \ttouch $$@\n $($(1)_postprocessed): | $($(1)_staged)\n\n\n###\n\n", "completion": "build: Make $(package)_*_env available to all $(package)_*_cmds"}
{"prompt": " file path A: test/functional/wallet_listsinceblock.py | file path B: test/functional/wallet_listsinceblock.py\n\n@@ -49,6 +49,7 @@ class ListSinceBlockTest(BitcoinTestFramework):\n             self.test_desc()\n         self.test_send_to_self()\n         self.test_op_return()\n+        self.test_label()\n \n     def test_no_blockhash(self):\n         self.log.info(\"Test no blockhash\")\n@@ -465,6 +466,20 @@ class ListSinceBlockTest(BitcoinTestFramework):\n \n         assert 'address' not in op_ret_tx\n \n+    def test_label(self):\n+        self.log.info('Test passing \"label\" argument fetches incoming transactions having the specified label')\n+        new_addr = self.nodes[1].getnewaddress(label=\"new_addr\", address_type=\"bech32\")\n+\n+        self.nodes[2].sendtoaddress(address=new_addr, amount=\"0.001\")\n+        self.generate(self.nodes[2], 1)\n+\n+        for label in [\"new_addr\", \"\"]:\n+            new_addr_transactions = self.nodes[1].listsinceblock(label=label)[\"transactions\"]\n+            assert_equal(len(new_addr_transactions), 1)\n+            assert_equal(new_addr_transactions[0][\"label\"], label)\n+            if label == \"new_addr\":\n+                assert_equal(new_addr_transactions[0][\"address\"], new_addr)\n+\n \n if __name__ == '__main__':\n     ListSinceBlockTest().main()\n\n\n###\n\n", "completion": "test: add coverage for `label` in `listsinceblock`"}
{"prompt": " file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -214,11 +214,11 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n             self.options.descriptors = None\n         elif self.options.descriptors is None:\n             # Some wallet is either required or optionally used by the test.\n-            # Prefer BDB unless it isn't available\n-            if self.is_bdb_compiled():\n-                self.options.descriptors = False\n-            elif self.is_sqlite_compiled():\n+            # Prefer SQLite unless it isn't available\n+            if self.is_sqlite_compiled():\n                 self.options.descriptors = True\n+            elif self.is_bdb_compiled():\n+                self.options.descriptors = False\n             else:\n                 # If neither are compiled, tests requiring a wallet will be skipped and the value of self.options.descriptors won't matter\n                 # It still needs to exist and be None in order for tests to work however.\n\n\n###\n\n", "completion": "test: prefer sqlite for wallet tests"}
{"prompt": " file path A: test/functional/wallet_migration.py | file path B: test/functional/wallet_migration.py\n\n@@ -40,11 +40,13 @@ class WalletMigrationTest(BitcoinTestFramework):\n             assert_equal(file_magic, b'SQLite format 3\\x00')\n         assert_equal(self.nodes[0].get_wallet_rpc(wallet_name).getwalletinfo()[\"format\"], \"sqlite\")\n \n-    def create_legacy_wallet(self, wallet_name):\n-        self.nodes[0].createwallet(wallet_name=wallet_name)\n+    def create_legacy_wallet(self, wallet_name, disable_private_keys=False):\n+        self.nodes[0].createwallet(wallet_name=wallet_name, descriptors=False, disable_private_keys=disable_private_keys)\n         wallet = self.nodes[0].get_wallet_rpc(wallet_name)\n-        assert_equal(wallet.getwalletinfo()[\"descriptors\"], False)\n-        assert_equal(wallet.getwalletinfo()[\"format\"], \"bdb\")\n+        info = wallet.getwalletinfo()\n+        assert_equal(info[\"descriptors\"], False)\n+        assert_equal(info[\"format\"], \"bdb\")\n+        assert_equal(info[\"private_keys_enabled\"], not disable_private_keys)\n         return wallet\n \n     def assert_addr_info_equal(self, addr_info, addr_info_old):\n@@ -187,11 +189,9 @@ class WalletMigrationTest(BitcoinTestFramework):\n \n         # Some keys in multisig do not belong to this wallet\n         self.log.info(\"Test migration of a wallet that has some keys in a multisig\")\n-        self.nodes[0].createwallet(wallet_name=\"multisig1\")\n-        multisig1 = self.nodes[0].get_wallet_rpc(\"multisig1\")\n+        multisig1 = self.create_legacy_wallet(\"multisig1\")\n         ms_info = multisig1.addmultisigaddress(2, [multisig1.getnewaddress(), pub1, pub2])\n         ms_info2 = multisig1.addmultisigaddress(2, [multisig1.getnewaddress(), pub1, pub2])\n-        assert_equal(multisig1.getwalletinfo()[\"descriptors\"], False)\n \n         addr1 = ms_info[\"address\"]\n         addr2 = ms_info2[\"address\"]\n@@ -256,9 +256,7 @@ class WalletMigrationTest(BitcoinTestFramework):\n \n         # Wallet with an imported address. Should be the same thing as the multisig test\n         self.log.info(\"Test migration of a wallet with watchonly imports\")\n-        self.nodes[0].createwallet(wallet_name=\"imports0\")\n-        imports0 = self.nodes[0].get_wallet_rpc(\"imports0\")\n-        assert_equal(imports0.getwalletinfo()[\"descriptors\"], False)\n+        imports0 = self.create_legacy_wallet(\"imports0\")\n \n         # Exteranl address label\n         imports0.setlabel(default.getnewaddress(), \"external\")\n@@ -318,11 +316,7 @@ class WalletMigrationTest(BitcoinTestFramework):\n \n         # Migrating an actual watchonly wallet should not create a new watchonly wallet\n         self.log.info(\"Test migration of a pure watchonly wallet\")\n-        self.nodes[0].createwallet(wallet_name=\"watchonly0\", disable_private_keys=True)\n-        watchonly0 = self.nodes[0].get_wallet_rpc(\"watchonly0\")\n-        info = watchonly0.getwalletinfo()\n-        assert_equal(info[\"descriptors\"], False)\n-        assert_equal(info[\"private_keys_enabled\"], False)\n+        watchonly0 = self.create_legacy_wallet(\"watchonly0\", disable_private_keys=True)\n \n         addr = default.getnewaddress()\n         desc = default.getaddressinfo(addr)[\"desc\"]\n@@ -345,11 +339,7 @@ class WalletMigrationTest(BitcoinTestFramework):\n \n         # Migrating a wallet with pubkeys added to the keypool\n         self.log.info(\"Test migration of a pure watchonly wallet with pubkeys in keypool\")\n-        self.nodes[0].createwallet(wallet_name=\"watchonly1\", disable_private_keys=True)\n-        watchonly1 = self.nodes[0].get_wallet_rpc(\"watchonly1\")\n-        info = watchonly1.getwalletinfo()\n-        assert_equal(info[\"descriptors\"], False)\n-        assert_equal(info[\"private_keys_enabled\"], False)\n+        watchonly1 = self.create_legacy_wallet(\"watchonly1\", disable_private_keys=True)\n \n         addr1 = default.getnewaddress(address_type=\"bech32\")\n         addr2 = default.getnewaddress(address_type=\"bech32\")\n\n\n###\n\n", "completion": "test: make wallet_migration.py pass with both wallet flags"}
{"prompt": " file path A: src/wallet/test/coinselector_tests.cpp | file path B: src/wallet/test/coinselector_tests.cpp\n\n@@ -4,6 +4,7 @@\n \n #include <consensus/amount.h>\n #include <node/context.h>\n+#include <policy/policy.h>\n #include <primitives/transaction.h>\n #include <random.h>\n #include <test/util/setup_common.h>\n@@ -930,6 +931,124 @@ BOOST_AUTO_TEST_CASE(effective_value_test)\n     BOOST_CHECK_EQUAL(output5.GetEffectiveValue(), nValue); // The effective value should be equal to the absolute value if input_bytes is -1\n }\n \n+static std::optional<SelectionResult> select_coins(const CAmount& target, const CoinSelectionParams& cs_params, const CCoinControl& cc, std::function<CoinsResult(CWallet&)> coin_setup, interfaces::Chain* chain, const ArgsManager& args)\n+{\n+    std::unique_ptr<CWallet> wallet = std::make_unique<CWallet>(chain, \"\", args, CreateMockWalletDatabase());\n+    wallet->LoadWallet();\n+    LOCK(wallet->cs_wallet);\n+    wallet->SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n+    wallet->SetupDescriptorScriptPubKeyMans();\n+\n+    auto available_coins = coin_setup(*wallet);\n+\n+    const auto result = SelectCoins(*wallet, available_coins, /*pre_set_inputs=*/ {}, target, cc, cs_params);\n+    if (result) {\n+        const auto signedTxSize = 10 + 34 + 68 * result->GetInputSet().size(); // static header size + output size + inputs size (P2WPKH)\n+        BOOST_CHECK_LE(signedTxSize * WITNESS_SCALE_FACTOR, MAX_STANDARD_TX_WEIGHT);\n+\n+        BOOST_CHECK_GE(result->GetSelectedValue(), target);\n+    }\n+    return result;\n+}\n+\n+static bool has_coin(const CoinSet& set, CAmount amount)\n+{\n+    return std::any_of(set.begin(), set.end(), [&](const auto& coin) { return coin.GetEffectiveValue() == amount; });\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_max_weight)\n+{\n+    const CAmount target = 49.5L * COIN;\n+    CCoinControl cc;\n+\n+    FastRandomContext rand;\n+    CoinSelectionParams cs_params{\n+        rand,\n+        /*change_output_size=*/34,\n+        /*change_spend_size=*/68,\n+        /*min_change_target=*/CENT,\n+        /*effective_feerate=*/CFeeRate(0),\n+        /*long_term_feerate=*/CFeeRate(0),\n+        /*discard_feerate=*/CFeeRate(0),\n+        /*tx_noinputs_size=*/10 + 34, // static header size + output size\n+        /*avoid_partial=*/false,\n+    };\n+\n+    auto chain{m_node.chain.get()};\n+\n+    {\n+        // Scenario 1:\n+        // The actor starts with 1x 50.0 BTC and 1515x 0.033 BTC (~100.0 BTC total) unspent outputs\n+        // Then tries to spend 49.5 BTC\n+        // The 50.0 BTC output should be selected, because the transaction would otherwise be too large\n+\n+        // Perform selection\n+\n+        const auto result = select_coins(\n+            target, cs_params, cc, [&](CWallet& wallet) {\n+                CoinsResult available_coins;\n+                for (int j = 0; j < 1515; ++j) {\n+                    add_coin(available_coins, wallet, CAmount(0.033 * COIN), CFeeRate(0), 144, false, 0, true);\n+                }\n+\n+                add_coin(available_coins, wallet, CAmount(50 * COIN), CFeeRate(0), 144, false, 0, true);\n+                return available_coins;\n+            },\n+            chain, m_args);\n+\n+        BOOST_CHECK(result);\n+        BOOST_CHECK(has_coin(result->GetInputSet(), CAmount(50 * COIN)));\n+    }\n+\n+    {\n+        // Scenario 2:\n+\n+        // The actor starts with 400x 0.0625 BTC and 2000x 0.025 BTC (75.0 BTC total) unspent outputs\n+        // Then tries to spend 49.5 BTC\n+        // A combination of coins should be selected, such that the created transaction is not too large\n+\n+        // Perform selection\n+        const auto result = select_coins(\n+            target, cs_params, cc, [&](CWallet& wallet) {\n+                CoinsResult available_coins;\n+                for (int j = 0; j < 400; ++j) {\n+                    add_coin(available_coins, wallet, CAmount(0.0625 * COIN), CFeeRate(0), 144, false, 0, true);\n+                }\n+                for (int j = 0; j < 2000; ++j) {\n+                    add_coin(available_coins, wallet, CAmount(0.025 * COIN), CFeeRate(0), 144, false, 0, true);\n+                }\n+                return available_coins;\n+            },\n+            chain, m_args);\n+\n+        BOOST_CHECK(has_coin(result->GetInputSet(), CAmount(0.0625 * COIN)));\n+        BOOST_CHECK(has_coin(result->GetInputSet(), CAmount(0.025 * COIN)));\n+    }\n+\n+    {\n+        // Scenario 3:\n+\n+        // The actor starts with 1515x 0.033 BTC (49.995 BTC total) unspent outputs\n+        // No results should be returned, because the transaction would be too large\n+\n+        // Perform selection\n+        const auto result = select_coins(\n+            target, cs_params, cc, [&](CWallet& wallet) {\n+                CoinsResult available_coins;\n+                for (int j = 0; j < 1515; ++j) {\n+                    add_coin(available_coins, wallet, CAmount(0.033 * COIN), CFeeRate(0), 144, false, 0, true);\n+                }\n+                return available_coins;\n+            },\n+            chain, m_args);\n+\n+        // No results\n+        // 1515 inputs * 68 bytes = 103,020 bytes\n+        // 103,020 bytes * 4 = 412,080 weight, which is above the MAX_STANDARD_TX_WEIGHT of 400,000\n+        BOOST_CHECK(!result);\n+    }\n+}\n+\n BOOST_AUTO_TEST_CASE(SelectCoins_effective_value_test)\n {\n     // Test that the effective value is used to check whether preset inputs provide sufficient funds when subtract_fee_outputs is not used.\n\n\n###\n\n", "completion": "test: Check max transaction weight in CoinSelection"}
{"prompt": " file path A: test/functional/mempool_compatibility.py | file path B: test/functional/mempool_compatibility.py\n\n@@ -21,12 +21,8 @@ from test_framework.wallet import (\n \n \n class MempoolCompatibilityTest(BitcoinTestFramework):\n-    def add_options(self, parser):\n-        self.add_wallet_options(parser)\n-\n     def set_test_params(self):\n         self.num_nodes = 2\n-        self.wallet_names = [None]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_previous_releases()\n@@ -37,7 +33,6 @@ class MempoolCompatibilityTest(BitcoinTestFramework):\n             None,\n         ])\n         self.start_nodes()\n-        self.import_deterministic_coinbase_privkeys()\n \n     def run_test(self):\n         self.log.info(\"Test that mempool.dat is compatible between versions\")\n@@ -51,11 +46,10 @@ class MempoolCompatibilityTest(BitcoinTestFramework):\n         # unbroadcasted_tx won't pass old_node's `MemPoolAccept::PreChecks`.\n         self.connect_nodes(0, 1)\n         self.sync_blocks()\n-        recipient = old_node.getnewaddress()\n         self.stop_node(1)\n \n         self.log.info(\"Add a transaction to mempool on old node and shutdown\")\n-        old_tx_hash = old_node.sendtoaddress(recipient, 0.0001)\n+        old_tx_hash = new_wallet.send_self_transfer(from_node=old_node)[\"txid\"]\n         assert old_tx_hash in old_node.getrawmempool()\n         self.stop_node(0)\n \n\n\n###\n\n", "completion": "test: Run mempool_compatibility.py with MiniWallet"}
{"prompt": " file path A: test/functional/rpc_net.py | file path B: test/functional/rpc_net.py\n\n@@ -185,7 +185,8 @@ class NetTest(BitcoinTestFramework):\n             self.nodes[0].setnetworkactive(state=False)\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], False)\n         # Wait a bit for all sockets to close\n-        self.wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)\n+        for n in self.nodes:\n+            self.wait_until(lambda: n.getnetworkinfo()['connections'] == 0, timeout=3)\n \n         with self.nodes[0].assert_debug_log(expected_msgs=['SetNetworkActive: true\\n']):\n             self.nodes[0].setnetworkactive(state=True)\n\n\n###\n\n", "completion": "test: Fix intermittent issue in rpc_net.py"}
{"prompt": " file path A: src/test/rpc_tests.cpp | file path B: src/test/rpc_tests.cpp\n\n@@ -89,6 +89,9 @@ BOOST_AUTO_TEST_CASE(rpc_namedparams)\n     // Make sure named arguments are transformed into positional arguments in correct places separated by nulls\n     BOOST_CHECK_EQUAL(TransformParams(JSON(R\"({\"arg2\": 2, \"arg4\": 4})\"), arg_names).write(), \"[null,2,null,4]\");\n \n+    // Make sure later named argument value silently overwrites earlier values\n+    BOOST_CHECK_EQUAL(TransformParams(JSON(R\"({\"arg2\": 2, \"arg2\": 4})\"), arg_names).write(), \"[null,4]\");\n+\n     // Make sure named and positional arguments can be combined.\n     BOOST_CHECK_EQUAL(TransformParams(JSON(R\"({\"arg5\": 5, \"args\": [1, 2], \"arg4\": 4})\"), arg_names).write(), \"[1,2,null,4,5]\");\n \n\n---\n file path A: test/functional/interface_bitcoin_cli.py | file path B: test/functional/interface_bitcoin_cli.py\n\n@@ -90,6 +90,10 @@ class TestBitcoinCli(BitcoinTestFramework):\n         assert_raises_rpc_error(-8, \"Parameter arg1 specified twice both as positional and named argument\", self.nodes[0].cli.echo, 0, 1, arg1=1)\n         assert_raises_rpc_error(-8, \"Parameter arg1 specified twice both as positional and named argument\", self.nodes[0].cli.echo, 0, None, 2, arg1=1)\n \n+        self.log.info(\"Test that later cli named arguments values silently overwrite earlier ones\")\n+        assert_equal(self.nodes[0].cli(\"-named\", \"echo\", \"arg0=0\", \"arg1=1\", \"arg2=2\", \"arg1=3\").send_cli(), ['0', '3', '2'])\n+        assert_equal(self.nodes[0].cli(\"-named\", \"echo\", \"args=[0,1,2,3]\", \"4\", \"5\", \"6\", ).send_cli(), ['4', '5', '6'])\n+\n         user, password = get_auth_cookie(self.nodes[0].datadir, self.chain)\n \n         self.log.info(\"Test -stdinrpcpass option\")\n\n\n###\n\n", "completion": "test: Add RPC tests for same named parameter specified more than once"}
{"prompt": " file path A: src/wallet/spend.cpp | file path B: src/wallet/spend.cpp\n\n@@ -332,7 +332,7 @@ CoinsResult AvailableCoins(const CWallet& wallet,\n \n             // Checks the sum amount of all UTXO's.\n             if (params.min_sum_amount != MAX_MONEY) {\n-                if (result.total_amount >= params.min_sum_amount) {\n+                if (result.GetTotalAmount() >= params.min_sum_amount) {\n                     return result;\n                 }\n             }\n@@ -356,7 +356,7 @@ CoinsResult AvailableCoinsListUnspent(const CWallet& wallet, const CCoinControl*\n CAmount GetAvailableBalance(const CWallet& wallet, const CCoinControl* coinControl)\n {\n     LOCK(wallet.cs_wallet);\n-    return AvailableCoins(wallet, coinControl).total_amount;\n+    return AvailableCoins(wallet, coinControl).GetTotalAmount();\n }\n \n const CTxOut& FindNonChangeParentOutput(const CWallet& wallet, const CTransaction& tx, int output)\n@@ -586,8 +586,8 @@ std::optional<SelectionResult> SelectCoins(const CWallet& wallet, CoinsResult& a\n \n     // Return early if we cannot cover the target with the wallet's UTXO.\n     // We use the total effective value if we are not subtracting fee from outputs and 'available_coins' contains the data.\n-    CAmount available_coins_total_amount = coin_selection_params.m_subtract_fee_outputs ? available_coins.total_amount :\n-            (available_coins.total_effective_amount.has_value() ? *available_coins.total_effective_amount : 0);\n+    CAmount available_coins_total_amount = coin_selection_params.m_subtract_fee_outputs ? available_coins.GetTotalAmount() :\n+            (available_coins.GetEffectiveTotalAmount().has_value() ? *available_coins.GetEffectiveTotalAmount() : 0);\n     if (selection_target > available_coins_total_amount) {\n         return std::nullopt; // Insufficient funds\n     }\n\n---\n file path A: src/wallet/spend.h | file path B: src/wallet/spend.h\n\n@@ -51,6 +51,10 @@ struct CoinsResult {\n     void Shuffle(FastRandomContext& rng_fast);\n     void Add(OutputType type, const COutput& out);\n \n+    CAmount GetTotalAmount() { return total_amount; }\n+    std::optional<CAmount> GetEffectiveTotalAmount() {return total_effective_amount; }\n+\n+private:\n     /** Sum of all available coins raw value */\n     CAmount total_amount{0};\n     /** Sum of all available coins effective value (each output value minus fees required to spend it) */\n\n\n###\n\n", "completion": "refactor: make CoinsResult total amounts members private"}
{"prompt": " file path A: src/wallet/test/coinselector_tests.cpp | file path B: src/wallet/test/coinselector_tests.cpp\n\n@@ -83,7 +83,7 @@ static void add_coin(CoinsResult& available_coins, CWallet& wallet, const CAmoun\n     assert(ret.second);\n     CWalletTx& wtx = (*ret.first).second;\n     const auto& txout = wtx.tx->vout.at(nInput);\n-    available_coins.coins[OutputType::BECH32].emplace_back(COutPoint(wtx.GetHash(), nInput), txout, nAge, CalculateMaximumSignedInputSize(txout, &wallet, /*coin_control=*/nullptr), /*spendable=*/ true, /*solvable=*/ true, /*safe=*/ true, wtx.GetTxTime(), fIsFromMe, feerate);\n+    available_coins.Add(OutputType::BECH32, {COutPoint(wtx.GetHash(), nInput), txout, nAge, CalculateMaximumSignedInputSize(txout, &wallet, /*coin_control=*/nullptr), /*spendable=*/ true, /*solvable=*/ true, /*safe=*/ true, wtx.GetTxTime(), fIsFromMe, feerate});\n }\n \n /** Check if SelectionResult a is equivalent to SelectionResult b.\n@@ -342,7 +342,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.Select(select_coin.outpoint);\n         PreSelectedInputs selected_input;\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n-        available_coins.coins[OutputType::BECH32].erase(available_coins.coins[OutputType::BECH32].begin());\n+        available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(0);\n         const auto result10 = SelectCoins(*wallet, available_coins, selected_input, 10 * CENT, coin_control, coin_selection_params_bnb);\n         BOOST_CHECK(result10);\n@@ -402,7 +402,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.Select(select_coin.outpoint);\n         PreSelectedInputs selected_input;\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n-        available_coins.coins[OutputType::BECH32].erase(++available_coins.coins[OutputType::BECH32].begin());\n+        available_coins.Erase({(++available_coins.coins[OutputType::BECH32].begin())->outpoint});\n         const auto result13 = SelectCoins(*wallet, available_coins, selected_input, 10 * CENT, coin_control, coin_selection_params_bnb);\n         BOOST_CHECK(EquivalentResult(expected_result, *result13));\n     }\n@@ -974,7 +974,7 @@ BOOST_AUTO_TEST_CASE(SelectCoins_effective_value_test)\n     cc.SelectExternal(output.outpoint, output.txout);\n \n     const auto preset_inputs = *Assert(FetchSelectedInputs(*wallet, cc, cs_params));\n-    available_coins.coins[OutputType::BECH32].erase(available_coins.coins[OutputType::BECH32].begin());\n+    available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n \n     const auto result = SelectCoins(*wallet, available_coins, preset_inputs, target, cc, cs_params);\n     BOOST_CHECK(!result);\n\n\n###\n\n", "completion": "test: bugfix, coinselector_test, use 'CoinsResult::Erase/Add' instead of direct member access"}
{"prompt": " file path A: src/wallet/test/spend_tests.cpp | file path B: src/wallet/test/spend_tests.cpp\n\n@@ -112,5 +112,50 @@ BOOST_FIXTURE_TEST_CASE(FillInputToWeightTest, BasicTestingSetup)\n     // Note: We don't test the next boundary because of memory allocation constraints.\n }\n \n+BOOST_FIXTURE_TEST_CASE(wallet_duplicated_preset_inputs_test, TestChain100Setup)\n+{\n+    // Verify that the wallet's Coin Selection process does not include pre-selected inputs twice in a transaction.\n+\n+    // Add 4 spendable UTXO, 50 BTC each, to the wallet (total balance 200 BTC)\n+    for (int i = 0; i < 4; i++) CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n+    auto wallet = CreateSyncedWallet(*m_node.chain, WITH_LOCK(Assert(m_node.chainman)->GetMutex(), return m_node.chainman->ActiveChain()), m_args, coinbaseKey);\n+\n+    LOCK(wallet->cs_wallet);\n+    auto available_coins = AvailableCoins(*wallet);\n+    std::vector<COutput> coins = available_coins.All();\n+    // Preselect the first 3 UTXO (150 BTC total)\n+    std::set<COutPoint> preset_inputs = {coins[0].outpoint, coins[1].outpoint, coins[2].outpoint};\n+\n+    // Try to create a tx that spends more than what preset inputs + wallet selected inputs are covering for.\n+    // The wallet can cover up to 200 BTC, and the tx target is 299 BTC.\n+    std::vector<CRecipient> recipients = {{GetScriptForDestination(*Assert(wallet->GetNewDestination(OutputType::BECH32, \"dummy\"))),\n+                                           /*nAmount=*/299 * COIN, /*fSubtractFeeFromAmount=*/true}};\n+    CCoinControl coin_control;\n+    coin_control.m_allow_other_inputs = true;\n+    for (const auto& outpoint : preset_inputs) {\n+        coin_control.Select(outpoint);\n+    }\n+\n+    // Attempt to send 299 BTC from a wallet that only has 200 BTC. The wallet should exclude\n+    // the preset inputs from the pool of available coins, realize that there is not enough\n+    // money to fund the 299 BTC payment, and fail with \"Insufficient funds\".\n+    //\n+    // Even with SFFO, the wallet can only afford to send 200 BTC.\n+    // If the wallet does not properly exclude preset inputs from the pool of available coins\n+    // prior to coin selection, it may create a transaction that does not fund the full payment\n+    // amount or, through SFFO, incorrectly reduce the recipient's amount by the difference\n+    // between the original target and the wrongly counted inputs (in this case 99 BTC)\n+    // so that the recipient's amount is no longer equal to the user's selected target of 299 BTC.\n+\n+    // First case, use 'subtract_fee_from_outputs=true'\n+    util::Result<CreatedTransactionResult> res_tx = CreateTransaction(*wallet, recipients, /*change_pos*/-1, coin_control);\n+    BOOST_CHECK(!res_tx.has_value());\n+\n+    // Second case, don't use 'subtract_fee_from_outputs'.\n+    recipients[0].fSubtractFeeFromAmount = false;\n+    res_tx = CreateTransaction(*wallet, recipients, /*change_pos*/-1, coin_control);\n+    BOOST_CHECK(!res_tx.has_value());\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()\n } // namespace wallet\n\n---\n file path A: test/functional/rpc_fundrawtransaction.py | file path B: test/functional/rpc_fundrawtransaction.py\n\n@@ -107,6 +107,7 @@ class RawTransactionsTest(BitcoinTestFramework):\n         self.generate(self.nodes[0], 121)\n \n         self.test_add_inputs_default_value()\n+        self.test_preset_inputs_selection()\n         self.test_weight_calculation()\n         self.test_change_position()\n         self.test_simple()\n@@ -1200,6 +1201,50 @@ class RawTransactionsTest(BitcoinTestFramework):\n \n         self.nodes[2].unloadwallet(\"test_preset_inputs\")\n \n+    def test_preset_inputs_selection(self):\n+        self.log.info('Test wallet preset inputs are not double-counted or reused in coin selection')\n+\n+        # Create and fund the wallet with 4 UTXO of 5 BTC each (20 BTC total)\n+        self.nodes[2].createwallet(\"test_preset_inputs_selection\")\n+        wallet = self.nodes[2].get_wallet_rpc(\"test_preset_inputs_selection\")\n+        outputs = {}\n+        for _ in range(4):\n+            outputs[wallet.getnewaddress(address_type=\"bech32\")] = 5\n+        self.nodes[0].sendmany(\"\", outputs)\n+        self.generate(self.nodes[0], 1)\n+\n+        # Select the preset inputs\n+        coins = wallet.listunspent()\n+        preset_inputs = [coins[0], coins[1], coins[2]]\n+\n+        # Now let's create the tx creation options\n+        options = {\n+            \"inputs\": preset_inputs,\n+            \"add_inputs\": True,  # automatically add coins from the wallet to fulfill the target\n+            \"subtract_fee_from_outputs\": [0],  # deduct fee from first output\n+            \"add_to_wallet\": False\n+        }\n+\n+        # Attempt to send 29 BTC from a wallet that only has 20 BTC. The wallet should exclude\n+        # the preset inputs from the pool of available coins, realize that there is not enough\n+        # money to fund the 29 BTC payment, and fail with \"Insufficient funds\".\n+        #\n+        # Even with SFFO, the wallet can only afford to send 20 BTC.\n+        # If the wallet does not properly exclude preset inputs from the pool of available coins\n+        # prior to coin selection, it may create a transaction that does not fund the full payment\n+        # amount or, through SFFO, incorrectly reduce the recipient's amount by the difference\n+        # between the original target and the wrongly counted inputs (in this case 9 BTC)\n+        # so that the recipient's amount is no longer equal to the user's selected target of 29 BTC.\n+\n+        # First case, use 'subtract_fee_from_outputs = true'\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", wallet.send, outputs=[{wallet.getnewaddress(address_type=\"bech32\"): 29}], options=options)\n+\n+        # Second case, don't use 'subtract_fee_from_outputs'\n+        del options[\"subtract_fee_from_outputs\"]\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", wallet.send, outputs=[{wallet.getnewaddress(address_type=\"bech32\"): 29}], options=options)\n+\n+        self.nodes[2].unloadwallet(\"test_preset_inputs_selection\")\n+\n     def test_weight_calculation(self):\n         self.log.info(\"Test weight calculation with external inputs\")\n \n\n\n###\n\n", "completion": "test: Coin Selection, duplicated preset inputs selection"}
{"prompt": " file path A: src/wallet/test/coinselector_tests.cpp | file path B: src/wallet/test/coinselector_tests.cpp\n\n@@ -980,5 +980,45 @@ BOOST_AUTO_TEST_CASE(SelectCoins_effective_value_test)\n     BOOST_CHECK(!result);\n }\n \n+BOOST_FIXTURE_TEST_CASE(wallet_coinsresult_test, BasicTestingSetup)\n+{\n+    // Test case to verify CoinsResult object sanity.\n+    CoinsResult available_coins;\n+    {\n+        std::unique_ptr<CWallet> dummyWallet = std::make_unique<CWallet>(m_node.chain.get(), \"dummy\", m_args, CreateMockWalletDatabase());\n+        BOOST_CHECK_EQUAL(dummyWallet->LoadWallet(), DBErrors::LOAD_OK);\n+        LOCK(dummyWallet->cs_wallet);\n+        dummyWallet->SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n+        dummyWallet->SetupDescriptorScriptPubKeyMans();\n+\n+        // Add some coins to 'available_coins'\n+        for (int i=0; i<10; i++) {\n+            add_coin(available_coins, *dummyWallet, 1 * COIN);\n+        }\n+    }\n+\n+    {\n+        // First test case, check that 'CoinsResult::Erase' function works as expected.\n+        // By trying to erase two elements from the 'available_coins' object.\n+        std::unordered_set<COutPoint, SaltedOutpointHasher> outs_to_remove;\n+        const auto& coins = available_coins.All();\n+        for (int i = 0; i < 2; i++) {\n+            outs_to_remove.emplace(coins[i].outpoint);\n+        }\n+        available_coins.Erase(outs_to_remove);\n+\n+        // Check that the elements were actually removed.\n+        const auto& updated_coins = available_coins.All();\n+        for (const auto& out: outs_to_remove) {\n+            auto it = std::find_if(updated_coins.begin(), updated_coins.end(), [&out](const COutput &coin) {\n+                return coin.outpoint == out;\n+            });\n+            BOOST_CHECK(it == updated_coins.end());\n+        }\n+        // And verify that no extra element were removed\n+        BOOST_CHECK_EQUAL(available_coins.Size(), 8);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()\n } // namespace wallet\n\n\n###\n\n", "completion": "test: wallet, coverage for CoinsResult::Erase function"}
{"prompt": " file path A: test/functional/wallet_sendall.py | file path B: test/functional/wallet_sendall.py\n\n@@ -284,6 +284,12 @@ class SendallTest(BitcoinTestFramework):\n                 recipients=[self.remainder_target],\n                 fee_rate=100000)\n \n+    @cleanup\n+    def sendall_fails_on_low_fee(self):\n+        self.log.info(\"Test sendall fails if the transaction fee is lower than the minimum fee rate setting\")\n+        assert_raises_rpc_error(-8, \"Fee rate (0.999 sat/vB) is lower than the minimum fee rate setting (1.000 sat/vB)\",\n+        self.wallet.sendall, recipients=[self.recipient], fee_rate=0.999)\n+\n     @cleanup\n     def sendall_watchonly_specific_inputs(self):\n         self.log.info(\"Test sendall with a subset of UTXO pool in a watchonly wallet\")\n@@ -376,6 +382,9 @@ class SendallTest(BitcoinTestFramework):\n         # Sendall fails when providing a fee that is too high\n         self.sendall_fails_on_high_fee()\n \n+        # Sendall fails when fee rate is lower than minimum\n+        self.sendall_fails_on_low_fee()\n+\n         # Sendall succeeds with watchonly wallets spending specific UTXOs\n         self.sendall_watchonly_specific_inputs()\n \n\n\n###\n\n", "completion": "test: Add sendall test for min-fee setting"}
{"prompt": " file path A: src/net_processing.cpp | file path B: src/net_processing.cpp\n\n@@ -2291,9 +2291,9 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n             std::vector<uint256> parent_ids_to_add;\n             {\n                 LOCK(m_mempool.cs);\n-                auto txiter = m_mempool.GetIter(tx->GetHash());\n-                if (txiter) {\n-                    const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                auto tx_iter = m_mempool.GetIter(tx->GetHash());\n+                if (tx_iter) {\n+                    const CTxMemPoolEntry::Parents& parents = (*tx_iter)->GetMemPoolParentsConst();\n                     parent_ids_to_add.reserve(parents.size());\n                     for (const CTxMemPoolEntry& parent : parents) {\n                         if (parent.GetTime() > now - UNCONDITIONAL_RELAY_DELAY) {\n\n\n###\n\n", "completion": "refactor: Rename local variable to distinguish it from type alias"}
{"prompt": " file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -408,10 +408,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n \n     def setup_nodes(self):\n         \"\"\"Override this method to customize test node setup\"\"\"\n-        extra_args = [[]] * self.num_nodes\n-        if hasattr(self, \"extra_args\"):\n-            extra_args = self.extra_args\n-        self.add_nodes(self.num_nodes, extra_args)\n+        self.add_nodes(self.num_nodes, self.extra_args)\n         self.start_nodes()\n         if self.requires_wallet:\n             self.import_deterministic_coinbase_privkeys()\n\n\n###\n\n", "completion": "test: remove unneeded extra_args code"}
{"prompt": " file path A: test/functional/feature_cltv.py | file path B: test/functional/feature_cltv.py\n\n@@ -8,6 +8,7 @@ Test that the CHECKLOCKTIMEVERIFY soft-fork activates.\n \"\"\"\n \n from test_framework.blocktools import (\n+    TIME_GENESIS_BLOCK,\n     create_block,\n     create_coinbase,\n )\n@@ -61,7 +62,7 @@ def cltv_invalidate(tx, failure_reason):\n         # +-------------------------------------------------+------------+--------------+\n         [[OP_CHECKLOCKTIMEVERIFY],                            None,       None],\n         [[OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP],       None,       None],\n-        [[CScriptNum(100), OP_CHECKLOCKTIMEVERIFY, OP_DROP],  0,          1296688602],  # timestamp of genesis block\n+        [[CScriptNum(100), OP_CHECKLOCKTIMEVERIFY, OP_DROP],  0,          TIME_GENESIS_BLOCK],\n         [[CScriptNum(100), OP_CHECKLOCKTIMEVERIFY, OP_DROP],  0,          50],\n         [[CScriptNum(50),  OP_CHECKLOCKTIMEVERIFY, OP_DROP],  SEQUENCE_FINAL, 50],\n     ][failure_reason]\n\n---\n file path A: test/functional/wallet_listdescriptors.py | file path B: test/functional/wallet_listdescriptors.py\n\n@@ -4,8 +4,11 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the listdescriptors RPC.\"\"\"\n \n+from test_framework.blocktools import (\n+    TIME_GENESIS_BLOCK,\n+)\n from test_framework.descriptors import (\n-    descsum_create\n+    descsum_create,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -66,13 +69,13 @@ class ListDescriptorsTest(BitcoinTestFramework):\n         wallet = node.get_wallet_rpc('w2')\n         wallet.importdescriptors([{\n             'desc': descsum_create('wpkh(' + xprv + hardened_path + '/0/*)'),\n-            'timestamp': 1296688602,\n+            'timestamp': TIME_GENESIS_BLOCK,\n         }])\n         expected = {\n             'wallet_name': 'w2',\n             'descriptors': [\n                 {'desc': descsum_create('wpkh([80002067' + hardened_path + ']' + xpub_acc + '/0/*)'),\n-                 'timestamp': 1296688602,\n+                 'timestamp': TIME_GENESIS_BLOCK,\n                  'active': False,\n                  'range': [0, 0],\n                  'next': 0},\n@@ -86,7 +89,7 @@ class ListDescriptorsTest(BitcoinTestFramework):\n             'wallet_name': 'w2',\n             'descriptors': [\n                 {'desc': descsum_create('wpkh(' + xprv + hardened_path + '/0/*)'),\n-                 'timestamp': 1296688602,\n+                 'timestamp': TIME_GENESIS_BLOCK,\n                  'active': False,\n                  'range': [0, 0],\n                  'next': 0},\n@@ -108,7 +111,7 @@ class ListDescriptorsTest(BitcoinTestFramework):\n         watch_only_wallet = node.get_wallet_rpc('watch-only')\n         watch_only_wallet.importdescriptors([{\n             'desc': descsum_create('wpkh(' + xpub_acc + ')'),\n-            'timestamp': 1296688602,\n+            'timestamp': TIME_GENESIS_BLOCK,\n         }])\n         assert_raises_rpc_error(-4, 'Can\\'t get descriptor string', watch_only_wallet.listdescriptors, True)\n \n@@ -117,14 +120,14 @@ class ListDescriptorsTest(BitcoinTestFramework):\n         wallet = node.get_wallet_rpc('w4')\n         wallet.importdescriptors([{\n             'desc': descsum_create('combo(' + node.get_deterministic_priv_key().key + ')'),\n-            'timestamp': 1296688602,\n+            'timestamp': TIME_GENESIS_BLOCK,\n         }])\n         expected = {\n             'wallet_name': 'w4',\n             'descriptors': [\n                 {'active': False,\n                  'desc': 'combo(0227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3f)#np574htj',\n-                 'timestamp': 1296688602},\n+                 'timestamp': TIME_GENESIS_BLOCK},\n             ]\n         }\n         assert_equal(expected, wallet.listdescriptors())\n\n\n###\n\n", "completion": "test: refactor: eliminate genesis block timestamp magic numbers"}
{"prompt": " file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -97,6 +97,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n         self.chain: str = 'regtest'\n         self.setup_clean_chain: bool = False\n         self.nodes: List[TestNode] = []\n+        self.extra_args = None\n         self.network_thread = None\n         self.rpc_timeout = 60  # Wait for up to 60 seconds for the RPC server to respond\n         self.supports_cli = True\n\n\n###\n\n", "completion": "test: add extra_args to BTF class"}
{"prompt": " file path A: test/functional/wallet_bumpfee.py | file path B: test/functional/wallet_bumpfee.py\n\n@@ -17,10 +17,6 @@ from decimal import Decimal\n \n from test_framework.blocktools import (\n     COINBASE_MATURITY,\n-    add_witness_commitment,\n-    create_block,\n-    create_coinbase,\n-    send_to_witness,\n )\n from test_framework.messages import (\n     MAX_BIP125_RBF_SEQUENCE,\n@@ -203,16 +199,8 @@ def test_segwit_bumpfee_succeeds(self, rbf_node, dest_address):\n     # Create a transaction with segwit output, then create an RBF transaction\n     # which spends it, and make sure bumpfee can be called on it.\n \n-    segwit_in = next(u for u in rbf_node.listunspent() if u[\"amount\"] == Decimal(\"0.001\"))\n-    segwit_out = rbf_node.getaddressinfo(rbf_node.getnewaddress(address_type='bech32'))\n-    segwitid = send_to_witness(\n-        use_p2wsh=False,\n-        node=rbf_node,\n-        utxo=segwit_in,\n-        pubkey=segwit_out[\"pubkey\"],\n-        encode_p2sh=False,\n-        amount=Decimal(\"0.0009\"),\n-        sign=True)\n+    segwit_out = rbf_node.getnewaddress(address_type='bech32')\n+    segwitid = rbf_node.send({segwit_out: \"0.0009\"}, options={\"change_position\": 1})[\"txid\"]\n \n     rbfraw = rbf_node.createrawtransaction([{\n         'txid': segwitid,\n@@ -544,10 +532,10 @@ def test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):\n     # then invalidate the block so the rbf tx will be put back in the mempool.\n     # This makes it possible to check whether the rbf tx outputs are\n     # spendable before the rbf tx is confirmed.\n-    block = submit_block_with_tx(rbf_node, rbftx)\n+    block = self.generateblock(rbf_node, output=\"raw(51)\", transactions=[rbftx])\n     # Can not abandon conflicted tx\n     assert_raises_rpc_error(-5, 'Transaction not eligible for abandonment', lambda: rbf_node.abandontransaction(txid=bumpid))\n-    rbf_node.invalidateblock(block.hash)\n+    rbf_node.invalidateblock(block[\"hash\"])\n     # Call abandon to make sure the wallet doesn't attempt to resubmit\n     # the bump tx and hope the wallet does not rebroadcast before we call.\n     rbf_node.abandontransaction(bumpid)\n@@ -622,17 +610,6 @@ def spend_one_input(node, dest_address, change_size=Decimal(\"0.00049000\")):\n     return txid\n \n \n-def submit_block_with_tx(node, tx):\n-    tip = node.getbestblockhash()\n-    height = node.getblockcount() + 1\n-    block_time = node.getblockheader(tip)[\"mediantime\"] + 1\n-    block = create_block(int(tip, 16), create_coinbase(height), block_time, txlist=[tx])\n-    add_witness_commitment(block)\n-    block.solve()\n-    node.submitblock(block.serialize().hex())\n-    return block\n-\n-\n def test_no_more_inputs_fails(self, rbf_node, dest_address):\n     self.log.info('Test that bumpfee fails when there are no available confirmed outputs')\n     # feerate rbf requires confirmed outputs when change output doesn't exist or is insufficient\n\n\n###\n\n", "completion": "test: Remove unused blocktools imports from wallet_bumpfee"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -177,6 +177,7 @@ BITCOIN_CORE_H = \\\n   kernel/checks.h \\\n   kernel/coinstats.h \\\n   kernel/context.h \\\n+  kernel/mempool_entry.h \\\n   kernel/mempool_limits.h \\\n   kernel/mempool_options.h \\\n   kernel/mempool_persist.h \\\n@@ -263,7 +264,6 @@ BITCOIN_CORE_H = \\\n   torcontrol.h \\\n   txdb.h \\\n   txmempool.h \\\n-  txmempool_entry.h \\\n   txorphanage.h \\\n   txrequest.h \\\n   undo.h \\\n\n---\n file path A: src/bench/mempool_eviction.cpp | file path B: src/bench/mempool_eviction.cpp\n\n@@ -3,10 +3,10 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n+#include <kernel/mempool_entry.h>\n #include <policy/policy.h>\n #include <test/util/setup_common.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n \n \n static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n\n---\n file path A: src/bench/mempool_stress.cpp | file path B: src/bench/mempool_stress.cpp\n\n@@ -3,10 +3,10 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n+#include <kernel/mempool_entry.h>\n #include <policy/policy.h>\n #include <test/util/setup_common.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <validation.h>\n \n #include <vector>\n\n---\n file path A: src/bench/rpc_mempool.cpp | file path B: src/bench/rpc_mempool.cpp\n\n@@ -4,10 +4,10 @@\n \n #include <bench/bench.h>\n #include <chainparamsbase.h>\n+#include <kernel/mempool_entry.h>\n #include <rpc/mempool.h>\n #include <test/util/setup_common.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n \n #include <univalue.h>\n \n\n---\n file path A: src/txmempool_entry.h | file path B: src/kernel/mempool_entry.h\n\n@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_TXMEMPOOL_ENTRY_H\n-#define BITCOIN_TXMEMPOOL_ENTRY_H\n+#ifndef BITCOIN_KERNEL_MEMPOOL_ENTRY_H\n+#define BITCOIN_KERNEL_MEMPOOL_ENTRY_H\n \n #include <consensus/amount.h>\n #include <consensus/validation.h>\n@@ -171,4 +171,4 @@ public:\n     mutable Epoch::Marker m_epoch_marker; //!< epoch when last touched, useful for graph algorithms\n };\n \n-#endif // BITCOIN_TXMEMPOOL_ENTRY_H\n+#endif // BITCOIN_KERNEL_MEMPOOL_ENTRY_H\n\n---\n file path A: src/net_processing.cpp | file path B: src/net_processing.cpp\n\n@@ -16,6 +16,7 @@\n #include <hash.h>\n #include <headerssync.h>\n #include <index/blockfilterindex.h>\n+#include <kernel/mempool_entry.h>\n #include <merkleblock.h>\n #include <netbase.h>\n #include <netmessagemaker.h>\n@@ -34,7 +35,6 @@\n #include <timedata.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <txorphanage.h>\n #include <txrequest.h>\n #include <util/check.h> // For NDEBUG compile time check\n\n---\n file path A: src/node/interfaces.cpp | file path B: src/node/interfaces.cpp\n\n@@ -15,17 +15,18 @@\n #include <interfaces/handler.h>\n #include <interfaces/node.h>\n #include <interfaces/wallet.h>\n+#include <kernel/chain.h>\n+#include <kernel/mempool_entry.h>\n #include <mapport.h>\n #include <net.h>\n #include <net_processing.h>\n #include <netaddress.h>\n #include <netbase.h>\n #include <node/blockstorage.h>\n-#include <kernel/chain.h>\n #include <node/coin.h>\n #include <node/context.h>\n-#include <node/transaction.h>\n #include <node/interface_ui.h>\n+#include <node/transaction.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n@@ -39,7 +40,6 @@\n #include <support/allocators/secure.h>\n #include <sync.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <uint256.h>\n #include <univalue.h>\n #include <util/check.h>\n\n---\n file path A: src/policy/fees.cpp | file path B: src/policy/fees.cpp\n\n@@ -8,6 +8,7 @@\n #include <clientversion.h>\n #include <consensus/amount.h>\n #include <fs.h>\n+#include <kernel/mempool_entry.h>\n #include <logging.h>\n #include <policy/feerate.h>\n #include <primitives/transaction.h>\n@@ -16,7 +17,6 @@\n #include <streams.h>\n #include <sync.h>\n #include <tinyformat.h>\n-#include <txmempool_entry.h>\n #include <uint256.h>\n #include <util/serfloat.h>\n #include <util/system.h>\n\n---\n file path A: src/policy/rbf.cpp | file path B: src/policy/rbf.cpp\n\n@@ -5,12 +5,12 @@\n #include <policy/rbf.h>\n \n #include <consensus/amount.h>\n+#include <kernel/mempool_entry.h>\n #include <policy/feerate.h>\n #include <primitives/transaction.h>\n #include <sync.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <uint256.h>\n #include <util/moneystr.h>\n #include <util/rbf.h>\n\n---\n file path A: src/rpc/mempool.cpp | file path B: src/rpc/mempool.cpp\n\n@@ -10,6 +10,7 @@\n #include <chainparams.h>\n #include <core_io.h>\n #include <fs.h>\n+#include <kernel/mempool_entry.h>\n #include <node/mempool_persist_args.h>\n #include <policy/rbf.h>\n #include <policy/settings.h>\n@@ -18,7 +19,6 @@\n #include <rpc/server_util.h>\n #include <rpc/util.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <univalue.h>\n #include <util/moneystr.h>\n #include <util/time.h>\n\n---\n file path A: src/test/fuzz/policy_estimator.cpp | file path B: src/test/fuzz/policy_estimator.cpp\n\n@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/mempool_entry.h>\n #include <policy/fees.h>\n #include <policy/fees_args.h>\n #include <primitives/transaction.h>\n@@ -11,7 +12,6 @@\n #include <test/fuzz/util/mempool.h>\n #include <test/util/setup_common.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n \n #include <cstdint>\n #include <optional>\n\n---\n file path A: src/test/fuzz/util/mempool.cpp | file path B: src/test/fuzz/util/mempool.cpp\n\n@@ -4,11 +4,11 @@\n \n #include <consensus/amount.h>\n #include <consensus/consensus.h>\n+#include <kernel/mempool_entry.h>\n #include <primitives/transaction.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/util.h>\n #include <test/fuzz/util/mempool.h>\n-#include <txmempool_entry.h>\n \n #include <cassert>\n #include <cstdint>\n\n---\n file path A: src/test/fuzz/util/mempool.h | file path B: src/test/fuzz/util/mempool.h\n\n@@ -5,7 +5,7 @@\n #ifndef BITCOIN_TEST_FUZZ_UTIL_MEMPOOL_H\n #define BITCOIN_TEST_FUZZ_UTIL_MEMPOOL_H\n \n-#include <txmempool_entry.h>\n+#include <kernel/mempool_entry.h>\n #include <validation.h>\n \n class CTransaction;\n\n---\n file path A: src/test/util/setup_common.cpp | file path B: src/test/util/setup_common.cpp\n\n@@ -17,6 +17,7 @@\n #include <init.h>\n #include <init/common.h>\n #include <interfaces/chain.h>\n+#include <kernel/mempool_entry.h>\n #include <net.h>\n #include <net_processing.h>\n #include <node/blockstorage.h>\n@@ -41,7 +42,6 @@\n #include <timedata.h>\n #include <txdb.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/thread.h>\n\n---\n file path A: src/txmempool.h | file path B: src/txmempool.h\n\n@@ -20,12 +20,12 @@\n #include <coins.h>\n #include <consensus/amount.h>\n #include <indirectmap.h>\n+#include <kernel/mempool_entry.h>\n #include <policy/feerate.h>\n #include <policy/packages.h>\n #include <primitives/transaction.h>\n #include <random.h>\n #include <sync.h>\n-#include <txmempool_entry.h>\n #include <util/epochguard.h>\n #include <util/hasher.h>\n \n\n---\n file path A: src/validation.cpp | file path B: src/validation.cpp\n\n@@ -22,6 +22,7 @@\n #include <flatfile.h>\n #include <fs.h>\n #include <hash.h>\n+#include <kernel/mempool_entry.h>\n #include <logging.h>\n #include <logging/timer.h>\n #include <node/blockstorage.h>\n@@ -42,7 +43,6 @@\n #include <tinyformat.h>\n #include <txdb.h>\n #include <txmempool.h>\n-#include <txmempool_entry.h>\n #include <uint256.h>\n #include <undo.h>\n #include <util/check.h> // For NDEBUG compile time check\n\n\n###\n\n", "completion": "refactor: Move `txmempool_entry.h` --> `kernel/mempool_entry.h`"}
{"prompt": " file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -448,11 +448,13 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n     # Public helper methods. These can be accessed by the subclass test scripts.\n \n     def add_wallet_options(self, parser, *, descriptors=True, legacy=True):\n-        group = parser.add_mutually_exclusive_group()\n         kwargs = {}\n         if descriptors + legacy == 1:\n             # If only one type can be chosen, set it as default\n             kwargs[\"default\"] = descriptors\n+        group = parser.add_mutually_exclusive_group(\n+            # If only one type is allowed, require it to be set in test_runner.py\n+            required=os.getenv(\"REQUIRE_WALLET_TYPE_SET\") == \"1\" and \"default\" in kwargs)\n         if descriptors:\n             group.add_argument(\"--descriptors\", action='store_const', const=True, **kwargs,\n                                help=\"Run test using a descriptor wallet\", dest='descriptors')\n\n---\n file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -27,6 +27,8 @@ import re\n import logging\n import unittest\n \n+os.environ[\"REQUIRE_WALLET_TYPE_SET\"] = \"1\"\n+\n # Formatting. Default colors to empty strings.\n DEFAULT, BOLD, GREEN, RED = (\"\", \"\"), (\"\", \"\"), (\"\", \"\"), (\"\", \"\")\n try:\n@@ -159,7 +161,7 @@ BASE_SCRIPTS = [\n     'wallet_avoidreuse.py --descriptors',\n     'wallet_avoid_mixing_output_types.py --descriptors',\n     'mempool_reorg.py',\n-    'mempool_persist.py',\n+    'mempool_persist.py --descriptors',\n     'p2p_block_sync.py',\n     'wallet_multiwallet.py --legacy-wallet',\n     'wallet_multiwallet.py --descriptors',\n@@ -208,7 +210,7 @@ BASE_SCRIPTS = [\n     'wallet_keypool.py --legacy-wallet',\n     'wallet_keypool.py --descriptors',\n     'wallet_descriptor.py --descriptors',\n-    'wallet_miniscript.py',\n+    'wallet_miniscript.py --descriptors',\n     'feature_maxtipage.py',\n     'p2p_nobloomfilter_messages.py',\n     'p2p_filter.py',\n@@ -222,7 +224,7 @@ BASE_SCRIPTS = [\n     'feature_assumevalid.py',\n     'example_test.py',\n     'wallet_txn_doublespend.py --legacy-wallet',\n-    'wallet_multisig_descriptor_psbt.py',\n+    'wallet_multisig_descriptor_psbt.py --descriptors',\n     'wallet_txn_doublespend.py --descriptors',\n     'feature_backwards_compatibility.py --legacy-wallet',\n     'feature_backwards_compatibility.py --descriptors',\n@@ -294,8 +296,8 @@ BASE_SCRIPTS = [\n     'wallet_sendall.py --legacy-wallet',\n     'wallet_sendall.py --descriptors',\n     'wallet_create_tx.py --descriptors',\n-    'wallet_taproot.py',\n-    'wallet_inactive_hdchains.py',\n+    'wallet_taproot.py --descriptors',\n+    'wallet_inactive_hdchains.py --legacy-wallet',\n     'p2p_fingerprint.py',\n     'feature_uacomment.py',\n     'feature_init.py',\n\n\n###\n\n", "completion": "test: Set wallet type in test_runner when only one type is allowed"}
{"prompt": " file path A: src/common/interfaces.cpp | file path B: src/common/interfaces.cpp\n\n@@ -20,10 +20,10 @@ public:\n     std::function<void()> m_cleanup;\n };\n \n-class HandlerImpl : public interfaces::Handler\n+class SignalHandler : public interfaces::Handler\n {\n public:\n-    explicit HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) {}\n+    explicit SignalHandler(boost::signals2::connection connection) : m_connection(std::move(connection)) {}\n \n     void disconnect() override { m_connection.disconnect(); }\n \n@@ -39,14 +39,14 @@ public:\n } // namespace common\n \n namespace interfaces {\n-std::unique_ptr<Handler> MakeHandler(std::function<void()> cleanup)\n+std::unique_ptr<Handler> MakeCleanupHandler(std::function<void()> cleanup)\n {\n     return std::make_unique<common::CleanupHandler>(std::move(cleanup));\n }\n \n-std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection)\n+std::unique_ptr<Handler> MakeSignalHandler(boost::signals2::connection connection)\n {\n-    return std::make_unique<common::HandlerImpl>(std::move(connection));\n+    return std::make_unique<common::SignalHandler>(std::move(connection));\n }\n \n std::unique_ptr<Echo> MakeEcho() { return std::make_unique<common::EchoImpl>(); }\n\n---\n file path A: src/interfaces/handler.h | file path B: src/interfaces/handler.h\n\n@@ -29,10 +29,10 @@ public:\n };\n \n //! Return handler wrapping a boost signal connection.\n-std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection);\n+std::unique_ptr<Handler> MakeSignalHandler(boost::signals2::connection connection);\n \n //! Return handler wrapping a cleanup function.\n-std::unique_ptr<Handler> MakeHandler(std::function<void()> cleanup);\n+std::unique_ptr<Handler> MakeCleanupHandler(std::function<void()> cleanup);\n \n } // namespace interfaces\n \n\n---\n file path A: src/node/interfaces.cpp | file path B: src/node/interfaces.cpp\n\n@@ -64,7 +64,7 @@ using interfaces::BlockTip;\n using interfaces::Chain;\n using interfaces::FoundBlock;\n using interfaces::Handler;\n-using interfaces::MakeHandler;\n+using interfaces::MakeSignalHandler;\n using interfaces::Node;\n using interfaces::WalletLoader;\n \n@@ -336,50 +336,50 @@ public:\n     }\n     std::unique_ptr<Handler> handleInitMessage(InitMessageFn fn) override\n     {\n-        return MakeHandler(::uiInterface.InitMessage_connect(fn));\n+        return MakeSignalHandler(::uiInterface.InitMessage_connect(fn));\n     }\n     std::unique_ptr<Handler> handleMessageBox(MessageBoxFn fn) override\n     {\n-        return MakeHandler(::uiInterface.ThreadSafeMessageBox_connect(fn));\n+        return MakeSignalHandler(::uiInterface.ThreadSafeMessageBox_connect(fn));\n     }\n     std::unique_ptr<Handler> handleQuestion(QuestionFn fn) override\n     {\n-        return MakeHandler(::uiInterface.ThreadSafeQuestion_connect(fn));\n+        return MakeSignalHandler(::uiInterface.ThreadSafeQuestion_connect(fn));\n     }\n     std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) override\n     {\n-        return MakeHandler(::uiInterface.ShowProgress_connect(fn));\n+        return MakeSignalHandler(::uiInterface.ShowProgress_connect(fn));\n     }\n     std::unique_ptr<Handler> handleInitWallet(InitWalletFn fn) override\n     {\n-        return MakeHandler(::uiInterface.InitWallet_connect(fn));\n+        return MakeSignalHandler(::uiInterface.InitWallet_connect(fn));\n     }\n     std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) override\n     {\n-        return MakeHandler(::uiInterface.NotifyNumConnectionsChanged_connect(fn));\n+        return MakeSignalHandler(::uiInterface.NotifyNumConnectionsChanged_connect(fn));\n     }\n     std::unique_ptr<Handler> handleNotifyNetworkActiveChanged(NotifyNetworkActiveChangedFn fn) override\n     {\n-        return MakeHandler(::uiInterface.NotifyNetworkActiveChanged_connect(fn));\n+        return MakeSignalHandler(::uiInterface.NotifyNetworkActiveChanged_connect(fn));\n     }\n     std::unique_ptr<Handler> handleNotifyAlertChanged(NotifyAlertChangedFn fn) override\n     {\n-        return MakeHandler(::uiInterface.NotifyAlertChanged_connect(fn));\n+        return MakeSignalHandler(::uiInterface.NotifyAlertChanged_connect(fn));\n     }\n     std::unique_ptr<Handler> handleBannedListChanged(BannedListChangedFn fn) override\n     {\n-        return MakeHandler(::uiInterface.BannedListChanged_connect(fn));\n+        return MakeSignalHandler(::uiInterface.BannedListChanged_connect(fn));\n     }\n     std::unique_ptr<Handler> handleNotifyBlockTip(NotifyBlockTipFn fn) override\n     {\n-        return MakeHandler(::uiInterface.NotifyBlockTip_connect([fn](SynchronizationState sync_state, const CBlockIndex* block) {\n+        return MakeSignalHandler(::uiInterface.NotifyBlockTip_connect([fn](SynchronizationState sync_state, const CBlockIndex* block) {\n             fn(sync_state, BlockTip{block->nHeight, block->GetBlockTime(), block->GetBlockHash()},\n                 GuessVerificationProgress(Params().TxData(), block));\n         }));\n     }\n     std::unique_ptr<Handler> handleNotifyHeaderTip(NotifyHeaderTipFn fn) override\n     {\n-        return MakeHandler(\n+        return MakeSignalHandler(\n             ::uiInterface.NotifyHeaderTip_connect([fn](SynchronizationState sync_state, int64_t height, int64_t timestamp, bool presync) {\n                 fn(sync_state, BlockTip{(int)height, timestamp, uint256{}}, presync);\n             }));\n\n---\n file path A: src/wallet/interfaces.cpp | file path B: src/wallet/interfaces.cpp\n\n@@ -36,7 +36,7 @@\n using interfaces::Chain;\n using interfaces::FoundBlock;\n using interfaces::Handler;\n-using interfaces::MakeHandler;\n+using interfaces::MakeSignalHandler;\n using interfaces::Wallet;\n using interfaces::WalletAddress;\n using interfaces::WalletBalances;\n@@ -486,34 +486,34 @@ public:\n     bool isLegacy() override { return m_wallet->IsLegacy(); }\n     std::unique_ptr<Handler> handleUnload(UnloadFn fn) override\n     {\n-        return MakeHandler(m_wallet->NotifyUnload.connect(fn));\n+        return MakeSignalHandler(m_wallet->NotifyUnload.connect(fn));\n     }\n     std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) override\n     {\n-        return MakeHandler(m_wallet->ShowProgress.connect(fn));\n+        return MakeSignalHandler(m_wallet->ShowProgress.connect(fn));\n     }\n     std::unique_ptr<Handler> handleStatusChanged(StatusChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet->NotifyStatusChanged.connect([fn](CWallet*) { fn(); }));\n+        return MakeSignalHandler(m_wallet->NotifyStatusChanged.connect([fn](CWallet*) { fn(); }));\n     }\n     std::unique_ptr<Handler> handleAddressBookChanged(AddressBookChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet->NotifyAddressBookChanged.connect(\n+        return MakeSignalHandler(m_wallet->NotifyAddressBookChanged.connect(\n             [fn](const CTxDestination& address, const std::string& label, bool is_mine,\n                  const std::string& purpose, ChangeType status) { fn(address, label, is_mine, purpose, status); }));\n     }\n     std::unique_ptr<Handler> handleTransactionChanged(TransactionChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet->NotifyTransactionChanged.connect(\n+        return MakeSignalHandler(m_wallet->NotifyTransactionChanged.connect(\n             [fn](const uint256& txid, ChangeType status) { fn(txid, status); }));\n     }\n     std::unique_ptr<Handler> handleWatchOnlyChanged(WatchOnlyChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet->NotifyWatchonlyChanged.connect(fn));\n+        return MakeSignalHandler(m_wallet->NotifyWatchonlyChanged.connect(fn));\n     }\n     std::unique_ptr<Handler> handleCanGetAddressesChanged(CanGetAddressesChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet->NotifyCanGetAddressesChanged.connect(fn));\n+        return MakeSignalHandler(m_wallet->NotifyCanGetAddressesChanged.connect(fn));\n     }\n     CWallet* wallet() override { return m_wallet.get(); }\n \n\n---\n file path A: src/wallet/wallet.cpp | file path B: src/wallet/wallet.cpp\n\n@@ -171,7 +171,7 @@ std::unique_ptr<interfaces::Handler> HandleLoadWallet(WalletContext& context, Lo\n {\n     LOCK(context.wallets_mutex);\n     auto it = context.wallet_load_fns.emplace(context.wallet_load_fns.end(), std::move(load_wallet));\n-    return interfaces::MakeHandler([&context, it] { LOCK(context.wallets_mutex); context.wallet_load_fns.erase(it); });\n+    return interfaces::MakeCleanupHandler([&context, it] { LOCK(context.wallets_mutex); context.wallet_load_fns.erase(it); });\n }\n \n void NotifyWalletLoaded(WalletContext& context, const std::shared_ptr<CWallet>& wallet)\n\n\n###\n\n", "completion": "refactor: Rename ambiguous interfaces::MakeHandler functions"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -672,7 +672,7 @@ endif\n #\n \n # util #\n-libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n+libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_util_a_SOURCES = \\\n   support/lockedpool.cpp \\\n\n\n###\n\n", "completion": "build: remove BOOST_CPPFLAGS from libbitcoin_util"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -633,6 +633,7 @@ libbitcoin_common_a_SOURCES = \\\n   chainparams.cpp \\\n   coins.cpp \\\n   common/bloom.cpp \\\n+  common/interfaces.cpp \\\n   common/run_command.cpp \\\n   compressor.cpp \\\n   core_read.cpp \\\n@@ -678,9 +679,6 @@ libbitcoin_util_a_SOURCES = \\\n   chainparamsbase.cpp \\\n   clientversion.cpp \\\n   fs.cpp \\\n-  interfaces/echo.cpp \\\n-  interfaces/handler.cpp \\\n-  interfaces/init.cpp \\\n   logging.cpp \\\n   random.cpp \\\n   randomenv.cpp \\\n\n---\n file path A: src/interfaces/handler.cpp | file path B: src/common/interfaces.cpp\n\n@@ -1,17 +1,26 @@\n-// Copyright (c) 2018-2021 The Bitcoin Core developers\n+// Copyright (c) 2021 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <interfaces/echo.h>\n #include <interfaces/handler.h>\n \n-\n #include <boost/signals2/connection.hpp>\n+#include <memory>\n #include <utility>\n \n-namespace interfaces {\n+namespace common {\n namespace {\n+class CleanupHandler : public interfaces::Handler\n+{\n+public:\n+    explicit CleanupHandler(std::function<void()> cleanup) : m_cleanup(std::move(cleanup)) {}\n+    ~CleanupHandler() override { if (!m_cleanup) return; m_cleanup(); m_cleanup = nullptr; }\n+    void disconnect() override { if (!m_cleanup) return; m_cleanup(); m_cleanup = nullptr; }\n+    std::function<void()> m_cleanup;\n+};\n \n-class HandlerImpl : public Handler\n+class HandlerImpl : public interfaces::Handler\n {\n public:\n     explicit HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) {}\n@@ -21,25 +30,24 @@ public:\n     boost::signals2::scoped_connection m_connection;\n };\n \n-class CleanupHandler : public Handler\n+class EchoImpl : public interfaces::Echo\n {\n public:\n-    explicit CleanupHandler(std::function<void()> cleanup) : m_cleanup(std::move(cleanup)) {}\n-    ~CleanupHandler() override { if (!m_cleanup) return; m_cleanup(); m_cleanup = nullptr; }\n-    void disconnect() override { if (!m_cleanup) return; m_cleanup(); m_cleanup = nullptr; }\n-    std::function<void()> m_cleanup;\n+    std::string echo(const std::string& echo) override { return echo; }\n };\n-\n } // namespace\n+} // namespace common\n \n-std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection)\n+namespace interfaces {\n+std::unique_ptr<Handler> MakeHandler(std::function<void()> cleanup)\n {\n-    return std::make_unique<HandlerImpl>(std::move(connection));\n+    return std::make_unique<common::CleanupHandler>(std::move(cleanup));\n }\n \n-std::unique_ptr<Handler> MakeHandler(std::function<void()> cleanup)\n+std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection)\n {\n-    return std::make_unique<CleanupHandler>(std::move(cleanup));\n+    return std::make_unique<common::HandlerImpl>(std::move(connection));\n }\n \n+std::unique_ptr<Echo> MakeEcho() { return std::make_unique<common::EchoImpl>(); }\n } // namespace interfaces\n\n---\n file path A: src/interfaces/echo.cpp | file path B: None\n\n@@ -1,18 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <interfaces/echo.h>\n-\n-#include <memory>\n-\n-namespace interfaces {\n-namespace {\n-class EchoImpl : public Echo\n-{\n-public:\n-    std::string echo(const std::string& echo) override { return echo; }\n-};\n-} // namespace\n-std::unique_ptr<Echo> MakeEcho() { return std::make_unique<EchoImpl>(); }\n-} // namespace interfaces\n\n---\n file path A: src/interfaces/init.cpp | file path B: None\n\n@@ -1,17 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <interfaces/chain.h>\n-#include <interfaces/echo.h>\n-#include <interfaces/init.h>\n-#include <interfaces/node.h>\n-#include <interfaces/wallet.h>\n-\n-namespace interfaces {\n-std::unique_ptr<Node> Init::makeNode() { return {}; }\n-std::unique_ptr<Chain> Init::makeChain() { return {}; }\n-std::unique_ptr<WalletLoader> Init::makeWalletLoader(Chain& chain) { return {}; }\n-std::unique_ptr<Echo> Init::makeEcho() { return {}; }\n-Ipc* Init::ipc() { return nullptr; }\n-} // namespace interfaces\n\n---\n file path A: src/interfaces/init.h | file path B: src/interfaces/init.h\n\n@@ -5,6 +5,11 @@\n #ifndef BITCOIN_INTERFACES_INIT_H\n #define BITCOIN_INTERFACES_INIT_H\n \n+#include <interfaces/chain.h>\n+#include <interfaces/echo.h>\n+#include <interfaces/node.h>\n+#include <interfaces/wallet.h>\n+\n #include <memory>\n \n namespace node {\n@@ -12,11 +17,7 @@ struct NodeContext;\n } // namespace node\n \n namespace interfaces {\n-class Chain;\n-class Echo;\n class Ipc;\n-class Node;\n-class WalletLoader;\n \n //! Initial interface created when a process is first started, and used to give\n //! and get access to other interfaces (Node, Chain, Wallet, etc).\n@@ -29,11 +30,11 @@ class Init\n {\n public:\n     virtual ~Init() = default;\n-    virtual std::unique_ptr<Node> makeNode();\n-    virtual std::unique_ptr<Chain> makeChain();\n-    virtual std::unique_ptr<WalletLoader> makeWalletLoader(Chain& chain);\n-    virtual std::unique_ptr<Echo> makeEcho();\n-    virtual Ipc* ipc();\n+    virtual std::unique_ptr<Node> makeNode() { return nullptr; }\n+    virtual std::unique_ptr<Chain> makeChain() { return nullptr; }\n+    virtual std::unique_ptr<WalletLoader> makeWalletLoader(Chain& chain) { return nullptr; }\n+    virtual std::unique_ptr<Echo> makeEcho() { return nullptr; }\n+    virtual Ipc* ipc() { return nullptr; }\n };\n \n //! Return implementation of Init interface for the node process. If the argv\n\n\n###\n\n", "completion": "refactor: Move src/interfaces/*.cpp files to libbitcoin_common.a"}
{"prompt": " file path A: ci/test/00_setup_env_native_asan.sh | file path B: ci/test/00_setup_env_native_asan.sh\n\n@@ -6,14 +6,21 @@\n \n export LC_ALL=C.UTF-8\n \n-# We install an up-to-date 'bpfcc-tools' package from an untrusted PPA.\n-# This can be dropped with the next Ubuntu or Debian release that includes up-to-date packages.\n-# See the if-then in ci/test/04_install.sh too.\n-export ADD_UNTRUSTED_BPFCC_PPA=true\n+# Only install BCC tracing packages in Cirrus CI.\n+if [[ \"${CIRRUS_CI}\" == \"true\" ]]; then\n+  # We install an up-to-date 'bpfcc-tools' package from an untrusted PPA.\n+  # This can be dropped with the next Ubuntu or Debian release that includes up-to-date packages.\n+  # See the if-then in ci/test/04_install.sh too.\n+  export ADD_UNTRUSTED_BPFCC_PPA=true\n+  export BPFCC_PACKAGE=\"bpfcc-tools\"\n+else\n+  export ADD_UNTRUSTED_BPFCC_PPA=false\n+  export BPFCC_PACKAGE=\"\"\n+fi\n \n export CONTAINER_NAME=ci_native_asan\n-export PACKAGES=\"systemtap-sdt-dev bpfcc-tools clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libevent-dev bsdmainutils libboost-dev libdb5.3++-dev libminiupnpc-dev libnatpmp-dev libzmq3-dev libqrencode-dev libsqlite3-dev\"\n-export DOCKER_NAME_TAG=ubuntu:22.04  # May not run in docker unless --enable-usdt is dropped\n+export PACKAGES=\"systemtap-sdt-dev clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libevent-dev bsdmainutils libboost-dev libdb5.3++-dev libminiupnpc-dev libnatpmp-dev libzmq3-dev libqrencode-dev libsqlite3-dev ${BPFCC_PACKAGE}\"\n+export DOCKER_NAME_TAG=ubuntu:22.04\n export NO_DEPENDS=1\n export GOAL=\"install\"\n export BITCOIN_CONFIG=\"--enable-usdt --enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=address,integer,undefined CC=clang CXX=clang++\"\n\n\n###\n\n", "completion": "ci: only run USDT interface tests on CirrusCI"}
{"prompt": " file path A: contrib/bitcoin-cli.bash-completion | file path B: contrib/completions/bash/bitcoin-cli.bash-completion\n\n\n---\n file path A: contrib/bitcoin-tx.bash-completion | file path B: contrib/completions/bash/bitcoin-tx.bash-completion\n\n\n---\n file path A: contrib/bitcoind.bash-completion | file path B: contrib/completions/bash/bitcoind.bash-completion\n\n\n\n###\n\n", "completion": "refactor: Sub-folder bash completions"}
{"prompt": " file path A: ci/test/04_install.sh | file path B: ci/test/04_install.sh\n\n@@ -130,8 +130,8 @@ fi\n CI_EXEC mkdir -p \"${BASE_SCRATCH_DIR}/sanitizer-output/\"\n \n if [[ ${USE_MEMORY_SANITIZER} == \"true\" ]]; then\n-  CI_EXEC \"update-alternatives --install /usr/bin/clang++ clang++ \\$(which clang++-12) 100\"\n-  CI_EXEC \"update-alternatives --install /usr/bin/clang clang \\$(which clang-12) 100\"\n+  CI_EXEC_ROOT \"update-alternatives --install /usr/bin/clang++ clang++ \\$(which clang++-12) 100\"\n+  CI_EXEC_ROOT \"update-alternatives --install /usr/bin/clang clang \\$(which clang-12) 100\"\n   CI_EXEC \"mkdir -p ${BASE_SCRATCH_DIR}/msan/build/\"\n   CI_EXEC \"git clone --depth=1 https://github.com/llvm/llvm-project -b llvmorg-12.0.0 ${BASE_SCRATCH_DIR}/msan/llvm-project\"\n   CI_EXEC \"cd ${BASE_SCRATCH_DIR}/msan/build/ && cmake -DLLVM_ENABLE_PROJECTS='libcxx;libcxxabi' -DCMAKE_BUILD_TYPE=Release -DLLVM_USE_SANITIZER=MemoryWithOrigins -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_TARGETS_TO_BUILD=X86 ../llvm-project/llvm/\"\n\n\n###\n\n", "completion": "ci: use ci_exec_root for clang install"}
{"prompt": " file path A: test/functional/rpc_net.py | file path B: test/functional/rpc_net.py\n\n@@ -112,7 +112,7 @@ class NetTest(BitcoinTestFramework):\n         no_version_peer_conntime = int(time.time())\n         self.nodes[0].setmocktime(no_version_peer_conntime)\n         with self.nodes[0].assert_debug_log([f\"Added connection peer={no_version_peer_id}\"]):\n-            self.nodes[0].add_p2p_connection(P2PInterface(), send_version=False, wait_for_verack=False)\n+            no_version_peer = self.nodes[0].add_p2p_connection(P2PInterface(), send_version=False, wait_for_verack=False)\n         self.nodes[0].setmocktime(0)\n         peer_info = self.nodes[0].getpeerinfo()[no_version_peer_id]\n         peer_info.pop(\"addr\")\n@@ -153,7 +153,8 @@ class NetTest(BitcoinTestFramework):\n                 \"version\": 0,\n             },\n         )\n-        self.nodes[0].disconnect_p2ps()\n+        no_version_peer.peer_disconnect()\n+        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 2)\n \n     def test_getnettotals(self):\n         self.log.info(\"Test getnettotals\")\n\n---\n file path A: test/functional/test_framework/test_node.py | file path B: test/functional/test_framework/test_node.py\n\n@@ -656,7 +656,8 @@ class TestNode():\n         return len([peer for peer in self.getpeerinfo() if peer['subver'] == P2P_SUBVERSION])\n \n     def disconnect_p2ps(self):\n-        \"\"\"Close all p2p connections to the node.\"\"\"\n+        \"\"\"Close all p2p connections to the node.\n+        Use only after each p2p has sent a version message to ensure the wait works.\"\"\"\n         for p in self.p2ps:\n             p.peer_disconnect()\n         del self.p2ps[:]\n\n\n###\n\n", "completion": "test: Fix intermittent failure in rpc_net.py"}
{"prompt": " file path A: src/wallet/test/walletload_tests.cpp | file path B: src/wallet/test/walletload_tests.cpp\n\n@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or https://www.opensource.org/licenses/mit-license.php.\n \n+#include <wallet/test/util.h>\n #include <wallet/wallet.h>\n #include <test/util/setup_common.h>\n \n@@ -50,5 +51,139 @@ BOOST_FIXTURE_TEST_CASE(wallet_load_unknown_descriptor, TestingSetup)\n     }\n }\n \n+bool HasAnyRecordOfType(WalletDatabase& db, const std::string& key)\n+{\n+    std::unique_ptr<DatabaseBatch> batch = db.MakeBatch(false);\n+    BOOST_CHECK(batch->StartCursor());\n+    while (true) {\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+        bool complete;\n+        BOOST_CHECK(batch->ReadAtCursor(ssKey, ssValue, complete));\n+        if (complete) break;\n+        std::string type;\n+        ssKey >> type;\n+        if (type == key) return true;\n+    }\n+    return false;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(wallet_load_verif_crypted_key_checksum, TestingSetup)\n+{\n+    // The test duplicates the db so each case has its own db instance.\n+    int NUMBER_OF_TESTS = 4;\n+    std::vector<std::unique_ptr<WalletDatabase>> dbs;\n+    CKey first_key;\n+    auto get_db = [](std::vector<std::unique_ptr<WalletDatabase>>& dbs) {\n+        std::unique_ptr<WalletDatabase> db = std::move(dbs.back());\n+        dbs.pop_back();\n+        return db;\n+    };\n+\n+    {   // Context setup.\n+        // Create and encrypt legacy wallet\n+        std::shared_ptr<CWallet> wallet(new CWallet(m_node.chain.get(), \"\", m_args, CreateMockWalletDatabase()));\n+        LOCK(wallet->cs_wallet);\n+        auto legacy_spkm = wallet->GetOrCreateLegacyScriptPubKeyMan();\n+        BOOST_CHECK(legacy_spkm->SetupGeneration(true));\n+\n+        // Get the first key in the wallet\n+        CTxDestination dest = *Assert(legacy_spkm->GetNewDestination(OutputType::LEGACY));\n+        CKeyID key_id = GetKeyForDestination(*legacy_spkm, dest);\n+        BOOST_CHECK(legacy_spkm->GetKey(key_id, first_key));\n+\n+        // Encrypt the wallet and duplicate database\n+        BOOST_CHECK(wallet->EncryptWallet(\"encrypt\"));\n+        wallet->Flush();\n+\n+        DatabaseOptions options;\n+        for (int i=0; i < NUMBER_OF_TESTS; i++) {\n+            dbs.emplace_back(DuplicateMockDatabase(wallet->GetDatabase(), options));\n+        }\n+    }\n+\n+    {\n+        // First test case:\n+        // Erase all the crypted keys from db and unlock the wallet.\n+        // The wallet will only re-write the crypted keys to db if any checksum is missing at load time.\n+        // So, if any 'ckey' record re-appears on db, then the checksums were not properly calculated, and we are re-writing\n+        // the records every time that 'CWallet::Unlock' gets called, which is not good.\n+\n+        // Load the wallet and check that is encrypted\n+        std::shared_ptr<CWallet> wallet(new CWallet(m_node.chain.get(), \"\", m_args, get_db(dbs)));\n+        BOOST_CHECK_EQUAL(wallet->LoadWallet(), DBErrors::LOAD_OK);\n+        BOOST_CHECK(wallet->IsCrypted());\n+        BOOST_CHECK(HasAnyRecordOfType(wallet->GetDatabase(), DBKeys::CRYPTED_KEY));\n+\n+        // Now delete all records and check that the 'Unlock' function doesn't re-write them\n+        BOOST_CHECK(wallet->GetLegacyScriptPubKeyMan()->DeleteRecords());\n+        BOOST_CHECK(!HasAnyRecordOfType(wallet->GetDatabase(), DBKeys::CRYPTED_KEY));\n+        BOOST_CHECK(wallet->Unlock(\"encrypt\"));\n+        BOOST_CHECK(!HasAnyRecordOfType(wallet->GetDatabase(), DBKeys::CRYPTED_KEY));\n+    }\n+\n+    {\n+        // Second test case:\n+        // Verify that loading up a 'ckey' with no checksum triggers a complete re-write of the crypted keys.\n+        std::unique_ptr<WalletDatabase> db = get_db(dbs);\n+        {\n+            std::unique_ptr<DatabaseBatch> batch = db->MakeBatch(false);\n+            std::pair<std::vector<unsigned char>, uint256> value;\n+            BOOST_CHECK(batch->Read(std::make_pair(DBKeys::CRYPTED_KEY, first_key.GetPubKey()), value));\n+\n+            const auto key = std::make_pair(DBKeys::CRYPTED_KEY, first_key.GetPubKey());\n+            BOOST_CHECK(batch->Write(key, value.first, /*fOverwrite=*/true));\n+        }\n+\n+        // Load the wallet and check that is encrypted\n+        std::shared_ptr<CWallet> wallet(new CWallet(m_node.chain.get(), \"\", m_args, std::move(db)));\n+        BOOST_CHECK_EQUAL(wallet->LoadWallet(), DBErrors::LOAD_OK);\n+        BOOST_CHECK(wallet->IsCrypted());\n+        BOOST_CHECK(HasAnyRecordOfType(wallet->GetDatabase(), DBKeys::CRYPTED_KEY));\n+\n+        // Now delete all ckey records and check that the 'Unlock' function re-writes them\n+        // (this is because the wallet, at load time, found a ckey record with no checksum)\n+        BOOST_CHECK(wallet->GetLegacyScriptPubKeyMan()->DeleteRecords());\n+        BOOST_CHECK(!HasAnyRecordOfType(wallet->GetDatabase(), DBKeys::CRYPTED_KEY));\n+        BOOST_CHECK(wallet->Unlock(\"encrypt\"));\n+        BOOST_CHECK(HasAnyRecordOfType(wallet->GetDatabase(), DBKeys::CRYPTED_KEY));\n+    }\n+\n+    {\n+        // Third test case:\n+        // Verify that loading up a 'ckey' with an invalid checksum throws an error.\n+        std::unique_ptr<WalletDatabase> db = get_db(dbs);\n+        {\n+            std::unique_ptr<DatabaseBatch> batch = db->MakeBatch(false);\n+            std::vector<unsigned char> crypted_data;\n+            BOOST_CHECK(batch->Read(std::make_pair(DBKeys::CRYPTED_KEY, first_key.GetPubKey()), crypted_data));\n+\n+            // Write an invalid checksum\n+            std::pair<std::vector<unsigned char>, uint256> value = std::make_pair(crypted_data, uint256::ONE);\n+            const auto key = std::make_pair(DBKeys::CRYPTED_KEY, first_key.GetPubKey());\n+            BOOST_CHECK(batch->Write(key, value, /*fOverwrite=*/true));\n+        }\n+\n+        std::shared_ptr<CWallet> wallet(new CWallet(m_node.chain.get(), \"\", m_args, std::move(db)));\n+        BOOST_CHECK_EQUAL(wallet->LoadWallet(), DBErrors::CORRUPT);\n+    }\n+\n+    {\n+        // Fourth test case:\n+        // Verify that loading up a 'ckey' with an invalid pubkey throws an error\n+        std::unique_ptr<WalletDatabase> db = get_db(dbs);\n+        {\n+            CPubKey invalid_key;\n+            BOOST_ASSERT(!invalid_key.IsValid());\n+            const auto key = std::make_pair(DBKeys::CRYPTED_KEY, invalid_key);\n+            std::pair<std::vector<unsigned char>, uint256> value;\n+            BOOST_CHECK(db->MakeBatch(false)->Write(key, value, /*fOverwrite=*/true));\n+        }\n+\n+        std::shared_ptr<CWallet> wallet(new CWallet(m_node.chain.get(), \"\", m_args, std::move(db)));\n+        BOOST_CHECK_EQUAL(wallet->LoadWallet(), DBErrors::CORRUPT);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()\n } // namespace wallet\n\n\n###\n\n", "completion": "test: load wallet, coverage for crypted keys"}
{"prompt": " file path A: src/bench/wallet_loading.cpp | file path B: src/bench/wallet_loading.cpp\n\n@@ -52,30 +52,6 @@ static void AddTx(CWallet& wallet)\n     wallet.AddToWallet(MakeTransactionRef(mtx), TxStateInactive{});\n }\n \n-static std::unique_ptr<WalletDatabase> DuplicateMockDatabase(WalletDatabase& database, DatabaseOptions& options)\n-{\n-    auto new_database = CreateMockWalletDatabase(options);\n-\n-    // Get a cursor to the original database\n-    auto batch = database.MakeBatch();\n-    batch->StartCursor();\n-\n-    // Get a batch for the new database\n-    auto new_batch = new_database->MakeBatch();\n-\n-    // Read all records from the original database and write them to the new one\n-    while (true) {\n-        CDataStream key(SER_DISK, CLIENT_VERSION);\n-        CDataStream value(SER_DISK, CLIENT_VERSION);\n-        bool complete;\n-        batch->ReadAtCursor(key, value, complete);\n-        if (complete) break;\n-        new_batch->Write(key, value);\n-    }\n-\n-    return new_database;\n-}\n-\n static void WalletLoading(benchmark::Bench& bench, bool legacy_wallet)\n {\n     const auto test_setup = MakeNoLogFileContext<TestingSetup>();\n\n---\n file path A: src/wallet/test/util.cpp | file path B: src/wallet/test/util.cpp\n\n@@ -44,6 +44,30 @@ std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cc\n     return wallet;\n }\n \n+std::unique_ptr<WalletDatabase> DuplicateMockDatabase(WalletDatabase& database, DatabaseOptions& options)\n+{\n+    auto new_database = CreateMockWalletDatabase(options);\n+\n+    // Get a cursor to the original database\n+    auto batch = database.MakeBatch();\n+    batch->StartCursor();\n+\n+    // Get a batch for the new database\n+    auto new_batch = new_database->MakeBatch();\n+\n+    // Read all records from the original database and write them to the new one\n+    while (true) {\n+        CDataStream key(SER_DISK, CLIENT_VERSION);\n+        CDataStream value(SER_DISK, CLIENT_VERSION);\n+        bool complete;\n+        batch->ReadAtCursor(key, value, complete);\n+        if (complete) break;\n+        new_batch->Write(key, value);\n+    }\n+\n+    return new_database;\n+}\n+\n std::string getnewaddress(CWallet& w)\n {\n     constexpr auto output_type = OutputType::BECH32;\n\n---\n file path A: src/wallet/test/util.h | file path B: src/wallet/test/util.h\n\n@@ -18,9 +18,14 @@ class Chain;\n \n namespace wallet {\n class CWallet;\n+struct DatabaseOptions;\n+class WalletDatabase;\n \n std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cchain, ArgsManager& args, const CKey& key);\n \n+// Creates a copy of the provided database\n+std::unique_ptr<WalletDatabase> DuplicateMockDatabase(WalletDatabase& database, DatabaseOptions& options);\n+\n /** Returns a new encoded destination from the wallet (hardcoded to BECH32) */\n std::string getnewaddress(CWallet& w);\n /** Returns a new destination, of an specific type, from the wallet */\n\n\n###\n\n", "completion": "refactor: move DuplicateMockDatabase to wallet/test/util.h"}
{"prompt": " file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -199,8 +199,6 @@ FUZZ_WALLET_SRC += \\\n endif # USE_SQLITE\n \n BITCOIN_TEST_SUITE += \\\n-  wallet/test/util.cpp \\\n-  wallet/test/util.h \\\n   wallet/test/wallet_test_fixture.cpp \\\n   wallet/test/wallet_test_fixture.h \\\n   wallet/test/init_test_fixture.cpp \\\n\n---\n file path A: src/Makefile.test_util.include | file path B: src/Makefile.test_util.include\n\n@@ -18,8 +18,11 @@ TEST_UTIL_H = \\\n   test/util/str.h \\\n   test/util/transaction_utils.h \\\n   test/util/txmempool.h \\\n-  test/util/validation.h \\\n-  test/util/wallet.h\n+  test/util/validation.h\n+\n+if ENABLE_WALLET\n+TEST_UTIL_H += wallet/test/util.h\n+endif # ENABLE_WALLET\n \n libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libtest_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -33,6 +36,10 @@ libtest_util_a_SOURCES = \\\n   test/util/str.cpp \\\n   test/util/transaction_utils.cpp \\\n   test/util/txmempool.cpp \\\n-  test/util/validation.cpp \\\n-  test/util/wallet.cpp \\\n-  $(TEST_UTIL_H)\n+  test/util/validation.cpp\n+\n+if ENABLE_WALLET\n+libtest_util_a_SOURCES += wallet/test/util.cpp\n+endif # ENABLE_WALLET\n+\n+libtest_util_a_SOURCES += $(TEST_UTIL_H)\n\n---\n file path A: src/bench/block_assemble.cpp | file path B: src/bench/block_assemble.cpp\n\n@@ -8,7 +8,6 @@\n #include <test/util/mining.h>\n #include <test/util/script.h>\n #include <test/util/setup_common.h>\n-#include <test/util/wallet.h>\n #include <txmempool.h>\n #include <validation.h>\n \n\n---\n file path A: src/bench/wallet_balance.cpp | file path B: src/bench/wallet_balance.cpp\n\n@@ -7,7 +7,7 @@\n #include <node/context.h>\n #include <test/util/mining.h>\n #include <test/util/setup_common.h>\n-#include <test/util/wallet.h>\n+#include <wallet/test/util.h>\n #include <validationinterface.h>\n #include <wallet/receive.h>\n #include <wallet/wallet.h>\n@@ -20,6 +20,8 @@ using wallet::DBErrors;\n using wallet::GetBalance;\n using wallet::WALLET_FLAG_DESCRIPTORS;\n \n+const std::string ADDRESS_BCRT1_UNSPENDABLE = \"bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj\";\n+\n static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const bool add_mine)\n {\n     const auto test_setup = MakeNoLogFileContext<const TestingSetup>();\n\n---\n file path A: src/bench/wallet_create_tx.cpp | file path B: src/bench/wallet_create_tx.cpp\n\n@@ -9,9 +9,9 @@\n #include <kernel/chain.h>\n #include <node/context.h>\n #include <test/util/setup_common.h>\n-#include <test/util/wallet.h>\n #include <validation.h>\n #include <wallet/spend.h>\n+#include <wallet/test/util.h>\n #include <wallet/wallet.h>\n \n using wallet::CWallet;\n\n---\n file path A: src/bench/wallet_loading.cpp | file path B: src/bench/wallet_loading.cpp\n\n@@ -7,7 +7,7 @@\n #include <node/context.h>\n #include <test/util/mining.h>\n #include <test/util/setup_common.h>\n-#include <test/util/wallet.h>\n+#include <wallet/test/util.h>\n #include <util/translation.h>\n #include <validationinterface.h>\n #include <wallet/context.h>\n\n---\n file path A: src/test/util/wallet.cpp | file path B: None\n\n@@ -1,32 +0,0 @@\n-// Copyright (c) 2019-2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <test/util/wallet.h>\n-\n-#include <key_io.h>\n-#include <outputtype.h>\n-#include <script/standard.h>\n-#ifdef ENABLE_WALLET\n-#include <util/check.h>\n-#include <util/translation.h>\n-#include <wallet/wallet.h>\n-#endif\n-\n-using wallet::CWallet;\n-\n-const std::string ADDRESS_BCRT1_UNSPENDABLE = \"bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj\";\n-\n-#ifdef ENABLE_WALLET\n-std::string getnewaddress(CWallet& w)\n-{\n-    constexpr auto output_type = OutputType::BECH32;\n-    return EncodeDestination(getNewDestination(w, output_type));\n-}\n-\n-CTxDestination getNewDestination(CWallet& w, OutputType output_type)\n-{\n-    return *Assert(w.GetNewDestination(output_type, \"\"));\n-}\n-\n-#endif // ENABLE_WALLET\n\n---\n file path A: src/test/util/wallet.h | file path B: None\n\n@@ -1,29 +0,0 @@\n-// Copyright (c) 2019 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_TEST_UTIL_WALLET_H\n-#define BITCOIN_TEST_UTIL_WALLET_H\n-\n-#include <outputtype.h>\n-#include <string>\n-\n-namespace wallet {\n-class CWallet;\n-} // namespace wallet\n-\n-// Constants //\n-\n-extern const std::string ADDRESS_BCRT1_UNSPENDABLE;\n-\n-// RPC-like //\n-\n-/** Import the address to the wallet */\n-void importaddress(wallet::CWallet& wallet, const std::string& address);\n-/** Returns a new encoded destination from the wallet (hardcoded to BECH32) */\n-std::string getnewaddress(wallet::CWallet& w);\n-/** Returns a new destination, of an specific type, from the wallet */\n-CTxDestination getNewDestination(wallet::CWallet& w, OutputType output_type);\n-\n-\n-#endif // BITCOIN_TEST_UTIL_WALLET_H\n\n---\n file path A: src/wallet/test/util.cpp | file path B: src/wallet/test/util.cpp\n\n@@ -11,8 +11,6 @@\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n \n-#include <boost/test/unit_test.hpp>\n-\n #include <memory>\n \n namespace wallet {\n@@ -39,10 +37,22 @@ std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cc\n     WalletRescanReserver reserver(*wallet);\n     reserver.reserve();\n     CWallet::ScanResult result = wallet->ScanForWalletTransactions(cchain.Genesis()->GetBlockHash(), /*start_height=*/0, /*max_height=*/{}, reserver, /*fUpdate=*/false, /*save_progress=*/false);\n-    BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n-    BOOST_CHECK_EQUAL(result.last_scanned_block, cchain.Tip()->GetBlockHash());\n-    BOOST_CHECK_EQUAL(*result.last_scanned_height, cchain.Height());\n-    BOOST_CHECK(result.last_failed_block.IsNull());\n+    assert(result.status == CWallet::ScanResult::SUCCESS);\n+    assert(result.last_scanned_block == cchain.Tip()->GetBlockHash());\n+    assert(*result.last_scanned_height == cchain.Height());\n+    assert(result.last_failed_block.IsNull());\n     return wallet;\n }\n+\n+std::string getnewaddress(CWallet& w)\n+{\n+    constexpr auto output_type = OutputType::BECH32;\n+    return EncodeDestination(getNewDestination(w, output_type));\n+}\n+\n+CTxDestination getNewDestination(CWallet& w, OutputType output_type)\n+{\n+    return *Assert(w.GetNewDestination(output_type, \"\"));\n+}\n+\n } // namespace wallet\n\n---\n file path A: src/wallet/test/util.h | file path B: src/wallet/test/util.h\n\n@@ -5,11 +5,13 @@\n #ifndef BITCOIN_WALLET_TEST_UTIL_H\n #define BITCOIN_WALLET_TEST_UTIL_H\n \n+#include <script/standard.h>\n #include <memory>\n \n class ArgsManager;\n class CChain;\n class CKey;\n+enum class OutputType;\n namespace interfaces {\n class Chain;\n } // namespace interfaces\n@@ -18,6 +20,12 @@ namespace wallet {\n class CWallet;\n \n std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cchain, ArgsManager& args, const CKey& key);\n+\n+/** Returns a new encoded destination from the wallet (hardcoded to BECH32) */\n+std::string getnewaddress(CWallet& w);\n+/** Returns a new destination, of an specific type, from the wallet */\n+CTxDestination getNewDestination(CWallet& w, OutputType output_type);\n+\n } // namespace wallet\n \n #endif // BITCOIN_WALLET_TEST_UTIL_H\n\n\n###\n\n", "completion": "refactor: unify test/util/wallet.h with wallet/test/util.h"}
{"prompt": " file path A: ci/test/04_install.sh | file path B: ci/test/04_install.sh\n\n@@ -27,6 +27,11 @@ export P_CI_DIR=\"$PWD\"\n \n if [ -z \"$DANGER_RUN_CI_ON_HOST\" ]; then\n   echo \"Creating $DOCKER_NAME_TAG container to run in\"\n+  LOCAL_UID=$(id -u)\n+  LOCAL_GID=$(id -g)\n+\n+  # the name isn't important, so long as we use the same UID\n+  LOCAL_USER=nonroot\n   ${CI_RETRY_EXE} docker pull \"$DOCKER_NAME_TAG\"\n \n   if [ -n \"${RESTART_CI_DOCKER_BEFORE_RUN}\" ] ; then\n@@ -44,7 +49,16 @@ if [ -z \"$DANGER_RUN_CI_ON_HOST\" ]; then\n                   --env-file /tmp/env \\\n                   --name $CONTAINER_NAME \\\n                   $DOCKER_NAME_TAG)\n-  export DOCKER_CI_CMD_PREFIX=\"docker exec $DOCKER_ID\"\n+\n+  # Create a non-root user inside the container which matches the local user.\n+  #\n+  # This prevents the root user in the container modifying the local file system permissions\n+  # on the mounted directories\n+  docker exec \"$DOCKER_ID\" useradd -u \"$LOCAL_UID\" -o -m \"$LOCAL_USER\"\n+  docker exec \"$DOCKER_ID\" groupmod -o -g \"$LOCAL_GID\" \"$LOCAL_USER\"\n+  docker exec \"$DOCKER_ID\" chown -R \"$LOCAL_USER\":\"$LOCAL_USER\" \"${BASE_ROOT_DIR}\"\n+  export DOCKER_CI_CMD_PREFIX_ROOT=\"docker exec -u 0 $DOCKER_ID\"\n+  export DOCKER_CI_CMD_PREFIX=\"docker exec -u $LOCAL_UID $DOCKER_ID\"\n else\n   echo \"Running on host system without docker wrapper\"\n fi\n@@ -52,15 +66,19 @@ fi\n CI_EXEC () {\n   $DOCKER_CI_CMD_PREFIX bash -c \"export PATH=$BASE_SCRATCH_DIR/bins/:\\$PATH && cd \\\"$P_CI_DIR\\\" && $*\"\n }\n+CI_EXEC_ROOT () {\n+  $DOCKER_CI_CMD_PREFIX_ROOT bash -c \"export PATH=$BASE_SCRATCH_DIR/bins/:\\$PATH && cd \\\"$P_CI_DIR\\\" && $*\"\n+}\n export -f CI_EXEC\n+export -f CI_EXEC_ROOT\n \n if [ -n \"$DPKG_ADD_ARCH\" ]; then\n-  CI_EXEC dpkg --add-architecture \"$DPKG_ADD_ARCH\"\n+  CI_EXEC_ROOT dpkg --add-architecture \"$DPKG_ADD_ARCH\"\n fi\n \n if [[ $DOCKER_NAME_TAG == *centos* ]]; then\n-  ${CI_RETRY_EXE} CI_EXEC dnf -y install epel-release\n-  ${CI_RETRY_EXE} CI_EXEC dnf -y --allowerasing install \"$DOCKER_PACKAGES\" \"$PACKAGES\"\n+  ${CI_RETRY_EXE} CI_EXEC_ROOT dnf -y install epel-release\n+  ${CI_RETRY_EXE} CI_EXEC_ROOT dnf -y --allowerasing install \"$DOCKER_PACKAGES\" \"$PACKAGES\"\n elif [ \"$CI_USE_APT_INSTALL\" != \"no\" ]; then\n   if [[ \"${ADD_UNTRUSTED_BPFCC_PPA}\" == \"true\" ]]; then\n     # Ubuntu 22.04 LTS and Debian 11 both have an outdated bpfcc-tools packages.\n@@ -68,10 +86,10 @@ elif [ \"$CI_USE_APT_INSTALL\" != \"no\" ]; then\n     # packages. Meanwhile, use an untrusted PPA to install an up-to-date version of the bpfcc-tools\n     # package.\n     # TODO: drop this once we can use newer images in GCE\n-    CI_EXEC add-apt-repository ppa:hadret/bpfcc\n+    CI_EXEC_ROOT add-apt-repository ppa:hadret/bpfcc\n   fi\n-  ${CI_RETRY_EXE} CI_EXEC apt-get update\n-  ${CI_RETRY_EXE} CI_EXEC apt-get install --no-install-recommends --no-upgrade -y \"$PACKAGES\" \"$DOCKER_PACKAGES\"\n+  ${CI_RETRY_EXE} CI_EXEC_ROOT apt-get update\n+  ${CI_RETRY_EXE} CI_EXEC_ROOT apt-get install --no-install-recommends --no-upgrade -y \"$PACKAGES\" \"$DOCKER_PACKAGES\"\n fi\n \n if [ -n \"$PIP_PACKAGES\" ]; then\n@@ -126,7 +144,7 @@ if [[ \"${RUN_TIDY}\" == \"true\" ]]; then\n     CI_EXEC \"mkdir -p ${DIR_IWYU}/build/\"\n     CI_EXEC \"git clone --depth=1 https://github.com/include-what-you-use/include-what-you-use -b clang_14 ${DIR_IWYU}/include-what-you-use\"\n     CI_EXEC \"cd ${DIR_IWYU}/build && cmake -G 'Unix Makefiles' -DCMAKE_PREFIX_PATH=/usr/lib/llvm-14 ../include-what-you-use\"\n-    CI_EXEC \"cd ${DIR_IWYU}/build && make install $MAKEJOBS\"\n+    CI_EXEC_ROOT \"cd ${DIR_IWYU}/build && make install $MAKEJOBS\"\n   fi\n fi\n \n\n---\n file path A: ci/test/05_before_script.sh | file path B: ci/test/05_before_script.sh\n\n@@ -11,6 +11,7 @@ if [ \"$CI_OS_NAME\" == \"macos\" ]; then\n   echo > \"${HOME}/Library/Application Support/Bitcoin\"\n else\n   CI_EXEC echo \\> \\$HOME/.bitcoin\n+  CI_EXEC_ROOT echo \\> \\$HOME/.bitcoin\n fi\n \n CI_EXEC mkdir -p \"${DEPENDS_DIR}/SDKs\" \"${DEPENDS_DIR}/sdk-sources\"\n\n\n###\n\n", "completion": "ci: create and use non-root user for docker image"}
{"prompt": " file path A: test/functional/p2p_ping.py | file path B: test/functional/p2p_ping.py\n\n@@ -12,7 +12,9 @@ from test_framework.p2p import P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n+\n PING_INTERVAL = 2 * 60\n+TIMEOUT_INTERVAL = 20 * 60\n \n \n class msg_pong_corrupt(msg_pong):\n@@ -20,19 +22,11 @@ class msg_pong_corrupt(msg_pong):\n         return b\"\"\n \n \n-class NodePongAdd1(P2PInterface):\n-    def on_ping(self, message):\n-        self.send_message(msg_pong(message.nonce + 1))\n-\n-\n class NodeNoPong(P2PInterface):\n     def on_ping(self, message):\n         pass\n \n \n-TIMEOUT_INTERVAL = 20 * 60\n-\n-\n class PingPongTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n\n\n###\n\n", "completion": "test: remove unused class `NodePongAdd1`"}
{"prompt": " file path A: test/sanitizer_suppressions/ubsan | file path B: test/sanitizer_suppressions/ubsan\n\n@@ -53,7 +53,6 @@ unsigned-integer-overflow:policy/fees.cpp\n unsigned-integer-overflow:prevector.h\n unsigned-integer-overflow:script/interpreter.cpp\n unsigned-integer-overflow:txmempool.cpp\n-unsigned-integer-overflow:txmempool_entry.h\n implicit-integer-sign-change:compat/stdin.cpp\n implicit-integer-sign-change:compressor.h\n implicit-integer-sign-change:crypto/\n@@ -63,7 +62,6 @@ implicit-integer-sign-change:script/bitcoinconsensus.cpp\n implicit-integer-sign-change:script/interpreter.cpp\n implicit-integer-sign-change:serialize.h\n implicit-integer-sign-change:txmempool.cpp\n-implicit-integer-sign-change:txmempool_entry.h\n implicit-signed-integer-truncation:crypto/\n implicit-unsigned-integer-truncation:crypto/\n shift-base:arith_uint256.cpp\n\n\n###\n\n", "completion": "test: Remove unused sanitizer suppressions"}
{"prompt": " file path A: test/functional/rpc_net.py | file path B: test/functional/rpc_net.py\n\n@@ -107,6 +107,54 @@ class NetTest(BitcoinTestFramework):\n         # Check dynamically generated networks list in getpeerinfo help output.\n         assert \"(ipv4, ipv6, onion, i2p, cjdns, not_publicly_routable)\" in self.nodes[0].help(\"getpeerinfo\")\n \n+        self.log.info(\"Check getpeerinfo output before a version message was sent\")\n+        no_version_peer_id = 2\n+        no_version_peer_conntime = int(time.time())\n+        self.nodes[0].setmocktime(no_version_peer_conntime)\n+        with self.nodes[0].assert_debug_log([f\"Added connection peer={no_version_peer_id}\"]):\n+            self.nodes[0].add_p2p_connection(P2PInterface(), send_version=False, wait_for_verack=False)\n+        self.nodes[0].setmocktime(0)\n+        peer_info = self.nodes[0].getpeerinfo()[no_version_peer_id]\n+        peer_info.pop(\"addr\")\n+        peer_info.pop(\"addrbind\")\n+        assert_equal(\n+            peer_info,\n+            {\n+                \"addr_processed\": 0,\n+                \"addr_rate_limited\": 0,\n+                \"addr_relay_enabled\": False,\n+                \"bip152_hb_from\": False,\n+                \"bip152_hb_to\": False,\n+                \"bytesrecv\": 0,\n+                \"bytesrecv_per_msg\": {},\n+                \"bytessent\": 0,\n+                \"bytessent_per_msg\": {},\n+                \"connection_type\": \"inbound\",\n+                \"conntime\": no_version_peer_conntime,\n+                \"id\": no_version_peer_id,\n+                \"inbound\": True,\n+                \"inflight\": [],\n+                \"last_block\": 0,\n+                \"last_transaction\": 0,\n+                \"lastrecv\": 0,\n+                \"lastsend\": 0,\n+                \"minfeefilter\": Decimal(\"0E-8\"),\n+                \"network\": \"not_publicly_routable\",\n+                \"permissions\": [],\n+                \"presynced_headers\": -1,\n+                \"relaytxes\": False,\n+                \"services\": \"0000000000000000\",\n+                \"servicesnames\": [],\n+                \"startingheight\": -1,\n+                \"subver\": \"\",\n+                \"synced_blocks\": -1,\n+                \"synced_headers\": -1,\n+                \"timeoffset\": 0,\n+                \"version\": 0,\n+            },\n+        )\n+        self.nodes[0].disconnect_p2ps()\n+\n     def test_getnettotals(self):\n         self.log.info(\"Test getnettotals\")\n         # Test getnettotals and getpeerinfo by doing a ping. The bytes\n\n\n###\n\n", "completion": "test: Add getpeerinfo test for missing version message"}
{"prompt": " file path A: test/functional/feature_fee_estimation.py | file path B: test/functional/feature_fee_estimation.py\n\n@@ -62,7 +62,7 @@ def small_txpuzzle_randfee(\n     unconflist.append({\"txid\": txid, \"vout\": 0, \"value\": total_in - amount - fee})\n     unconflist.append({\"txid\": txid, \"vout\": 1, \"value\": amount})\n \n-    return (tx.serialize().hex(), fee)\n+    return (tx.get_vsize(), fee)\n \n \n def check_raw_estimates(node, fees_seen):\n@@ -158,7 +158,7 @@ class EstimateFeeTest(BitcoinTestFramework):\n             random.shuffle(self.confutxo)\n             for _ in range(random.randrange(100 - 50, 100 + 50)):\n                 from_index = random.randint(1, 2)\n-                (txhex, fee) = small_txpuzzle_randfee(\n+                (tx_bytes, fee) = small_txpuzzle_randfee(\n                     self.wallet,\n                     self.nodes[from_index],\n                     self.confutxo,\n@@ -167,7 +167,7 @@ class EstimateFeeTest(BitcoinTestFramework):\n                     min_fee,\n                     min_fee,\n                 )\n-                tx_kbytes = (len(txhex) // 2) / 1000.0\n+                tx_kbytes = tx_bytes / 1000.0\n                 self.fees_per_kb.append(float(fee) / tx_kbytes)\n             self.sync_mempools(wait=0.1)\n             mined = mining_node.getblock(self.generate(mining_node, 1)[0], True)[\"tx\"]\n\n\n###\n\n", "completion": "test: Changed small_txpuzzle_randfee to return the virtual size instead of the transaction hex for feerate calculation."}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -426,7 +426,6 @@ libbitcoin_node_a_SOURCES = \\\n   torcontrol.cpp \\\n   txdb.cpp \\\n   txmempool.cpp \\\n-  txmempool_entry.cpp \\\n   txorphanage.cpp \\\n   txrequest.cpp \\\n   validation.cpp \\\n@@ -932,7 +931,6 @@ libbitcoinkernel_la_SOURCES = \\\n   threadinterrupt.cpp \\\n   txdb.cpp \\\n   txmempool.cpp \\\n-  txmempool_entry.cpp \\\n   uint256.cpp \\\n   util/check.cpp \\\n   util/getuniquepath.cpp \\\n\n---\n file path A: src/txmempool_entry.cpp | file path B: None\n\n@@ -1,49 +0,0 @@\n-// Copyright (c) 2009-2022 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <txmempool_entry.h>\n-\n-#include <consensus/amount.h>\n-#include <consensus/validation.h>\n-#include <core_memusage.h>\n-#include <policy/policy.h>\n-#include <policy/settings.h>\n-#include <primitives/transaction.h>\n-#include <util/overflow.h>\n-\n-CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& tx, CAmount fee,\n-                                 int64_t time, unsigned int entry_height,\n-                                 bool spends_coinbase, int64_t sigops_cost, LockPoints lp)\n-    : tx{tx},\n-      nFee{fee},\n-      nTxWeight(GetTransactionWeight(*tx)),\n-      nUsageSize{RecursiveDynamicUsage(tx)},\n-      nTime{time},\n-      entryHeight{entry_height},\n-      spendsCoinbase{spends_coinbase},\n-      sigOpCost{sigops_cost},\n-      m_modified_fee{nFee},\n-      lockPoints{lp},\n-      nSizeWithDescendants{GetTxSize()},\n-      nModFeesWithDescendants{nFee},\n-      nSizeWithAncestors{GetTxSize()},\n-      nModFeesWithAncestors{nFee},\n-      nSigOpCostWithAncestors{sigOpCost} {}\n-\n-void CTxMemPoolEntry::UpdateModifiedFee(CAmount fee_diff)\n-{\n-    nModFeesWithDescendants = SaturatingAdd(nModFeesWithDescendants, fee_diff);\n-    nModFeesWithAncestors = SaturatingAdd(nModFeesWithAncestors, fee_diff);\n-    m_modified_fee = SaturatingAdd(m_modified_fee, fee_diff);\n-}\n-\n-void CTxMemPoolEntry::UpdateLockPoints(const LockPoints& lp)\n-{\n-    lockPoints = lp;\n-}\n-\n-size_t CTxMemPoolEntry::GetTxSize() const\n-{\n-    return GetVirtualTransactionSize(nTxWeight, sigOpCost, ::nBytesPerSigOp);\n-}\n\n---\n file path A: src/txmempool_entry.h | file path B: src/txmempool_entry.h\n\n@@ -6,8 +6,13 @@\n #define BITCOIN_TXMEMPOOL_ENTRY_H\n \n #include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <core_memusage.h>\n+#include <policy/policy.h>\n+#include <policy/settings.h>\n #include <primitives/transaction.h>\n #include <util/epochguard.h>\n+#include <util/overflow.h>\n \n #include <chrono>\n #include <functional>\n@@ -77,14 +82,14 @@ private:\n     const bool spendsCoinbase;      //!< keep track of transactions that spend a coinbase\n     const int64_t sigOpCost;        //!< Total sigop cost\n     CAmount m_modified_fee;         //!< Used for determining the priority of the transaction for mining in a block\n-    LockPoints lockPoints;     //!< Track the height and time at which tx was final\n+    LockPoints lockPoints;          //!< Track the height and time at which tx was final\n \n     // Information about descendants of this transaction that are in the\n     // mempool; if we remove this transaction we must remove all of these\n     // descendants as well.\n     uint64_t nCountWithDescendants{1}; //!< number of descendant transactions\n-    uint64_t nSizeWithDescendants;   //!< ... and size\n-    CAmount nModFeesWithDescendants; //!< ... and total fees (all including us)\n+    uint64_t nSizeWithDescendants;     //!< ... and size\n+    CAmount nModFeesWithDescendants;   //!< ... and total fees (all including us)\n \n     // Analogous statistics for ancestor transactions\n     uint64_t nCountWithAncestors{1};\n@@ -96,12 +101,30 @@ public:\n     CTxMemPoolEntry(const CTransactionRef& tx, CAmount fee,\n                     int64_t time, unsigned int entry_height,\n                     bool spends_coinbase,\n-                    int64_t sigops_cost, LockPoints lp);\n+                    int64_t sigops_cost, LockPoints lp)\n+        : tx{tx},\n+          nFee{fee},\n+          nTxWeight(GetTransactionWeight(*tx)),\n+          nUsageSize{RecursiveDynamicUsage(tx)},\n+          nTime{time},\n+          entryHeight{entry_height},\n+          spendsCoinbase{spends_coinbase},\n+          sigOpCost{sigops_cost},\n+          m_modified_fee{nFee},\n+          lockPoints{lp},\n+          nSizeWithDescendants{GetTxSize()},\n+          nModFeesWithDescendants{nFee},\n+          nSizeWithAncestors{GetTxSize()},\n+          nModFeesWithAncestors{nFee},\n+          nSigOpCostWithAncestors{sigOpCost} {}\n \n     const CTransaction& GetTx() const { return *this->tx; }\n     CTransactionRef GetSharedTx() const { return this->tx; }\n     const CAmount& GetFee() const { return nFee; }\n-    size_t GetTxSize() const;\n+    size_t GetTxSize() const\n+    {\n+        return GetVirtualTransactionSize(nTxWeight, sigOpCost, ::nBytesPerSigOp);\n+    }\n     size_t GetTxWeight() const { return nTxWeight; }\n     std::chrono::seconds GetTime() const { return std::chrono::seconds{nTime}; }\n     unsigned int GetHeight() const { return entryHeight; }\n@@ -115,9 +138,18 @@ public:\n     // Adjusts the ancestor state\n     void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int64_t modifySigOps);\n     // Updates the modified fees with descendants/ancestors.\n-    void UpdateModifiedFee(CAmount fee_diff);\n+    void UpdateModifiedFee(CAmount fee_diff)\n+    {\n+        nModFeesWithDescendants = SaturatingAdd(nModFeesWithDescendants, fee_diff);\n+        nModFeesWithAncestors = SaturatingAdd(nModFeesWithAncestors, fee_diff);\n+        m_modified_fee = SaturatingAdd(m_modified_fee, fee_diff);\n+    }\n+\n     // Update the LockPoints after a reorg\n-    void UpdateLockPoints(const LockPoints& lp);\n+    void UpdateLockPoints(const LockPoints& lp)\n+    {\n+        lockPoints = lp;\n+    }\n \n     uint64_t GetCountWithDescendants() const { return nCountWithDescendants; }\n     uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; }\n\n---\n file path A: test/sanitizer_suppressions/ubsan | file path B: test/sanitizer_suppressions/ubsan\n\n@@ -53,7 +53,7 @@ unsigned-integer-overflow:policy/fees.cpp\n unsigned-integer-overflow:prevector.h\n unsigned-integer-overflow:script/interpreter.cpp\n unsigned-integer-overflow:txmempool.cpp\n-unsigned-integer-overflow:txmempool_entry.cpp\n+unsigned-integer-overflow:txmempool_entry.h\n implicit-integer-sign-change:compat/stdin.cpp\n implicit-integer-sign-change:compressor.h\n implicit-integer-sign-change:crypto/\n@@ -63,7 +63,7 @@ implicit-integer-sign-change:script/bitcoinconsensus.cpp\n implicit-integer-sign-change:script/interpreter.cpp\n implicit-integer-sign-change:serialize.h\n implicit-integer-sign-change:txmempool.cpp\n-implicit-integer-sign-change:txmempool_entry.cpp\n+implicit-integer-sign-change:txmempool_entry.h\n implicit-signed-integer-truncation:crypto/\n implicit-unsigned-integer-truncation:crypto/\n shift-base:arith_uint256.cpp\n\n\n###\n\n", "completion": "refactor: Inline `CTxMemPoolEntry` class's functions"}
{"prompt": " file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -449,11 +449,15 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n \n     def add_wallet_options(self, parser, *, descriptors=True, legacy=True):\n         group = parser.add_mutually_exclusive_group()\n+        kwargs = {}\n+        if descriptors + legacy == 1:\n+            # If only one type can be chosen, set it as default\n+            kwargs[\"default\"] = descriptors\n         if descriptors:\n-            group.add_argument(\"--descriptors\", action='store_const', const=True,\n+            group.add_argument(\"--descriptors\", action='store_const', const=True, **kwargs,\n                                help=\"Run test using a descriptor wallet\", dest='descriptors')\n         if legacy:\n-            group.add_argument(\"--legacy-wallet\", action='store_const', const=False,\n+            group.add_argument(\"--legacy-wallet\", action='store_const', const=False, **kwargs,\n                                help=\"Run test using legacy wallets\", dest='descriptors')\n \n     def add_nodes(self, num_nodes: int, extra_args=None, *, rpchost=None, binary=None, binary_cli=None, versions=None):\n\n\n###\n\n", "completion": "test: Set default in add_wallet_options if only one type can be chosen"}
{"prompt": " file path A: test/functional/feature_maxtipage.py | file path B: test/functional/feature_maxtipage.py\n\n@@ -22,23 +22,24 @@ class MaxTipAgeTest(BitcoinTestFramework):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n \n-    def test_maxtipage(self, maxtipage, set_parameter=True):\n+    def test_maxtipage(self, maxtipage, set_parameter=True, test_deltas=True):\n         node_miner = self.nodes[0]\n         node_ibd = self.nodes[1]\n \n         self.restart_node(1, [f'-maxtipage={maxtipage}'] if set_parameter else None)\n         self.connect_nodes(0, 1)\n-\n-        # tips older than maximum age -> stay in IBD\n         cur_time = int(time.time())\n-        node_ibd.setmocktime(cur_time)\n-        for delta in [5, 4, 3, 2, 1]:\n-            node_miner.setmocktime(cur_time - maxtipage - delta)\n-            self.generate(node_miner, 1)\n-            assert_equal(node_ibd.getblockchaininfo()['initialblockdownload'], True)\n+\n+        if test_deltas:\n+            # tips older than maximum age -> stay in IBD\n+            node_ibd.setmocktime(cur_time)\n+            for delta in [5, 4, 3, 2, 1]:\n+                node_miner.setmocktime(cur_time - maxtipage - delta)\n+                self.generate(node_miner, 1)\n+                assert_equal(node_ibd.getblockchaininfo()['initialblockdownload'], True)\n \n         # tip within maximum age -> leave IBD\n-        node_miner.setmocktime(cur_time - maxtipage)\n+        node_miner.setmocktime(max(cur_time - maxtipage, 0))\n         self.generate(node_miner, 1)\n         assert_equal(node_ibd.getblockchaininfo()['initialblockdownload'], False)\n \n@@ -51,6 +52,10 @@ class MaxTipAgeTest(BitcoinTestFramework):\n             self.log.info(f\"Test IBD with maximum tip age of {hours} hours (-maxtipage={maxtipage}).\")\n             self.test_maxtipage(maxtipage)\n \n+        max_long_val = 9223372036854775807\n+        self.log.info(f\"Test IBD with highest allowable maximum tip age ({max_long_val}).\")\n+        self.test_maxtipage(max_long_val, test_deltas=False)\n+\n \n if __name__ == '__main__':\n     MaxTipAgeTest().main()\n\n\n###\n\n", "completion": "test: add -maxtipage test for the maximum allowable value"}
{"prompt": " file path A: src/validation.cpp | file path B: src/validation.cpp\n\n@@ -1541,7 +1541,7 @@ bool Chainstate::IsInitialBlockDownload() const\n     if (m_chain.Tip()->nChainWork < m_chainman.MinimumChainWork()) {\n         return true;\n     }\n-    if (m_chain.Tip()->Time() < NodeClock::now() - m_chainman.m_options.max_tip_age) {\n+    if (m_chain.Tip()->Time() < Now<NodeSeconds>() - m_chainman.m_options.max_tip_age) {\n         return true;\n     }\n     LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\");\n\n\n###\n\n", "completion": "fix: validation: cast now() to seconds for maxtipage comparison"}
{"prompt": " file path A: src/test/txreconciliation_tests.cpp | file path B: src/test/txreconciliation_tests.cpp\n\n@@ -22,17 +22,21 @@ BOOST_AUTO_TEST_CASE(RegisterPeerTest)\n     BOOST_CHECK(tracker.RegisterPeer(/*peer_id=*/0, /*is_peer_inbound=*/true,\n                                      /*peer_recon_version=*/0, salt) == ReconciliationRegisterResult::PROTOCOL_VIOLATION);\n \n-    // Valid registration.\n+    // Valid registration (inbound and outbound peers).\n     BOOST_REQUIRE(!tracker.IsPeerRegistered(0));\n     BOOST_REQUIRE(tracker.RegisterPeer(0, true, 1, salt) == ReconciliationRegisterResult::SUCCESS);\n     BOOST_CHECK(tracker.IsPeerRegistered(0));\n-\n-    // Reconciliation version is higher than ours, should be able to register.\n     BOOST_REQUIRE(!tracker.IsPeerRegistered(1));\n     tracker.PreRegisterPeer(1);\n-    BOOST_REQUIRE(tracker.RegisterPeer(1, true, 2, salt) == ReconciliationRegisterResult::SUCCESS);\n+    BOOST_REQUIRE(tracker.RegisterPeer(1, false, 1, salt) == ReconciliationRegisterResult::SUCCESS);\n     BOOST_CHECK(tracker.IsPeerRegistered(1));\n \n+    // Reconciliation version is higher than ours, should be able to register.\n+    BOOST_REQUIRE(!tracker.IsPeerRegistered(2));\n+    tracker.PreRegisterPeer(2);\n+    BOOST_REQUIRE(tracker.RegisterPeer(2, true, 2, salt) == ReconciliationRegisterResult::SUCCESS);\n+    BOOST_CHECK(tracker.IsPeerRegistered(2));\n+\n     // Try registering for the second time.\n     BOOST_REQUIRE(tracker.RegisterPeer(1, false, 1, salt) == ReconciliationRegisterResult::ALREADY_REGISTERED);\n \n\n---\n file path A: test/functional/p2p_sendtxrcncl.py | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -77,7 +77,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.wait_for_verack()\n         verack_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'verack'][0]\n         sendtxrcncl_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'sendtxrcncl'][0]\n-        assert(sendtxrcncl_index < verack_index)\n+        assert sendtxrcncl_index < verack_index\n         self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL on pre-WTXID version should not be sent')\n@@ -121,6 +121,14 @@ class SendTxRcnclTest(BitcoinTestFramework):\n             peer.send_message(sendtxrcncl_low_version)\n             peer.wait_for_disconnect()\n \n+        self.log.info('SENDTXRCNCL with version=2 is valid')\n+        sendtxrcncl_higher_version = create_sendtxrcncl_msg()\n+        sendtxrcncl_higher_version.version = 2\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n+        with self.nodes[0].assert_debug_log(['Register peer=6']):\n+            peer.send_message(sendtxrcncl_higher_version)\n+        self.nodes[0].disconnect_p2ps()\n+\n         self.log.info('sending SENDTXRCNCL after sending VERACK triggers a disconnect')\n         peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         with self.nodes[0].assert_debug_log([\"sendtxrcncl received after verack\"]):\n\n\n###\n\n", "completion": "test: Expand unit and functional tests for txreconciliation"}
{"prompt": " file path A: test/functional/rpc_fundrawtransaction.py | file path B: test/functional/rpc_fundrawtransaction.py\n\n@@ -1173,7 +1173,6 @@ class RawTransactionsTest(BitcoinTestFramework):\n \n         # Case (3), Explicit add_inputs=true and preset inputs (with preset inputs not-covering the target amount)\n         options[\"add_inputs\"] = True\n-        options[\"add_to_wallet\"] = False\n         assert \"psbt\" in wallet.walletcreatefundedpsbt(outputs=[{addr1: 8}], inputs=inputs, options=options)\n \n         # Case (4), Explicit add_inputs=true and preset inputs (with preset inputs covering the target amount)\n\n\n###\n\n", "completion": "test: Don't pass add_to_wallet option to walletcreatefundedpsbt"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -175,7 +175,7 @@ task:\n     - ccache --show-stats\n   check_script:\n     - src\\test_bitcoin.exe -l test_suite\n-    - src\\bench_bitcoin.exe --sanity-check > NUL\n+    - src\\bench_bitcoin.exe --sanity-check\n     - python test\\util\\test_runner.py\n     - python test\\util\\rpcauth-test.py\n   functional_tests_script:\n\n---\n file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -377,7 +377,7 @@ if TARGET_WINDOWS\n else\n if ENABLE_BENCH\n \t@echo \"Running bench/bench_bitcoin (one iteration sanity check, only high priority)...\"\n-\t$(BENCH_BINARY) -sanity-check -priority-level=high > /dev/null\n+\t$(BENCH_BINARY) -sanity-check -priority-level=high\n endif\n endif\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n\n\n###\n\n", "completion": "test: Drop no longer required bench output redirection"}
{"prompt": " file path A: test/functional/test_framework/test_node.py | file path B: test/functional/test_framework/test_node.py\n\n@@ -105,6 +105,9 @@ class TestNode():\n             \"-debugexclude=rand\",\n             \"-uacomment=testnode%d\" % i,\n         ]\n+        if self.descriptors is None:\n+            self.args.append(\"-disablewallet\")\n+\n         if use_valgrind:\n             default_suppressions_file = os.path.join(\n                 os.path.dirname(os.path.realpath(__file__)),\n\n\n###\n\n", "completion": "test: Set -disablewallet when no wallet has been compiled"}
{"prompt": " file path A: test/functional/interface_bitcoin_cli.py | file path B: test/functional/interface_bitcoin_cli.py\n\n@@ -69,8 +69,6 @@ class TestBitcoinCli(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-        if self.is_specified_wallet_compiled():\n-            self.requires_wallet = True\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_cli()\n@@ -114,6 +112,7 @@ class TestBitcoinCli(BitcoinTestFramework):\n \n         self.log.info(\"Test -getinfo returns expected network and blockchain info\")\n         if self.is_specified_wallet_compiled():\n+            self.import_deterministic_coinbase_privkeys()\n             self.nodes[0].encryptwallet(password)\n         cli_get_info_string = self.nodes[0].cli('-getinfo').send_cli()\n         cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n\n---\n file path A: test/functional/mempool_unbroadcast.py | file path B: test/functional/mempool_unbroadcast.py\n\n@@ -17,8 +17,6 @@ MAX_INITIAL_BROADCAST_DELAY = 15 * 60 # 15 minutes in seconds\n class MempoolUnbroadcastTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n-        if self.is_wallet_compiled():\n-            self.requires_wallet = True\n \n     def run_test(self):\n         self.wallet = MiniWallet(self.nodes[0])\n@@ -35,6 +33,7 @@ class MempoolUnbroadcastTest(BitcoinTestFramework):\n         self.log.info(\"Generate transactions that only node 0 knows about\")\n \n         if self.is_wallet_compiled():\n+            self.import_deterministic_coinbase_privkeys()\n             # generate a wallet txn\n             addr = node.getnewaddress()\n             wallet_tx_hsh = node.sendtoaddress(addr, 0.0001)\n\n---\n file path A: test/functional/rpc_createmultisig.py | file path B: test/functional/rpc_createmultisig.py\n\n@@ -28,8 +28,6 @@ class RpcCreateMultiSigTest(BitcoinTestFramework):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n         self.supports_cli = False\n-        if self.is_bdb_compiled():\n-            self.requires_wallet = True\n \n     def get_keys(self):\n         self.pub = []\n@@ -50,6 +48,7 @@ class RpcCreateMultiSigTest(BitcoinTestFramework):\n         self.wallet = MiniWallet(test_node=node0)\n \n         if self.is_bdb_compiled():\n+            self.import_deterministic_coinbase_privkeys()\n             self.check_addmultisigaddress_errors()\n \n         self.log.info('Generating blocks ...')\n\n---\n file path A: test/functional/rpc_rawtransaction.py | file path B: test/functional/rpc_rawtransaction.py\n\n@@ -65,8 +65,6 @@ class RawTransactionsTest(BitcoinTestFramework):\n         # whitelist all peers to speed up tx relay / mempool sync\n         for args in self.extra_args:\n             args.append(\"-whitelist=noban@127.0.0.1\")\n-        self.requires_wallet = self.is_specified_wallet_compiled()\n-\n         self.supports_cli = False\n \n     def setup_network(self):\n@@ -85,7 +83,8 @@ class RawTransactionsTest(BitcoinTestFramework):\n         self.sendrawtransaction_testmempoolaccept_tests()\n         self.decoderawtransaction_tests()\n         self.transaction_version_number_tests()\n-        if self.requires_wallet and not self.options.descriptors:\n+        if self.is_specified_wallet_compiled() and not self.options.descriptors:\n+            self.import_deterministic_coinbase_privkeys()\n             self.raw_multisig_transaction_legacy_tests()\n \n     def getrawtransaction_tests(self):\n\n---\n file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -113,7 +113,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n         self.wallet_names = None\n         # By default the wallet is not required. Set to true by skip_if_no_wallet().\n         # When False, we ignore wallet_names regardless of what it is.\n-        self.requires_wallet = False\n+        self._requires_wallet = False\n         # Disable ThreadOpenConnections by default, so that adding entries to\n         # addrman will not result in automatic connections to them.\n         self.disable_autoconnect = True\n@@ -412,7 +412,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n             extra_args = self.extra_args\n         self.add_nodes(self.num_nodes, extra_args)\n         self.start_nodes()\n-        if self.requires_wallet:\n+        if self._requires_wallet:\n             self.import_deterministic_coinbase_privkeys()\n         if not self.setup_clean_chain:\n             for n in self.nodes:\n@@ -866,7 +866,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n \n     def skip_if_no_wallet(self):\n         \"\"\"Skip the running test if wallet has not been compiled.\"\"\"\n-        self.requires_wallet = True\n+        self._requires_wallet = True\n         if not self.is_wallet_compiled():\n             raise SkipTest(\"wallet has not been compiled.\")\n         if self.options.descriptors:\n\n\n###\n\n", "completion": "test: Make requires_wallet private"}
{"prompt": " file path A: src/test/getarg_tests.cpp | file path B: src/test/getarg_tests.cpp\n\n@@ -429,7 +429,7 @@ BOOST_AUTO_TEST_CASE(logargs)\n     const auto okaylog = std::make_pair(\"-okaylog\", ArgsManager::ALLOW_ANY);\n     const auto dontlog = std::make_pair(\"-dontlog\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE);\n     SetupArgs(local_args, {okaylog_bool, okaylog_negbool, okaylog, dontlog});\n-    ResetArgs(local_args, \"-okaylog-bool -nookaylog-negbool -okaylog=public -dontlog=private\");\n+    ResetArgs(local_args, \"-okaylog-bool -nookaylog-negbool -okaylog=public -dontlog=private42\");\n \n     // Everything logged to debug.log will also append to str\n     std::string str;\n@@ -447,7 +447,7 @@ BOOST_AUTO_TEST_CASE(logargs)\n     BOOST_CHECK(str.find(\"Command-line arg: okaylog-negbool=false\") != std::string::npos);\n     BOOST_CHECK(str.find(\"Command-line arg: okaylog=\\\"public\\\"\") != std::string::npos);\n     BOOST_CHECK(str.find(\"dontlog=****\") != std::string::npos);\n-    BOOST_CHECK(str.find(\"private\") == std::string::npos);\n+    BOOST_CHECK(str.find(\"private42\") == std::string::npos);\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: Avoid collision with valid path names in `getarg_tests/logargs`"}
{"prompt": " file path A: test/functional/wallet_descriptor.py | file path B: test/functional/wallet_descriptor.py\n\n@@ -62,6 +62,11 @@ class WalletDescriptorTest(BitcoinTestFramework):\n         assert addr_info['desc'].startswith('wpkh(')\n         assert_equal(addr_info['hdkeypath'], 'm/84\\'/1\\'/0\\'/0/0')\n \n+        addr = self.nodes[0].getnewaddress(\"\", \"bech32m\")\n+        addr_info = self.nodes[0].getaddressinfo(addr)\n+        assert addr_info['desc'].startswith('tr(')\n+        assert_equal(addr_info['hdkeypath'], 'm/86\\'/1\\'/0\\'/0/0')\n+\n         # Check that getrawchangeaddress works\n         addr = self.nodes[0].getrawchangeaddress(\"legacy\")\n         addr_info = self.nodes[0].getaddressinfo(addr)\n@@ -78,6 +83,11 @@ class WalletDescriptorTest(BitcoinTestFramework):\n         assert addr_info['desc'].startswith('wpkh(')\n         assert_equal(addr_info['hdkeypath'], 'm/84\\'/1\\'/0\\'/1/0')\n \n+        addr = self.nodes[0].getrawchangeaddress(\"bech32m\")\n+        addr_info = self.nodes[0].getaddressinfo(addr)\n+        assert addr_info['desc'].startswith('tr(')\n+        assert_equal(addr_info['hdkeypath'], 'm/86\\'/1\\'/0\\'/1/0')\n+\n         # Make a wallet to receive coins at\n         self.nodes[0].createwallet(wallet_name=\"desc2\", descriptors=True)\n         recv_wrpc = self.nodes[0].get_wallet_rpc(\"desc2\")\n@@ -161,9 +171,11 @@ class WalletDescriptorTest(BitcoinTestFramework):\n         addr_types = [('legacy', False, 'pkh(', '44\\'/1\\'/0\\'', -13),\n                       ('p2sh-segwit', False, 'sh(wpkh(', '49\\'/1\\'/0\\'', -14),\n                       ('bech32', False, 'wpkh(', '84\\'/1\\'/0\\'', -13),\n+                      ('bech32m', False, 'tr(', '86\\'/1\\'/0\\'', -13),\n                       ('legacy', True, 'pkh(', '44\\'/1\\'/0\\'', -13),\n                       ('p2sh-segwit', True, 'sh(wpkh(', '49\\'/1\\'/0\\'', -14),\n-                      ('bech32', True, 'wpkh(', '84\\'/1\\'/0\\'', -13)]\n+                      ('bech32', True, 'wpkh(', '84\\'/1\\'/0\\'', -13),\n+                      ('bech32m', True, 'tr(', '86\\'/1\\'/0\\'', -13)]\n \n         for addr_type, internal, desc_prefix, deriv_path, int_idx in addr_types:\n             int_str = 'internal' if internal else 'external'\n\n\n###\n\n", "completion": "test: add missing bech32m / BIP86 test-cases to wallet_descriptor.py"}
{"prompt": " file path A: test/functional/wallet_descriptor.py | file path B: test/functional/wallet_descriptor.py\n\n@@ -3,6 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test descriptor wallet function.\"\"\"\n+import os\n+import sqlite3\n \n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.test_framework import BitcoinTestFramework\n@@ -209,5 +211,15 @@ class WalletDescriptorTest(BitcoinTestFramework):\n                     imp_addr = imp_rpc.getnewaddress(address_type=addr_type)\n                 assert_equal(exp_addr, imp_addr)\n \n+        self.log.info(\"Test that loading descriptor wallet containing legacy key types throws error\")\n+        self.nodes[0].createwallet(wallet_name=\"crashme\", descriptors=True)\n+        self.nodes[0].unloadwallet(\"crashme\")\n+        wallet_db = os.path.join(self.nodes[0].datadir, self.chain, \"wallets\", \"crashme\", self.wallet_data_filename)\n+        with sqlite3.connect(wallet_db) as conn:\n+            # add \"cscript\" entry: key type is uint160 (20 bytes), value type is CScript (zero-length here)\n+            conn.execute('INSERT INTO main VALUES(?, ?)', (b'\\x07cscript' + b'\\x00'*20, b'\\x00'))\n+        assert_raises_rpc_error(-4, \"Unexpected legacy entry in descriptor wallet found.\", self.nodes[0].loadwallet, \"crashme\")\n+\n+\n if __name__ == '__main__':\n     WalletDescriptorTest().main ()\n\n\n###\n\n", "completion": "test: check that loading descriptor wallet with legacy entries throws error"}
{"prompt": " file path A: test/functional/p2p_sendtxrcncl.py | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -74,7 +74,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         assert not peer.sendtxrcncl_msg_received.initiator\n         assert peer.sendtxrcncl_msg_received.responder\n         assert_equal(peer.sendtxrcncl_msg_received.version, 1)\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL should be sent before VERACK')\n         peer = self.nodes[0].add_p2p_connection(PeerTrackMsgOrder(), send_version=True, wait_for_verack=True)\n@@ -82,7 +82,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         verack_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'verack'][0]\n         sendtxrcncl_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'sendtxrcncl'][0]\n         assert(sendtxrcncl_index < verack_index)\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL on pre-WTXID version should not be sent')\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=False, wait_for_verack=False)\n@@ -94,7 +94,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.send_message(pre_wtxid_version_msg)\n         peer.wait_for_verack()\n         assert not peer.sendtxrcncl_msg_received\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL for fRelay=false should not be sent')\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=False, wait_for_verack=False)\n@@ -106,7 +106,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.send_message(no_txrelay_version_msg)\n         peer.wait_for_verack()\n         assert not peer.sendtxrcncl_msg_received\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('valid SENDTXRCNCL received')\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n@@ -152,31 +152,31 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         with self.nodes[0].assert_debug_log(['Forget txreconciliation state of peer']):\n             peer.send_message(create_sendtxrcncl_msg())\n             peer.send_message(msg_verack())\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL sent to an outbound')\n         peer = self.nodes[0].add_outbound_p2p_connection(\n-            SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=1, connection_type=\"outbound-full-relay\")\n+            SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=0, connection_type=\"outbound-full-relay\")\n         assert peer.sendtxrcncl_msg_received\n         assert peer.sendtxrcncl_msg_received.initiator\n         assert not peer.sendtxrcncl_msg_received.responder\n         assert_equal(peer.sendtxrcncl_msg_received.version, 1)\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL should not be sent if block-relay-only')\n         peer = self.nodes[0].add_outbound_p2p_connection(\n-            SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=2, connection_type=\"block-relay-only\")\n+            SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=0, connection_type=\"block-relay-only\")\n         assert not peer.sendtxrcncl_msg_received\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info(\"SENDTXRCNCL should not be sent if feeler\")\n-        peer = self.nodes[0].add_outbound_p2p_connection(P2PFeelerReceiver(), p2p_idx=2, connection_type=\"feeler\")\n+        peer = self.nodes[0].add_outbound_p2p_connection(P2PFeelerReceiver(), p2p_idx=0, connection_type=\"feeler\")\n         assert not peer.sendtxrcncl_msg_received\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL if block-relay-only triggers a disconnect')\n         peer = self.nodes[0].add_outbound_p2p_connection(\n-            PeerNoVerack(), wait_for_verack=False, p2p_idx=3, connection_type=\"block-relay-only\")\n+            PeerNoVerack(), wait_for_verack=False, p2p_idx=0, connection_type=\"block-relay-only\")\n         with self.nodes[0].assert_debug_log([\"we indicated no tx relay; disconnecting\"]):\n             peer.send_message(create_sendtxrcncl_msg(initiator=False))\n             peer.wait_for_disconnect()\n@@ -184,7 +184,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.log.info('SENDTXRCNCL with initiator=1 and responder=0 from outbound triggers a disconnect')\n         sendtxrcncl_wrong_role = create_sendtxrcncl_msg(initiator=True)\n         peer = self.nodes[0].add_outbound_p2p_connection(\n-            PeerNoVerack(), wait_for_verack=False, p2p_idx=4, connection_type=\"outbound-full-relay\")\n+            PeerNoVerack(), wait_for_verack=False, p2p_idx=0, connection_type=\"outbound-full-relay\")\n         with self.nodes[0].assert_debug_log([\"txreconciliation protocol violation\"]):\n             peer.send_message(sendtxrcncl_wrong_role)\n             peer.wait_for_disconnect()\n@@ -193,13 +193,13 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.restart_node(0, [])\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n         assert not peer.sendtxrcncl_msg_received\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL not sent if blocksonly is set')\n         self.restart_node(0, [\"-txreconciliation\", \"-blocksonly\"])\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n         assert not peer.sendtxrcncl_msg_received\n-        peer.peer_disconnect()\n+        self.nodes[0].disconnect_p2ps()\n \n \n if __name__ == '__main__':\n\n---\n file path A: test/functional/test_framework/test_node.py | file path B: test/functional/test_framework/test_node.py\n\n@@ -625,6 +625,10 @@ class TestNode():\n \n         This method adds the p2p connection to the self.p2ps list and returns\n         the connection to the caller.\n+\n+        p2p_idx must be different for simultaneously connected peers. When reusing it for the next peer\n+        after disconnecting the previous one, it is necessary to wait for the disconnect to finish to avoid\n+        a race condition.\n         \"\"\"\n \n         def addconnection_callback(address, port):\n\n\n###\n\n", "completion": "test: fix intermittent failure in p2p_sendtxrcncl.py"}
{"prompt": " file path A: configure.ac | file path B: configure.ac\n\n@@ -1984,10 +1984,6 @@ AC_SUBST(HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])\n-AC_CONFIG_LINKS([contrib/devtools/security-check.py:contrib/devtools/security-check.py])\n-AC_CONFIG_LINKS([contrib/devtools/symbol-check.py:contrib/devtools/symbol-check.py])\n-AC_CONFIG_LINKS([contrib/devtools/test-security-check.py:contrib/devtools/test-security-check.py])\n-AC_CONFIG_LINKS([contrib/devtools/test-symbol-check.py:contrib/devtools/test-symbol-check.py])\n AC_CONFIG_LINKS([contrib/devtools/iwyu/bitcoin.core.imp:contrib/devtools/iwyu/bitcoin.core.imp])\n AC_CONFIG_LINKS([contrib/filter-lcov.py:contrib/filter-lcov.py])\n AC_CONFIG_LINKS([contrib/macdeploy/background.tiff:contrib/macdeploy/background.tiff])\n\n\n###\n\n", "completion": "build: Drop unneeded linking of `contrib/devtools/` scripts"}
{"prompt": " file path A: test/functional/wallet_taproot.py | file path B: test/functional/wallet_taproot.py\n\n@@ -156,9 +156,6 @@ KEYS = [\n     }\n ]\n \n-CHANGE_XPRV = \"tprv8ZgxMBicQKsPcyDrWwiecVnTtFmfRwbfFqEfR4ZGWvq5aTTwLBWmAm5zrbMcYtb9gQNFfhRfqhhrBG37U3nhmXxEgeEPBJGHAPrHCrAd1WX\"\n-CHANGE_XPUB = \"tpubD6NzVbkrYhZ4WSFeQbPF1uSaTHHbbGnZq8qShabZwCdUQwihxaLMMFhs2kidGF2qrRKiQVqw8VoyuTHj1bZqmMXMeciaU1gBjWA1sim2zUB\"\n-\n \n def key(hex_key):\n     \"\"\"Construct an x-only pubkey from its hex representation.\"\"\"\n\n\n###\n\n", "completion": "test: remove unused `CHANGE_{XPRV,XPUB}` constants"}
{"prompt": " file path A: build_msvc/bitcoin-cli/bitcoin-cli.vcxproj | file path B: build_msvc/bitcoin-cli/bitcoin-cli.vcxproj\n\n@@ -15,6 +15,9 @@\n     <ProjectReference Include=\"..\\libbitcoin_cli\\libbitcoin_cli.vcxproj\">\n       <Project>{0667528c-d734-4009-adf9-c0d6c4a5a5a6}</Project>\n     </ProjectReference>\n+    <ProjectReference Include=\"..\\libbitcoin_common\\libbitcoin_common.vcxproj\">\n+      <Project>{7c87e378-df58-482e-aa2f-1bc129bc19ce}</Project>\n+    </ProjectReference>\n     <ProjectReference Include=\"..\\libbitcoin_crypto\\libbitcoin_crypto.vcxproj\">\n       <Project>{6190199c-6cf4-4dad-bfbd-93fa72a760c1}</Project>\n     </ProjectReference>\n\n---\n file path A: build_msvc/libbitcoin_common/libbitcoin_common.vcxproj.in | file path B: build_msvc/libbitcoin_common/libbitcoin_common.vcxproj.in\n\n@@ -8,6 +8,7 @@\n     <ConfigurationType>StaticLibrary</ConfigurationType>\n   </PropertyGroup>\n   <ItemGroup>\n+    <ClCompile Include=\"..\\..\\src\\common\\url.cpp\" />\n @SOURCE_FILES@\n   </ItemGroup>\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n---\n file path A: build_msvc/libbitcoin_util/libbitcoin_util.vcxproj.in | file path B: build_msvc/libbitcoin_util/libbitcoin_util.vcxproj.in\n\n@@ -8,7 +8,6 @@\n     <ConfigurationType>StaticLibrary</ConfigurationType>\n   </PropertyGroup>\n   <ItemGroup>\n-    <ClCompile Include=\"..\\..\\src\\util\\url.cpp\" />\n @SOURCE_FILES@\n   </ItemGroup>\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n---\n file path A: ci/test/06_script_b.sh | file path B: ci/test/06_script_b.sh\n\n@@ -40,6 +40,7 @@ if [ \"${RUN_TIDY}\" = \"true\" ]; then\n   ( CI_EXEC run-clang-tidy -quiet \"${MAKEJOBS}\" ) | grep -C5 \"error\"\n   export P_CI_DIR=\"${BASE_BUILD_DIR}/bitcoin-$HOST/\"\n   CI_EXEC \"python3 ${DIR_IWYU}/include-what-you-use/iwyu_tool.py\"\\\n+          \" src/common/url.cpp\"\\\n           \" src/compat\"\\\n           \" src/dbwrapper.cpp\"\\\n           \" src/init\"\\\n@@ -68,7 +69,6 @@ if [ \"${RUN_TIDY}\" = \"true\" ]; then\n           \" src/util/strencodings.cpp\"\\\n           \" src/util/string.cpp\"\\\n           \" src/util/syserror.cpp\"\\\n-          \" src/util/url.cpp\"\\\n           \" src/zmq\"\\\n           \" -p . ${MAKEJOBS} -- -Xiwyu --cxx17ns -Xiwyu --mapping_file=${BASE_BUILD_DIR}/bitcoin-$HOST/contrib/devtools/iwyu/bitcoin.core.imp\"\n fi\n\n---\n file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -134,6 +134,7 @@ BITCOIN_CORE_H = \\\n   coins.h \\\n   common/bloom.h \\\n   common/run_command.h \\\n+  common/url.h \\\n   compat/assumptions.h \\\n   compat/byteswap.h \\\n   compat/compat.h \\\n@@ -303,7 +304,6 @@ BITCOIN_CORE_H = \\\n   util/translation.h \\\n   util/types.h \\\n   util/ui_change_type.h \\\n-  util/url.h \\\n   util/vector.h \\\n   validation.h \\\n   validationinterface.h \\\n@@ -662,6 +662,11 @@ libbitcoin_common_a_SOURCES = \\\n   script/standard.cpp \\\n   warnings.cpp \\\n   $(BITCOIN_CORE_H)\n+\n+if USE_LIBEVENT\n+libbitcoin_common_a_CPPFLAGS += $(EVENT_CFLAGS)\n+libbitcoin_common_a_SOURCES += common/url.cpp\n+endif\n #\n \n # util #\n@@ -708,11 +713,6 @@ libbitcoin_util_a_SOURCES = \\\n   util/time.cpp \\\n   util/tokenpipe.cpp \\\n   $(BITCOIN_CORE_H)\n-\n-if USE_LIBEVENT\n-libbitcoin_util_a_CPPFLAGS += $(EVENT_CFLAGS)\n-libbitcoin_util_a_SOURCES += util/url.cpp\n-endif\n #\n \n # cli #\n@@ -776,6 +776,7 @@ endif\n bitcoin_cli_LDADD = \\\n   $(LIBBITCOIN_CLI) \\\n   $(LIBUNIVALUE) \\\n+  $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO)\n \n\n---\n file path A: src/bitcoin-cli.cpp | file path B: src/bitcoin-cli.cpp\n\n@@ -9,6 +9,7 @@\n \n #include <chainparamsbase.h>\n #include <clientversion.h>\n+#include <common/url.h>\n #include <compat/compat.h>\n #include <compat/stdin.h>\n #include <policy/feerate.h>\n@@ -21,7 +22,6 @@\n #include <util/strencodings.h>\n #include <util/system.h>\n #include <util/translation.h>\n-#include <util/url.h>\n \n #include <algorithm>\n #include <chrono>\n\n---\n file path A: src/bitcoin-wallet.cpp | file path B: src/bitcoin-wallet.cpp\n\n@@ -9,6 +9,7 @@\n #include <chainparams.h>\n #include <chainparamsbase.h>\n #include <clientversion.h>\n+#include <common/url.h>\n #include <compat/compat.h>\n #include <interfaces/init.h>\n #include <key.h>\n@@ -17,7 +18,6 @@\n #include <tinyformat.h>\n #include <util/system.h>\n #include <util/translation.h>\n-#include <util/url.h>\n #include <wallet/wallettool.h>\n \n #include <exception>\n\n---\n file path A: src/bitcoind.cpp | file path B: src/bitcoind.cpp\n\n@@ -9,6 +9,7 @@\n \n #include <chainparams.h>\n #include <clientversion.h>\n+#include <common/url.h>\n #include <compat/compat.h>\n #include <init.h>\n #include <interfaces/chain.h>\n@@ -25,7 +26,6 @@\n #include <util/threadnames.h>\n #include <util/tokenpipe.h>\n #include <util/translation.h>\n-#include <util/url.h>\n \n #include <any>\n #include <functional>\n\n---\n file path A: src/util/url.cpp | file path B: src/common/url.cpp\n\n@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util/url.h>\n+#include <common/url.h>\n \n #include <event2/http.h>\n \n\n---\n file path A: src/util/url.h | file path B: src/common/url.h\n\n@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_UTIL_URL_H\n-#define BITCOIN_UTIL_URL_H\n+#ifndef BITCOIN_COMMON_URL_H\n+#define BITCOIN_COMMON_URL_H\n \n #include <string>\n \n@@ -11,4 +11,4 @@ using UrlDecodeFn = std::string(const std::string& url_encoded);\n UrlDecodeFn urlDecode;\n extern UrlDecodeFn* const URL_DECODE;\n \n-#endif // BITCOIN_UTIL_URL_H\n+#endif // BITCOIN_COMMON_URL_H\n\n---\n file path A: src/qt/main.cpp | file path B: src/qt/main.cpp\n\n@@ -4,9 +4,9 @@\n \n #include <qt/bitcoin.h>\n \n+#include <common/url.h>\n #include <compat/compat.h>\n #include <util/translation.h>\n-#include <util/url.h>\n \n #include <QCoreApplication>\n \n\n---\n file path A: src/test/fuzz/string.cpp | file path B: src/test/fuzz/string.cpp\n\n@@ -4,6 +4,7 @@\n \n #include <blockfilter.h>\n #include <clientversion.h>\n+#include <common/url.h>\n #include <logging.h>\n #include <netaddress.h>\n #include <netbase.h>\n@@ -27,7 +28,6 @@\n #include <util/string.h>\n #include <util/system.h>\n #include <util/translation.h>\n-#include <util/url.h>\n #include <version.h>\n \n #include <cstdint>\n\n---\n file path A: src/test/util/setup_common.cpp | file path B: src/test/util/setup_common.cpp\n\n@@ -9,6 +9,7 @@\n #include <addrman.h>\n #include <banman.h>\n #include <chainparams.h>\n+#include <common/url.h>\n #include <consensus/consensus.h>\n #include <consensus/params.h>\n #include <consensus/validation.h>\n@@ -46,7 +47,6 @@\n #include <util/threadnames.h>\n #include <util/time.h>\n #include <util/translation.h>\n-#include <util/url.h>\n #include <util/vector.h>\n #include <validation.h>\n #include <validationinterface.h>\n\n---\n file path A: src/wallet/rpc/util.cpp | file path B: src/wallet/rpc/util.cpp\n\n@@ -4,9 +4,9 @@\n \n #include <wallet/rpc/util.h>\n \n+#include <common/url.h>\n #include <rpc/util.h>\n #include <util/translation.h>\n-#include <util/url.h>\n #include <wallet/context.h>\n #include <wallet/wallet.h>\n \n\n\n###\n\n", "completion": "refactor: move url.h/cpp from lib util to lib common"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -710,6 +710,7 @@ libbitcoin_util_a_SOURCES = \\\n   $(BITCOIN_CORE_H)\n \n if USE_LIBEVENT\n+libbitcoin_util_a_CPPFLAGS += $(EVENT_CFLAGS)\n libbitcoin_util_a_SOURCES += util/url.cpp\n endif\n #\n\n\n###\n\n", "completion": "build: add missing event cflags to libbitcoin_util"}
{"prompt": " file path A: test/functional/feature_index_prune.py | file path B: test/functional/feature_index_prune.py\n\n@@ -138,6 +138,7 @@ class FeatureIndexPruneTest(BitcoinTestFramework):\n             self.connect_nodes(i, 3)\n \n         self.sync_blocks(timeout=300)\n+        self.sync_index(height=2500)\n \n         for node in self.nodes[:2]:\n             with node.assert_debug_log(['limited pruning to height 2489']):\n\n\n###\n\n", "completion": "test: fix intermittent failure in feature_index_prune.py"}
{"prompt": " file path A: test/functional/rpc_getblockfrompeer.py | file path B: test/functional/rpc_getblockfrompeer.py\n\n@@ -100,7 +100,7 @@ class GetBlockFromPeerTest(BitcoinTestFramework):\n         # Connect a P2PInterface to the pruning node and have it submit only the header of the\n         # block that the pruning node has not seen\n         node1_interface = self.nodes[1].add_p2p_connection(P2PInterface())\n-        node1_interface.send_message(msg_headers([block]))\n+        node1_interface.send_and_ping(msg_headers([block]))\n \n         # Get the peer id of the P2PInterface from the pruning node\n         node1_peers = self.nodes[1].getpeerinfo()\n\n\n###\n\n", "completion": "test: fix intermittent failure in rpc_getblockfrompeer.py"}
{"prompt": " file path A: test/functional/test_framework/wallet.py | file path B: test/functional/test_framework/wallet.py\n\n@@ -245,6 +245,7 @@ class MiniWallet:\n         utxos_to_spend: Optional[List[dict]] = None,\n         num_outputs=1,\n         amount_per_output=0,\n+        locktime=0,\n         sequence=0,\n         fee_per_output=1000,\n         target_weight=0\n@@ -257,27 +258,29 @@ class MiniWallet:\n         utxos_to_spend = utxos_to_spend or [self.get_utxo()]\n         sequence = [sequence] * len(utxos_to_spend) if type(sequence) is int else sequence\n         assert_equal(len(utxos_to_spend), len(sequence))\n-        # create simple tx template (1 input, 1 output)\n-        tx = self.create_self_transfer(\n-            fee_rate=0,\n-            utxo_to_spend=utxos_to_spend[0])[\"tx\"]\n-\n-        # duplicate inputs, witnesses and outputs\n-        tx.vin = [deepcopy(tx.vin[0]) for _ in range(len(utxos_to_spend))]\n-        for txin, seq in zip(tx.vin, sequence):\n-            txin.nSequence = seq\n-        tx.wit.vtxinwit = [deepcopy(tx.wit.vtxinwit[0]) for _ in range(len(utxos_to_spend))]\n-        tx.vout = [deepcopy(tx.vout[0]) for _ in range(num_outputs)]\n-\n-        # adapt input prevouts\n-        for i, utxo in enumerate(utxos_to_spend):\n-            tx.vin[i] = CTxIn(COutPoint(int(utxo['txid'], 16), utxo['vout']))\n-\n-        # adapt output amounts (use fixed fee per output)\n+\n+        # calculate output amount\n         inputs_value_total = sum([int(COIN * utxo['value']) for utxo in utxos_to_spend])\n         outputs_value_total = inputs_value_total - fee_per_output * num_outputs\n-        for o in tx.vout:\n-            o.nValue = amount_per_output or (outputs_value_total // num_outputs)\n+        amount_per_output = amount_per_output or (outputs_value_total // num_outputs)\n+\n+        # create tx\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']), nSequence=seq) for utxo_to_spend,seq in zip(utxos_to_spend, sequence)]\n+        tx.vout = [CTxOut(amount_per_output, bytearray(self._scriptPubKey)) for _ in range(num_outputs)]\n+        tx.nLockTime = locktime\n+\n+        if self._mode == MiniWalletMode.RAW_P2PK:\n+            self.sign_tx(tx)\n+        elif self._mode == MiniWalletMode.RAW_OP_TRUE:\n+            for i in range(len(utxos_to_spend)):\n+                tx.vin[i].scriptSig = CScript([OP_NOP] * 43)  # pad to identical size\n+        elif self._mode == MiniWalletMode.ADDRESS_OP_TRUE:\n+            tx.wit.vtxinwit = [CTxInWitness()] * len(utxos_to_spend)\n+            for i in range(len(utxos_to_spend)):\n+                tx.wit.vtxinwit[i].scriptWitness.stack = [CScript([OP_TRUE]), bytes([LEAF_VERSION_TAPSCRIPT]) + self._internal_key]\n+        else:\n+            assert False\n \n         if target_weight:\n             self._bulk_tx(tx, target_weight)\n@@ -300,6 +303,7 @@ class MiniWallet:\n         utxo_to_spend = utxo_to_spend or self.get_utxo()\n         assert fee_rate >= 0\n         assert fee >= 0\n+        # calculate fee\n         if self._mode in (MiniWalletMode.RAW_OP_TRUE, MiniWalletMode.ADDRESS_OP_TRUE):\n             vsize = Decimal(104)  # anyone-can-spend\n         elif self._mode == MiniWalletMode.RAW_P2PK:\n@@ -309,29 +313,12 @@ class MiniWallet:\n         send_value = utxo_to_spend[\"value\"] - (fee or (fee_rate * vsize / 1000))\n         assert send_value > 0\n \n-        tx = CTransaction()\n-        tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']), nSequence=sequence)]\n-        tx.vout = [CTxOut(int(COIN * send_value), bytearray(self._scriptPubKey))]\n-        tx.nLockTime = locktime\n-        if self._mode == MiniWalletMode.RAW_P2PK:\n-            self.sign_tx(tx)\n-        elif self._mode == MiniWalletMode.RAW_OP_TRUE:\n-            tx.vin[0].scriptSig = CScript([OP_NOP] * 43)  # pad to identical size\n-        elif self._mode == MiniWalletMode.ADDRESS_OP_TRUE:\n-            tx.wit.vtxinwit = [CTxInWitness()]\n-            tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE]), bytes([LEAF_VERSION_TAPSCRIPT]) + self._internal_key]\n-        else:\n-            assert False\n-\n-        assert_equal(tx.get_vsize(), vsize)\n-\n-        if target_weight:\n-            self._bulk_tx(tx, target_weight)\n-\n-        tx_hex = tx.serialize().hex()\n-        new_utxo = self._create_utxo(txid=tx.rehash(), vout=0, value=send_value, height=0)\n+        # create tx\n+        tx = self.create_self_transfer_multi(utxos_to_spend=[utxo_to_spend], locktime=locktime, sequence=sequence, amount_per_output=int(COIN * send_value), target_weight=target_weight)\n+        if not target_weight:\n+            assert_equal(tx[\"tx\"].get_vsize(), vsize)\n \n-        return {\"txid\": new_utxo[\"txid\"], \"wtxid\": tx.getwtxid(), \"hex\": tx_hex, \"tx\": tx, \"new_utxo\": new_utxo}\n+        return {\"txid\": tx[\"txid\"], \"wtxid\": tx[\"tx\"].getwtxid(), \"hex\": tx[\"hex\"], \"tx\": tx[\"tx\"], \"new_utxo\": tx[\"new_utxos\"][0]}\n \n     def sendrawtransaction(self, *, from_node, tx_hex, maxfeerate=0, **kwargs):\n         txid = from_node.sendrawtransaction(hexstring=tx_hex, maxfeerate=maxfeerate, **kwargs)\n\n\n###\n\n", "completion": "test: Move tx creation to create_self_transfer_multi"}
{"prompt": " file path A: src/kernel/chainstatemanager_opts.h | file path B: src/kernel/chainstatemanager_opts.h\n\n@@ -31,9 +31,9 @@ struct ChainstateManagerOpts {\n     std::optional<bool> check_block_index{};\n     bool checkpoints_enabled{DEFAULT_CHECKPOINTS_ENABLED};\n     //! If set, it will override the minimum work we will assume exists on some valid chain.\n-    std::optional<arith_uint256> minimum_chain_work;\n+    std::optional<arith_uint256> minimum_chain_work{};\n     //! If set, it will override the block hash whose ancestors we will assume to have valid scripts without checking them.\n-    std::optional<uint256> assumed_valid_block;\n+    std::optional<uint256> assumed_valid_block{};\n     //! If the tip is older than this, the node is considered to be in initial block download.\n     std::chrono::seconds max_tip_age{DEFAULT_MAX_TIP_AGE};\n };\n\n\n###\n\n", "completion": "refactor: Silence GCC Wmissing-field-initializers in ChainstateManagerOpts"}
{"prompt": " file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -136,6 +136,7 @@ BASE_SCRIPTS = [\n     # vv Tests less than 30s vv\n     'wallet_keypool_topup.py --legacy-wallet',\n     'wallet_keypool_topup.py --descriptors',\n+    'wallet_fast_rescan.py --descriptors',\n     'feature_fee_estimation.py',\n     'interface_zmq.py',\n     'rpc_invalid_address_message.py',\n\n---\n file path A: None | file path B: test/functional/wallet_fast_rescan.py\n\n@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test that fast rescan using block filters for descriptor wallets detects\n+   top-ups correctly and finds the same transactions than the slow variant.\"\"\"\n+import os\n+from typing import List\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_node import TestNode\n+from test_framework.util import assert_equal\n+from test_framework.wallet import MiniWallet\n+from test_framework.wallet_util import get_generate_key\n+\n+\n+KEYPOOL_SIZE = 100   # smaller than default size to speed-up test\n+NUM_DESCRIPTORS = 9  # number of descriptors (8 default ranged ones + 1 fixed non-ranged one)\n+NUM_BLOCKS = 6       # number of blocks to mine\n+\n+\n+class WalletFastRescanTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[f'-keypool={KEYPOOL_SIZE}', '-blockfilterindex=1']]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    def get_wallet_txids(self, node: TestNode, wallet_name: str) -> List[str]:\n+        w = node.get_wallet_rpc(wallet_name)\n+        txs = w.listtransactions('*', 1000000)\n+        return [tx['txid'] for tx in txs]\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        wallet = MiniWallet(node)\n+        wallet.rescan_utxos()\n+\n+        self.log.info(\"Create descriptor wallet with backup\")\n+        WALLET_BACKUP_FILENAME = os.path.join(node.datadir, 'wallet.bak')\n+        node.createwallet(wallet_name='topup_test', descriptors=True)\n+        w = node.get_wallet_rpc('topup_test')\n+        fixed_key = get_generate_key()\n+        print(w.importdescriptors([{\"desc\": descsum_create(f\"wpkh({fixed_key.privkey})\"), \"timestamp\": \"now\"}]))\n+        descriptors = w.listdescriptors()['descriptors']\n+        assert_equal(len(descriptors), NUM_DESCRIPTORS)\n+        w.backupwallet(WALLET_BACKUP_FILENAME)\n+\n+        self.log.info(f\"Create txs sending to end range address of each descriptor, triggering top-ups\")\n+        for i in range(NUM_BLOCKS):\n+            self.log.info(f\"Block {i+1}/{NUM_BLOCKS}\")\n+            for desc_info in w.listdescriptors()['descriptors']:\n+                if 'range' in desc_info:\n+                    start_range, end_range = desc_info['range']\n+                    addr = w.deriveaddresses(desc_info['desc'], [end_range, end_range])[0]\n+                    spk = bytes.fromhex(w.getaddressinfo(addr)['scriptPubKey'])\n+                    self.log.info(f\"-> range [{start_range},{end_range}], last address {addr}\")\n+                else:\n+                    spk = bytes.fromhex(fixed_key.p2wpkh_script)\n+                    self.log.info(f\"-> fixed non-range descriptor address {fixed_key.p2wpkh_addr}\")\n+                wallet.send_to(from_node=node, scriptPubKey=spk, amount=10000)\n+            self.generate(node, 1)\n+\n+        self.log.info(\"Import wallet backup with block filter index\")\n+        with node.assert_debug_log(['fast variant using block filters']):\n+            node.restorewallet('rescan_fast', WALLET_BACKUP_FILENAME)\n+        txids_fast = self.get_wallet_txids(node, 'rescan_fast')\n+\n+        self.log.info(\"Import non-active descriptors with block filter index\")\n+        node.createwallet(wallet_name='rescan_fast_nonactive', descriptors=True, disable_private_keys=True, blank=True)\n+        with node.assert_debug_log(['fast variant using block filters']):\n+            w = node.get_wallet_rpc('rescan_fast_nonactive')\n+            w.importdescriptors([{\"desc\": descriptor['desc'], \"timestamp\": 0} for descriptor in descriptors])\n+        txids_fast_nonactive = self.get_wallet_txids(node, 'rescan_fast_nonactive')\n+\n+        self.restart_node(0, [f'-keypool={KEYPOOL_SIZE}', '-blockfilterindex=0'])\n+        self.log.info(\"Import wallet backup w/o block filter index\")\n+        with node.assert_debug_log(['slow variant inspecting all blocks']):\n+            node.restorewallet(\"rescan_slow\", WALLET_BACKUP_FILENAME)\n+        txids_slow = self.get_wallet_txids(node, 'rescan_slow')\n+\n+        self.log.info(\"Import non-active descriptors w/o block filter index\")\n+        node.createwallet(wallet_name='rescan_slow_nonactive', descriptors=True, disable_private_keys=True, blank=True)\n+        with node.assert_debug_log(['slow variant inspecting all blocks']):\n+            w = node.get_wallet_rpc('rescan_slow_nonactive')\n+            w.importdescriptors([{\"desc\": descriptor['desc'], \"timestamp\": 0} for descriptor in descriptors])\n+        txids_slow_nonactive = self.get_wallet_txids(node, 'rescan_slow_nonactive')\n+\n+        self.log.info(\"Verify that all rescans found the same txs in slow and fast variants\")\n+        assert_equal(len(txids_slow), NUM_DESCRIPTORS * NUM_BLOCKS)\n+        assert_equal(len(txids_fast), NUM_DESCRIPTORS * NUM_BLOCKS)\n+        assert_equal(len(txids_slow_nonactive), NUM_DESCRIPTORS * NUM_BLOCKS)\n+        assert_equal(len(txids_fast_nonactive), NUM_DESCRIPTORS * NUM_BLOCKS)\n+        assert_equal(sorted(txids_slow), sorted(txids_fast))\n+        assert_equal(sorted(txids_slow_nonactive), sorted(txids_fast_nonactive))\n+\n+\n+if __name__ == '__main__':\n+    WalletFastRescanTest().main()\n\n\n###\n\n", "completion": "test: add test for fast rescan using block filters (top-up detection)"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -312,16 +312,16 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_mac.sh\"\n \n task:\n-  name: 'macOS 12 native x86_64 [gui, system sqlite] [no depends]'\n+  name: 'macOS 13 native arm64 [gui, sqlite only] [no depends]'\n   macos_instance:\n     # Use latest image, but hardcode version to avoid silent upgrades (and breaks)\n-    image: monterey-xcode-13.3  # https://cirrus-ci.org/guide/macOS\n+    image: ghcr.io/cirruslabs/macos-ventura-xcode:14.1  # https://cirrus-ci.org/guide/macOS\n   << : *MACOS_NATIVE_TASK_TEMPLATE\n   env:\n     << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     CI_USE_APT_INSTALL: \"no\"\n     PACKAGE_MANAGER_INSTALL: \"echo\"  # Nothing to do\n-    FILE_ENV: \"./ci/test/00_setup_env_mac_native_x86_64.sh\"\n+    FILE_ENV: \"./ci/test/00_setup_env_mac_native_arm64.sh\"\n \n task:\n   name: 'ARM64 Android APK [focal]'\n\n---\n file path A: ci/test/00_setup_env_mac_native_x86_64.sh | file path B: ci/test/00_setup_env_mac_native_arm64.sh\n\n@@ -6,12 +6,11 @@\n \n export LC_ALL=C.UTF-8\n \n-export HOST=x86_64-apple-darwin\n-export PIP_PACKAGES=\"zmq lief\"\n+export HOST=arm64-apple-darwin\n+export PIP_PACKAGES=\"zmq\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--with-gui --enable-reduce-exports\"\n+export BITCOIN_CONFIG=\"--with-gui --with-miniupnpc --with-natpmp --enable-reduce-exports\"\n export CI_OS_NAME=\"macos\"\n export NO_DEPENDS=1\n export OSX_SDK=\"\"\n export CCACHE_SIZE=300M\n-export RUN_SECURITY_TESTS=\"true\"\n\n\n###\n\n", "completion": "ci: Use `macos-ventura-xcode:14.1` image for \"macOS native\" task"}
{"prompt": " file path A: test/functional/p2p_sendtxrcncl.py | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -107,29 +107,33 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.send_message(create_sendtxrcncl_msg())\n         self.wait_until(lambda : \"sendtxrcncl\" in self.nodes[0].getpeerinfo()[-1][\"bytesrecv_per_msg\"])\n         self.log.info('second SENDTXRCNCL triggers a disconnect')\n-        peer.send_message(create_sendtxrcncl_msg())\n-        peer.wait_for_disconnect()\n+        with self.nodes[0].assert_debug_log([\"(sendtxrcncl received from already registered peer); disconnecting\"]):\n+            peer.send_message(create_sendtxrcncl_msg())\n+            peer.wait_for_disconnect()\n \n         self.log.info('SENDTXRCNCL with initiator=responder=0 triggers a disconnect')\n         sendtxrcncl_no_role = create_sendtxrcncl_msg()\n         sendtxrcncl_no_role.initiator = False\n         sendtxrcncl_no_role.responder = False\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n-        peer.send_message(sendtxrcncl_no_role)\n-        peer.wait_for_disconnect()\n+        with self.nodes[0].assert_debug_log([\"txreconciliation protocol violation\"]):\n+            peer.send_message(sendtxrcncl_no_role)\n+            peer.wait_for_disconnect()\n \n         self.log.info('SENDTXRCNCL with initiator=0 and responder=1 from inbound triggers a disconnect')\n         sendtxrcncl_wrong_role = create_sendtxrcncl_msg(initiator=False)\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n-        peer.send_message(sendtxrcncl_wrong_role)\n-        peer.wait_for_disconnect()\n+        with self.nodes[0].assert_debug_log([\"txreconciliation protocol violation\"]):\n+            peer.send_message(sendtxrcncl_wrong_role)\n+            peer.wait_for_disconnect()\n \n         self.log.info('SENDTXRCNCL with version=0 triggers a disconnect')\n         sendtxrcncl_low_version = create_sendtxrcncl_msg()\n         sendtxrcncl_low_version.version = 0\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n-        peer.send_message(sendtxrcncl_low_version)\n-        peer.wait_for_disconnect()\n+        with self.nodes[0].assert_debug_log([\"txreconciliation protocol violation\"]):\n+            peer.send_message(sendtxrcncl_low_version)\n+            peer.wait_for_disconnect()\n \n         self.log.info('sending SENDTXRCNCL after sending VERACK triggers a disconnect')\n         peer = self.nodes[0].add_p2p_connection(P2PInterface())\n@@ -162,8 +166,9 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.log.info('SENDTXRCNCL if block-relay-only triggers a disconnect')\n         peer = self.nodes[0].add_outbound_p2p_connection(\n             PeerNoVerack(), wait_for_verack=False, p2p_idx=3, connection_type=\"block-relay-only\")\n-        peer.send_message(create_sendtxrcncl_msg(initiator=False))\n-        peer.wait_for_disconnect()\n+        with self.nodes[0].assert_debug_log([\"we indicated no tx relay; disconnecting\"]):\n+            peer.send_message(create_sendtxrcncl_msg(initiator=False))\n+            peer.wait_for_disconnect()\n \n         self.log.info('SENDTXRCNCL with initiator=1 and responder=0 from outbound triggers a disconnect')\n         sendtxrcncl_wrong_role = create_sendtxrcncl_msg(initiator=True)\n\n\n###\n\n", "completion": "test: Check debug log as well in p2p_sendtxrcncl.py"}
{"prompt": " file path A: test/functional/p2p_sendtxrcncl.py | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -168,9 +168,10 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.log.info('SENDTXRCNCL with initiator=1 and responder=0 from outbound triggers a disconnect')\n         sendtxrcncl_wrong_role = create_sendtxrcncl_msg(initiator=True)\n         peer = self.nodes[0].add_outbound_p2p_connection(\n-            P2PInterface(), wait_for_verack=False, p2p_idx=4, connection_type=\"outbound-full-relay\")\n-        peer.send_message(sendtxrcncl_wrong_role)\n-        peer.wait_for_disconnect()\n+            PeerNoVerack(), wait_for_verack=False, p2p_idx=4, connection_type=\"outbound-full-relay\")\n+        with self.nodes[0].assert_debug_log([\"txreconciliation protocol violation\"]):\n+            peer.send_message(sendtxrcncl_wrong_role)\n+            peer.wait_for_disconnect()\n \n         self.log.info('SENDTXRCNCL not sent if -txreconciliation flag is not set')\n         self.restart_node(0, [])\n\n\n###\n\n", "completion": "test: Check correct disconnect reason in p2p_sendtxrcncl.py"}
{"prompt": " file path A: ci/test/04_install.sh | file path B: ci/test/04_install.sh\n\n@@ -78,7 +78,7 @@ if [ -n \"$PIP_PACKAGES\" ]; then\n   if [ \"$CI_OS_NAME\" == \"macos\" ]; then\n     sudo -H pip3 install --upgrade pip\n     # shellcheck disable=SC2086\n-    IN_GETOPT_BIN=\"/usr/local/opt/gnu-getopt/bin/getopt\" ${CI_RETRY_EXE} pip3 install --user $PIP_PACKAGES\n+    IN_GETOPT_BIN=\"$(brew --prefix gnu-getopt)/bin/getopt\" ${CI_RETRY_EXE} pip3 install --user $PIP_PACKAGES\n   else\n     # shellcheck disable=SC2086\n     ${CI_RETRY_EXE} CI_EXEC pip3 install --user $PIP_PACKAGES\n\n\n###\n\n", "completion": "ci: Make `getopt` path architecture agnostic"}
{"prompt": " file path A: test/functional/p2p_sendtxrcncl.py | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -132,12 +132,10 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.wait_for_disconnect()\n \n         self.log.info('sending SENDTXRCNCL after sending VERACK triggers a disconnect')\n-        # We use PeerNoVerack even though verack is sent right after, to make sure it was actually\n-        # sent before sendtxrcncl is sent.\n-        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n-        peer.send_and_ping(msg_verack())\n-        peer.send_message(create_sendtxrcncl_msg())\n-        peer.wait_for_disconnect()\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n+        with self.nodes[0].assert_debug_log([\"sendtxrcncl received after verack\"]):\n+            peer.send_message(create_sendtxrcncl_msg())\n+            peer.wait_for_disconnect()\n \n         self.log.info('SENDTXRCNCL without WTXIDRELAY is ignored (recon state is erased after VERACK)')\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(wtxidrelay=False), send_version=True, wait_for_verack=False)\n\n\n###\n\n", "completion": "test: Fix intermittent issue in p2p_sendtxrcncl.py"}
{"prompt": " file path A: src/net_processing.cpp | file path B: src/net_processing.cpp\n\n@@ -657,9 +657,9 @@ private:\n      */\n     bool MaybeSendGetHeaders(CNode& pfrom, const CBlockLocator& locator, Peer& peer) EXCLUSIVE_LOCKS_REQUIRED(g_msgproc_mutex);\n     /** Potentially fetch blocks from this peer upon receipt of a new headers tip */\n-    void HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, const CBlockIndex* pindexLast);\n+    void HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, const CBlockIndex& last_header);\n     /** Update peer state based on received headers message */\n-    void UpdatePeerStateForReceivedHeaders(CNode& pfrom, const CBlockIndex *pindexLast, bool received_new_header, bool may_have_more_headers);\n+    void UpdatePeerStateForReceivedHeaders(CNode& pfrom, const CBlockIndex& last_header, bool received_new_header, bool may_have_more_headers);\n \n     void SendBlockTransactions(CNode& pfrom, Peer& peer, const CBlock& block, const BlockTransactionsRequest& req);\n \n@@ -2605,22 +2605,21 @@ bool PeerManagerImpl::MaybeSendGetHeaders(CNode& pfrom, const CBlockLocator& loc\n }\n \n /*\n- * Given a new headers tip ending in pindexLast, potentially request blocks towards that tip.\n+ * Given a new headers tip ending in last_header, potentially request blocks towards that tip.\n  * We require that the given tip have at least as much work as our tip, and for\n  * our current tip to be \"close to synced\" (see CanDirectFetch()).\n  */\n-void PeerManagerImpl::HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, const CBlockIndex* pindexLast)\n+void PeerManagerImpl::HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, const CBlockIndex& last_header)\n {\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n \n     LOCK(cs_main);\n     CNodeState *nodestate = State(pfrom.GetId());\n \n-    if (CanDirectFetch() && pindexLast->IsValid(BLOCK_VALID_TREE) && m_chainman.ActiveChain().Tip()->nChainWork <= pindexLast->nChainWork) {\n-\n+    if (CanDirectFetch() && last_header.IsValid(BLOCK_VALID_TREE) && m_chainman.ActiveChain().Tip()->nChainWork <= last_header.nChainWork) {\n         std::vector<const CBlockIndex*> vToFetch;\n-        const CBlockIndex *pindexWalk = pindexLast;\n-        // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n+        const CBlockIndex* pindexWalk{&last_header};\n+        // Calculate all the blocks we'd need to switch to last_header, up to a limit.\n         while (pindexWalk && !m_chainman.ActiveChain().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                     !IsBlockRequested(pindexWalk->GetBlockHash()) &&\n@@ -2636,8 +2635,8 @@ void PeerManagerImpl::HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, c\n         // direct fetch and rely on parallel download instead.\n         if (!m_chainman.ActiveChain().Contains(pindexWalk)) {\n             LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n-                    pindexLast->GetBlockHash().ToString(),\n-                    pindexLast->nHeight);\n+                     last_header.GetBlockHash().ToString(),\n+                     last_header.nHeight);\n         } else {\n             std::vector<CInv> vGetData;\n             // Download as much as possible, from earliest to latest.\n@@ -2654,14 +2653,15 @@ void PeerManagerImpl::HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, c\n             }\n             if (vGetData.size() > 1) {\n                 LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n-                        pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n+                         last_header.GetBlockHash().ToString(),\n+                         last_header.nHeight);\n             }\n             if (vGetData.size() > 0) {\n                 if (!m_ignore_incoming_txs &&\n                         nodestate->m_provides_cmpctblocks &&\n                         vGetData.size() == 1 &&\n                         mapBlocksInFlight.size() == 1 &&\n-                        pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                        last_header.pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                     // In any case, we want to download using a compact block, not a regular one\n                     vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                 }\n@@ -2672,12 +2672,12 @@ void PeerManagerImpl::HeadersDirectFetchBlocks(CNode& pfrom, const Peer& peer, c\n }\n \n /**\n- * Given receipt of headers from a peer ending in pindexLast, along with\n+ * Given receipt of headers from a peer ending in last_header, along with\n  * whether that header was new and whether the headers message was full,\n  * update the state we keep for the peer.\n  */\n void PeerManagerImpl::UpdatePeerStateForReceivedHeaders(CNode& pfrom,\n-        const CBlockIndex *pindexLast, bool received_new_header, bool may_have_more_headers)\n+        const CBlockIndex& last_header, bool received_new_header, bool may_have_more_headers)\n {\n     LOCK(cs_main);\n     CNodeState *nodestate = State(pfrom.GetId());\n@@ -2686,14 +2686,13 @@ void PeerManagerImpl::UpdatePeerStateForReceivedHeaders(CNode& pfrom,\n     }\n     nodestate->nUnconnectingHeaders = 0;\n \n-    assert(pindexLast);\n-    UpdateBlockAvailability(pfrom.GetId(), pindexLast->GetBlockHash());\n+    UpdateBlockAvailability(pfrom.GetId(), last_header.GetBlockHash());\n \n     // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n     // because it is set in UpdateBlockAvailability. Some nullptr checks\n     // are still present, however, as belt-and-suspenders.\n \n-    if (received_new_header && pindexLast->nChainWork > m_chainman.ActiveChain().Tip()->nChainWork) {\n+    if (received_new_header && last_header.nChainWork > m_chainman.ActiveChain().Tip()->nChainWork) {\n         nodestate->m_last_block_announcement = GetTime();\n     }\n \n@@ -2859,7 +2858,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n             return;\n         }\n     }\n-    Assume(pindexLast);\n+    assert(pindexLast);\n \n     // Consider fetching more headers if we are not using our headers-sync mechanism.\n     if (nCount == MAX_HEADERS_RESULTS && !have_headers_sync) {\n@@ -2870,10 +2869,10 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n         }\n     }\n \n-    UpdatePeerStateForReceivedHeaders(pfrom, pindexLast, received_new_header, nCount == MAX_HEADERS_RESULTS);\n+    UpdatePeerStateForReceivedHeaders(pfrom, *pindexLast, received_new_header, nCount == MAX_HEADERS_RESULTS);\n \n     // Consider immediately downloading blocks.\n-    HeadersDirectFetchBlocks(pfrom, peer, pindexLast);\n+    HeadersDirectFetchBlocks(pfrom, peer, *pindexLast);\n \n     return;\n }\n\n\n###\n\n", "completion": "refactor: Pass reference to last header, not pointer"}
{"prompt": " file path A: src/test/system_tests.cpp | file path B: src/test/system_tests.cpp\n\n@@ -51,15 +51,9 @@ BOOST_AUTO_TEST_CASE(run_command)\n     }\n     {\n         // An invalid command is handled by Boost\n-#ifdef WIN32\n-        const std::string expected{\"The system cannot find the file specified.\"};\n-#else\n-        const std::string expected{\"No such file or directory\"};\n-#endif\n         BOOST_CHECK_EXCEPTION(RunCommandParseJSON(\"invalid_command\"), boost::process::process_error, [&](const boost::process::process_error& e) {\n-            const std::string what(e.what());\n-            BOOST_CHECK(what.find(\"RunCommandParseJSON error:\") == std::string::npos);\n-            BOOST_CHECK(what.find(expected) != std::string::npos);\n+            BOOST_CHECK(std::string(e.what()).find(\"RunCommandParseJSON error:\") == std::string::npos);\n+            BOOST_CHECK_EQUAL(e.code().value(), 2);\n             return true;\n         });\n     }\n\n\n###\n\n", "completion": "test: Make `system_tests/run_command` locale agnostic"}
{"prompt": " file path A: test/functional/data/rpc_getblockstats.json | file path B: test/functional/data/rpc_getblockstats.json\n\n@@ -102,8 +102,8 @@\n     \"00000020f44e7a48b9f221af95f3295c8dcefc5358934a68dc79e2933dc0794b350cad0a90fad2cd50b41d4ef45e76c2a456b98c180632bb4b44e0cd18ce90679fe54e552b4ae75affff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401630101ffffffff0200f2052a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n     \"0000002087454276cce83f4d19e0120f6e9728ac5905f7adaf6b27e3f5bbe43ab823f85db7d1f44666531483df3d67c15f2c231718ad93b63b851dce5ff4c4a67f524ffa2b4ae75affff7f200100000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401640101ffffffff0200f2052a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n     \"000000202cdc3e99f07a80252dd6097faa0eddf3f2dde5ae390610e0bca94ecc25931551d31fceb8fe0a682f6017ca3dbb582f3a2f06e5d99ec99c42c8a744dd4c9216b82b4ae75affff7f200300000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401650101ffffffff0200f2052a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n-    \"000000209b3ace9bd510918d20e87518c0cf5976cab3e28cc7af41259a89c6dd7668a32922808b8a082be71bcd6152cb8fd223650b5579a41344ba749e4d17b9bf211a9e2b4ae75affff7f200000000002020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401660101ffffffff026c03062a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9edb85d8f3c122c43a72f1e0dd122c8f7af040aa0b0a46001621110fb37818021510120000000000000000000000000000000000000000000000000000000000000000000000000020000000128394022bf44bff30d7399cb5a16e3b94fed67dc174c2e1d77df91bad5a51cb3000000006a47304402201c16d06a5c4353168b3881071aea7d1eb4d88eedfea53a9d6af9abb56da9060002205abf3ae535f1f1b5cfe8ba955535c2b20ac003e7d7720c5b7d2640ac2a04d19001210227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3ffeffffff0294b89a3b000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac00286bee0000000017a91452bab4f229415d0dc5c6d30b162f93a1a0cac5958765000000\",\n-    \"000000200fa168b50a79ad24378a6b0f96e4c9f4ccb657a2663320d5fc1efd8ee7caa10ab42a31c444f2153387530a0979d4dc3dcc134b394c821227b8abff930c03c8412b4ae75affff7f200200000004020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401670101ffffffff02e015072a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9ed20376d4bc90f9c689850eec3603cda658ba6295241730473ceb0e970b8d594150120000000000000000000000000000000000000000000000000000000000000000000000000020000000191e549a6cc852bbf1d3f11144b1a34079f64305e6971d2e685d2b40cd386e8a6000000006a47304402200bf62021c0a9a47ced8eba1e0998f5c71b2950763198d83ad284bd791241dbb00220446a05b7c35e7458924de88a8dcccab1ec6a106aa005345e55b482d8eb66337301210227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3ffeffffff02acdbf405000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac94d7a4350000000017a914dfa6f0b17d2c64962c94203e744a9d4179ed22c18766000000020000000112d2f07672102dc6f099c4be308f598e4c4da1a7e0cb462ae14f0444525a1332000000006a47304402200a6a2f544f3f9d299608a7c745e2326de176fb1cac03ae3e74943f4250b8896e02205023a5b4faff99865bf91f1263605a502c723628be9240c0b7bec81d2ed106f101210227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3ffeffffff0200ca9a3b000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac94166bee0000000017a914152cc82f7944f5c416de7dbffb052f7081765d7987660000000200000000010191e549a6cc852bbf1d3f11144b1a34079f64305e6971d2e685d2b40cd386e8a601000000171600147cc872ad7350c37fecab9c4c6d9f08aceb53bdb8feffffff02005ed0b20000000017a914aab1c8c53fe62e283a53efa28097709f4f2ed37b87e0bc9a3b000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0247304402201b4476f238ed5d515bfcd6927d0d008a4993770763eca73e3ee66f69971831d902200f5215a6dfd90391dd63462cfdf69804fe31224c309ec9c38d33a04dce71c0ee0121028c9d2955a95301b699db62e97d54bf0a91feb44e5cd94bbf5b62f1df57fb643966000000\"\n+    \"000000209b3ace9bd510918d20e87518c0cf5976cab3e28cc7af41259a89c6dd7668a329f03ef4716ad5d88bccfd71088bf2ec3eb5b32e0ff60f35f9becd73052bfa8af12b4ae75affff7f200000000002020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401660101ffffffff025803062a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9edb11910e4e0ee6ee6d6bad42736999d1eba649243dc781438e5ef845c7227aaad0120000000000000000000000000000000000000000000000000000000000000000000000000020000000128394022bf44bff30d7399cb5a16e3b94fed67dc174c2e1d77df91bad5a51cb3000000006a47304402200650c6c50bd4952ca13b7aa37d458a36628434bbb968701063cdd36d0725e36c02202e059ccf7a4a049de028c4f140e543baa7e69ea3663e3d1fdfbc8ba7247e82f901210227d85ba011276cf25b51df6a188b75e604b38770a462b2d0e9fb2fc839ef5d3ffeffffff02a8b89a3b000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac00286bee0000000016001423838e991caedd69289d9dac88ca423cca683a2265000000\",\n+    \"0000002061597bf3305ee2334b5d7fec136c2064b69d14955b50cd0b81f49ac33d88e506d80731ce60c2f275d29539a4d04c7e8c72aa4ade3c9baec24881a581fc524c6a2b4ae75affff7f200000000005020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0401670101ffffffff023840072a010000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac0000000000000000266a24aa21a9ed89a3c65f40921b14168368cf4775a710ad17b613cedcff001f1f1ca3c863cc11012000000000000000000000000000000000000000000000000000000000000000000000000002000000000101bb475ac72ba1a45a96be584a689d6d0ace820d9587b0db53dc40a15555b9be770100000000feffffff02c0be9a3b000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac005ed0b200000000160014a57f6871c70569e0543322614c5c85438b796a900247304402207893b5466cdbf9cdedcc73fb8e10e01c4dd9aac4345031ef0c35d91e82ff5fd602207f0e1d7e4270a532060fd1e6ad7881d18acb173fd4fd1d61f3c8ff6707bdb972012103bb4c79ca594b19bbec7ee6302af0ef4191345fa7f03a30ed4e042aeed680924b6600000002000000000101e6a996cbac10b2d6b2bb2796a4ebf639ee21b136e06c7d8c6bc62b7cb4a311870100000000feffffff0200ca9a3b000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88acc088357700000000160014c48ea35298422796eb75ee9a04ebada66780083902473044022062963ff9f1f0d2c885060c083b97ddd67bd6e8a7daaed6578a62c1f905fd31a6022001836efe75bbce64d29700f5568aed78ce68f098ef0b8efdad0679e2f6c0ceb5012102228c4d459ce647b63b2681597a6e8391e4b5afab147f90747184a0893e4934c26600000002000000000101c654a35d86b4c3112ae9ec75e3bc271e0b8f928620386fdaf9517e8a9b511d850100000000feffffff024038f505000000001976a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88acc0a73f7100000000160014cb1049e20cebfe756d657af0d47a3357c1db3c9702473044022024728eb27e884d08b2b95e670fd58c0e10106a18bc9e01f753f9ae474aa2c95e02201d5abe91302b373507dce1fd2f4b95ddc36e21d23eda6c476cc9efea80338ef90121036be02fd68622ce6740f0d028059af96a310c23c675f044732171df6f64f0fcb2660000000200000000010135c4ee1a780d8279ea7c79d3ad6fbb39315a13e6b51dd51f49db6e2f4796bada0100000000feffffff020000000000000000036a0121c8183f71000000001600147ea4d830ca77c20a23155a176a1472613dc4e7840247304402202db3527431e09ca8034d207134d79fc063939bd402286dd8b3872de3b2a746b402207faae5fb8838e6877822a9209fe2e81d4be4a69ce8164215e03f9b92d75e94f90121024d456d37df6f3436ee1685b78d90d2d24c4dd8c602d5f41405fe7f449b43415f00000000\"\n   ],\n   \"mocktime\": 1525107225,\n   \"stats\": [\n@@ -147,10 +147,10 @@\n       \"utxo_size_inc_actual\": 75\n     },\n     {\n-      \"avgfee\": 4460,\n+      \"avgfee\": 4440,\n       \"avgfeerate\": 20,\n-      \"avgtxsize\": 223,\n-      \"blockhash\": \"0aa1cae78efd1efcd5203366a257b6ccf4c9e4960f6b8a3724ad790ab568a10f\",\n+      \"avgtxsize\": 222,\n+      \"blockhash\": \"06e5883dc39af4810bcd505b95149db664206c13ec7f5d4b33e25e30f37b5961\",\n       \"feerate_percentiles\": [\n         20,\n         20,\n@@ -160,69 +160,69 @@\n       ],\n       \"height\": 102,\n       \"ins\": 1,\n-      \"maxfee\": 4460,\n+      \"maxfee\": 4440,\n       \"maxfeerate\": 20,\n-      \"maxtxsize\": 223,\n-      \"medianfee\": 4460,\n+      \"maxtxsize\": 222,\n+      \"medianfee\": 4440,\n       \"mediantime\": 1525107242,\n-      \"mediantxsize\": 223,\n-      \"minfee\": 4460,\n+      \"mediantxsize\": 222,\n+      \"minfee\": 4440,\n       \"minfeerate\": 20,\n-      \"mintxsize\": 223,\n+      \"mintxsize\": 222,\n       \"outs\": 4,\n       \"subsidy\": 5000000000,\n       \"swtotal_size\": 0,\n       \"swtotal_weight\": 0,\n       \"swtxs\": 0,\n       \"time\": 1525107243,\n-      \"total_out\": 4999995540,\n-      \"total_size\": 223,\n-      \"total_weight\": 892,\n-      \"totalfee\": 4460,\n+      \"total_out\": 4999995560,\n+      \"total_size\": 222,\n+      \"total_weight\": 888,\n+      \"totalfee\": 4440,\n       \"txs\": 2,\n       \"utxo_increase\": 3,\n       \"utxo_increase_actual\": 2,\n-      \"utxo_size_inc\": 236,\n-      \"utxo_size_inc_actual\": 148\n+      \"utxo_size_inc\": 235,\n+      \"utxo_size_inc_actual\": 147\n     },\n     {\n-      \"avgfee\": 24906,\n-      \"avgfeerate\": 121,\n-      \"avgtxsize\": 231,\n-      \"blockhash\": \"53e416e2538bc783c42a7aea566e884321afed893e9e58cf356d6429759dfa46\",\n+      \"avgfee\": 21390,\n+      \"avgfeerate\": 155,\n+      \"avgtxsize\": 219,\n+      \"blockhash\": \"7474991c2ae3c94c4813d75b4c752028304b773dd4dce8d460dfa2d1e7b542a3\",\n       \"feerate_percentiles\": [\n         20,\n         20,\n         20,\n-        300,\n-        300\n+        301,\n+        301\n       ],\n       \"height\": 103,\n-      \"ins\": 3,\n-      \"maxfee\": 66900,\n-      \"maxfeerate\": 300,\n-      \"maxtxsize\": 249,\n-      \"medianfee\": 4460,\n+      \"ins\": 4,\n+      \"maxfee\": 43200,\n+      \"maxfeerate\": 301,\n+      \"maxtxsize\": 225,\n+      \"medianfee\": 19740,\n       \"mediantime\": 1525107243,\n-      \"mediantxsize\": 223,\n-      \"minfee\": 3360,\n+      \"mediantxsize\": 225,\n+      \"minfee\": 2880,\n       \"minfeerate\": 20,\n-      \"mintxsize\": 223,\n-      \"outs\": 8,\n+      \"mintxsize\": 203,\n+      \"outs\": 10,\n       \"subsidy\": 5000000000,\n-      \"swtotal_size\": 249,\n-      \"swtotal_weight\": 669,\n-      \"swtxs\": 1,\n+      \"swtotal_size\": 878,\n+      \"swtotal_weight\": 2204,\n+      \"swtxs\": 4,\n       \"time\": 1525107243,\n-      \"total_out\": 9999920820,\n-      \"total_size\": 695,\n-      \"total_weight\": 2453,\n-      \"totalfee\": 74720,\n-      \"txs\": 4,\n-      \"utxo_increase\": 5,\n-      \"utxo_size_inc\": 384,\n+      \"total_out\": 10899908680,\n+      \"total_size\": 878,\n+      \"total_weight\": 2204,\n+      \"totalfee\": 85560,\n+      \"txs\": 5,\n+      \"utxo_increase\": 6,\n       \"utxo_increase_actual\": 4,\n-      \"utxo_size_inc_actual\": 296\n+      \"utxo_size_inc\": 441,\n+      \"utxo_size_inc_actual\": 300\n     }\n   ]\n-}\n+}\n\\ No newline at end of file\n\n---\n file path A: test/functional/rpc_getblockstats.py | file path B: test/functional/rpc_getblockstats.py\n\n@@ -57,6 +57,8 @@ class GetblockstatsTest(BitcoinTestFramework):\n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=False)\n         self.nodes[0].settxfee(amount=0.003)\n         self.nodes[0].sendtoaddress(address=address, amount=1, subtractfeefromamount=True)\n+        # Send to OP_RETURN output to test its exclusion from statistics\n+        self.nodes[0].send(outputs={\"data\": \"21\"})\n         self.sync_all()\n         self.generate(self.nodes[0], 1)\n \n@@ -173,6 +175,12 @@ class GetblockstatsTest(BitcoinTestFramework):\n         assert_equal(genesis_stats[\"utxo_increase_actual\"], 0)\n         assert_equal(genesis_stats[\"utxo_size_inc_actual\"], 0)\n \n+        self.log.info('Test tip including OP_RETURN')\n+        tip_stats = self.nodes[0].getblockstats(tip)\n+        assert_equal(tip_stats[\"utxo_increase\"], 6)\n+        assert_equal(tip_stats[\"utxo_size_inc\"], 441)\n+        assert_equal(tip_stats[\"utxo_increase_actual\"], 4)\n+        assert_equal(tip_stats[\"utxo_size_inc_actual\"], 300)\n \n if __name__ == '__main__':\n     GetblockstatsTest().main()\n\n\n###\n\n", "completion": "test: Test exclusion of OP_RETURN from getblockstats"}
{"prompt": " file path A: test/functional/rpc_getblockstats.py | file path B: test/functional/rpc_getblockstats.py\n\n@@ -43,6 +43,10 @@ class GetblockstatsTest(BitcoinTestFramework):\n     def generate_test_data(self, filename):\n         mocktime = 1525107225\n         self.nodes[0].setmocktime(mocktime)\n+        self.nodes[0].createwallet(wallet_name='test')\n+        privkey = self.nodes[0].get_deterministic_priv_key().key\n+        self.nodes[0].importprivkey(privkey)\n+\n         self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         address = self.nodes[0].get_deterministic_priv_key().address\n\n\n###\n\n", "completion": "test: Fix getblockstats test data generator"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -933,7 +933,6 @@ libbitcoinkernel_la_SOURCES = \\\n   support/cleanse.cpp \\\n   support/lockedpool.cpp \\\n   sync.cpp \\\n-  threadinterrupt.cpp \\\n   txdb.cpp \\\n   txmempool.cpp \\\n   uint256.cpp \\\n\n\n###\n\n", "completion": "build: remove threadinterrupt from libbitcoinkernel"}
{"prompt": " file path A: test/functional/wallet_sendall.py | file path B: test/functional/wallet_sendall.py\n\n@@ -221,6 +221,11 @@ class SendallTest(BitcoinTestFramework):\n         self.add_utxos([16, 5])\n         spent_utxo = self.wallet.listunspent()[0]\n \n+        # fails on out of bounds vout\n+        assert_raises_rpc_error(-8,\n+                \"Input not found. UTXO ({}:{}) is not part of wallet.\".format(spent_utxo[\"txid\"], 1000),\n+                self.wallet.sendall, recipients=[self.remainder_target], options={\"inputs\": [{\"txid\": spent_utxo[\"txid\"], \"vout\": 1000}]})\n+\n         # fails on unconfirmed spent UTXO\n         self.wallet.sendall(recipients=[self.remainder_target])\n         assert_raises_rpc_error(-8,\n\n\n###\n\n", "completion": "test: Test for out of bounds vout in sendall"}
{"prompt": " file path A: test/functional/wallet_sendall.py | file path B: test/functional/wallet_sendall.py\n\n@@ -276,6 +276,33 @@ class SendallTest(BitcoinTestFramework):\n                 recipients=[self.remainder_target],\n                 fee_rate=100000)\n \n+    @cleanup\n+    def sendall_watchonly_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool in a watchonly wallet\")\n+        self.add_utxos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        self.nodes[0].createwallet(wallet_name=\"watching\", disable_private_keys=True)\n+        watchonly = self.nodes[0].get_wallet_rpc(\"watching\")\n+\n+        import_req = [{\n+            \"desc\": utxo[\"desc\"],\n+            \"timestamp\": 0,\n+        }]\n+        if self.options.descriptors:\n+            watchonly.importdescriptors(import_req)\n+        else:\n+            watchonly.importmulti(import_req)\n+\n+        sendall_tx_receipt = watchonly.sendall(recipients=[self.remainder_target], options={\"inputs\": [utxo]})\n+        psbt = sendall_tx_receipt[\"psbt\"]\n+        decoded = self.nodes[0].decodepsbt(psbt)\n+        assert_equal(len(decoded[\"inputs\"]), 1)\n+        assert_equal(len(decoded[\"outputs\"]), 1)\n+        assert_equal(decoded[\"tx\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(decoded[\"tx\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        assert_equal(decoded[\"tx\"][\"vout\"][0][\"scriptPubKey\"][\"address\"], self.remainder_target)\n+\n     # This tests needs to be the last one otherwise @cleanup will fail with \"Transaction too large\" error\n     def sendall_fails_with_transaction_too_large(self):\n         self.log.info(\"Test that sendall fails if resulting transaction is too large\")\n@@ -341,6 +368,9 @@ class SendallTest(BitcoinTestFramework):\n         # Sendall fails when providing a fee that is too high\n         self.sendall_fails_on_high_fee()\n \n+        # Sendall succeeds with watchonly wallets spending specific UTXOs\n+        self.sendall_watchonly_specific_inputs()\n+\n         # Sendall fails when many inputs result to too large transaction\n         self.sendall_fails_with_transaction_too_large()\n \n\n\n###\n\n", "completion": "test: Test that sendall works with watchonly spending specific utxos"}
{"prompt": " file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -373,8 +373,8 @@ endif\n if TARGET_WINDOWS\n else\n if ENABLE_BENCH\n-\t@echo \"Running bench/bench_bitcoin (one iteration sanity check)...\"\n-\t$(BENCH_BINARY) --sanity-check > /dev/null\n+\t@echo \"Running bench/bench_bitcoin (one iteration sanity check, only high priority)...\"\n+\t$(BENCH_BINARY) -sanity-check -priority-level=high > /dev/null\n endif\n endif\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n\n\n###\n\n", "completion": "build: only run high priority benchmarks in 'make check'"}
{"prompt": " file path A: test/functional/mining_basic.py | file path B: test/functional/mining_basic.py\n\n@@ -200,7 +200,7 @@ class MiningTest(BitcoinTestFramework):\n \n         self.log.info(\"getblocktemplate: Test bad timestamps\")\n         bad_block = copy.deepcopy(block)\n-        bad_block.nTime = 2**31 - 1\n+        bad_block.nTime = 2**32 - 1\n         assert_template(node, bad_block, 'time-too-new')\n         assert_submitblock(bad_block, 'time-too-new', 'time-too-new')\n         bad_block.nTime = 0\n\n---\n file path A: test/functional/rpc_blockchain.py | file path B: test/functional/rpc_blockchain.py\n\n@@ -89,6 +89,7 @@ class BlockchainTest(BitcoinTestFramework):\n         self._test_waitforblockheight()\n         self._test_getblock()\n         self._test_getdeploymentinfo()\n+        self._test_y2106()\n         assert self.nodes[0].verifychain(4, 0)\n \n     def mine_chain(self):\n@@ -255,6 +256,14 @@ class BlockchainTest(BitcoinTestFramework):\n         # calling with an explicit hash works\n         self.check_signalling_deploymentinfo_result(self.nodes[0].getdeploymentinfo(gbci207[\"bestblockhash\"]), gbci207[\"blocks\"], gbci207[\"bestblockhash\"], \"started\")\n \n+    def _test_y2106(self):\n+        self.log.info(\"Check that block timestamps work until year 2106\")\n+        self.generate(self.nodes[0], 8)[-1]\n+        time_2106 = 2**32 - 1\n+        self.nodes[0].setmocktime(time_2106)\n+        last = self.generate(self.nodes[0], 6)[-1]\n+        assert_equal(self.nodes[0].getblockheader(last)[\"mediantime\"], time_2106)\n+\n     def _test_getchaintxstats(self):\n         self.log.info(\"Test getchaintxstats\")\n \n\n\n###\n\n", "completion": "test: Test year 2106 block timestamps"}
{"prompt": " file path A: test/functional/rpc_scanblocks.py | file path B: test/functional/rpc_scanblocks.py\n\n@@ -3,6 +3,10 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the scanblocks RPC call.\"\"\"\n+from test_framework.blockfilter import (\n+    bip158_basic_element_hash,\n+    bip158_relevant_scriptpubkeys,\n+)\n from test_framework.messages import COIN\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -71,6 +75,28 @@ class ScanblocksTest(BitcoinTestFramework):\n         assert(blockhash in node.scanblocks(\n             \"start\", [{\"desc\": f\"pkh({parent_key}/*)\", \"range\": [0, 100]}], height)['relevant_blocks'])\n \n+        # check that false-positives are included in the result now; note that\n+        # finding a false-positive at runtime would take too long, hence we simply\n+        # use a pre-calculated one that collides with the regtest genesis block's\n+        # coinbase output and verify that their BIP158 ranged hashes match\n+        genesis_blockhash = node.getblockhash(0)\n+        genesis_spks = bip158_relevant_scriptpubkeys(node, genesis_blockhash)\n+        assert_equal(len(genesis_spks), 1)\n+        genesis_coinbase_spk = list(genesis_spks)[0]\n+        false_positive_spk = bytes.fromhex(\"001400000000000000000000000000000000000cadcb\")\n+\n+        genesis_coinbase_hash = bip158_basic_element_hash(genesis_coinbase_spk, 1, genesis_blockhash)\n+        false_positive_hash = bip158_basic_element_hash(false_positive_spk, 1, genesis_blockhash)\n+        assert_equal(genesis_coinbase_hash, false_positive_hash)\n+\n+        assert(genesis_blockhash in node.scanblocks(\n+            \"start\", [{\"desc\": f\"raw({genesis_coinbase_spk.hex()})\"}], 0, 0)['relevant_blocks'])\n+        assert(genesis_blockhash in node.scanblocks(\n+            \"start\", [{\"desc\": f\"raw({false_positive_spk.hex()})\"}], 0, 0)['relevant_blocks'])\n+\n+        # TODO: after an \"accurate\" mode for scanblocks is implemented (e.g. PR #26325)\n+        # check here that it filters out the false-positive\n+\n         # test node with disabled blockfilterindex\n         assert_raises_rpc_error(-1, \"Index is not enabled for filtertype basic\",\n                                 self.nodes[1].scanblocks, \"start\", [f\"addr({addr_1})\"])\n\n\n###\n\n", "completion": "test: check for false-positives in rpc_scanblocks.py"}
{"prompt": " file path A: None | file path B: test/functional/test_framework/blockfilter.py\n\n@@ -0,0 +1,49 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Helper routines relevant for compact block filters (BIP158).\n+\"\"\"\n+from .siphash import siphash\n+\n+\n+def bip158_basic_element_hash(script_pub_key, N, block_hash):\n+    \"\"\" Calculates the ranged hash of a filter element as defined in BIP158:\n+\n+    'The first step in the filter construction is hashing the variable-sized\n+    raw items in the set to the range [0, F), where F = N * M.'\n+\n+    'The items are first passed through the pseudorandom function SipHash, which takes a\n+    128-bit key k and a variable-sized byte vector and produces a uniformly random 64-bit\n+    output. Implementations of this BIP MUST use the SipHash parameters c = 2 and d = 4.'\n+\n+    'The parameter k MUST be set to the first 16 bytes of the hash (in standard\n+    little-endian representation) of the block for which the filter is constructed. This\n+    ensures the key is deterministic while still varying from block to block.'\n+    \"\"\"\n+    M = 784931\n+    block_hash_bytes = bytes.fromhex(block_hash)[::-1]\n+    k0 = int.from_bytes(block_hash_bytes[0:8], 'little')\n+    k1 = int.from_bytes(block_hash_bytes[8:16], 'little')\n+    return (siphash(k0, k1, script_pub_key) * (N * M)) >> 64\n+\n+\n+def bip158_relevant_scriptpubkeys(node, block_hash):\n+    \"\"\" Determines the basic filter relvant scriptPubKeys as defined in BIP158:\n+\n+    'A basic filter MUST contain exactly the following items for each transaction in a block:\n+       - The previous output script (the script being spent) for each input, except for\n+         the coinbase transaction.\n+       - The scriptPubKey of each output, aside from all OP_RETURN output scripts.'\n+    \"\"\"\n+    spks = set()\n+    for tx in node.getblock(blockhash=block_hash, verbosity=3)['tx']:\n+        # gather prevout scripts\n+        for i in tx['vin']:\n+            if 'prevout' in i:\n+                spks.add(bytes.fromhex(i['prevout']['scriptPubKey']['hex']))\n+        # gather output scripts\n+        for o in tx['vout']:\n+            if o['scriptPubKey']['type'] != 'nulldata':\n+                spks.add(bytes.fromhex(o['scriptPubKey']['hex']))\n+    return spks\n\n\n###\n\n", "completion": "test: add compact block filter (BIP158) helper routines"}
{"prompt": " file path A: test/functional/test_framework/siphash.py | file path B: test/functional/test_framework/siphash.py\n\n@@ -1,15 +1,17 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2022 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Specialized SipHash-2-4 implementations.\n+\"\"\"SipHash-2-4 implementation.\n \n-This implements SipHash-2-4 for 256-bit integers.\n+This implements SipHash-2-4. For convenience, an interface taking 256-bit\n+integers is provided in addition to the one accepting generic data.\n \"\"\"\n \n def rotl64(n, b):\n     return n >> (64 - b) | (n & ((1 << (64 - b)) - 1)) << b\n \n+\n def siphash_round(v0, v1, v2, v3):\n     v0 = (v0 + v1) & ((1 << 64) - 1)\n     v1 = rotl64(v1, 13)\n@@ -27,37 +29,37 @@ def siphash_round(v0, v1, v2, v3):\n     v2 = rotl64(v2, 32)\n     return (v0, v1, v2, v3)\n \n-def siphash256(k0, k1, h):\n-    n0 = h & ((1 << 64) - 1)\n-    n1 = (h >> 64) & ((1 << 64) - 1)\n-    n2 = (h >> 128) & ((1 << 64) - 1)\n-    n3 = (h >> 192) & ((1 << 64) - 1)\n+\n+def siphash(k0, k1, data):\n+    assert(type(data) == bytes)\n     v0 = 0x736f6d6570736575 ^ k0\n     v1 = 0x646f72616e646f6d ^ k1\n     v2 = 0x6c7967656e657261 ^ k0\n-    v3 = 0x7465646279746573 ^ k1 ^ n0\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0 ^= n0\n-    v3 ^= n1\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0 ^= n1\n-    v3 ^= n2\n+    v3 = 0x7465646279746573 ^ k1\n+    c = 0\n+    t = 0\n+    for d in data:\n+        t |= d << (8 * (c % 8))\n+        c = (c + 1) & 0xff\n+        if (c & 7) == 0:\n+            v3 ^= t\n+            v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+            v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+            v0 ^= t\n+            t = 0\n+    t = t | (c << 56)\n+    v3 ^= t\n     v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n     v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0 ^= n2\n-    v3 ^= n3\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0 ^= n3\n-    v3 ^= 0x2000000000000000\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n-    v0 ^= 0x2000000000000000\n-    v2 ^= 0xFF\n+    v0 ^= t\n+    v2 ^= 0xff\n     v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n     v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n     v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n     v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n     return v0 ^ v1 ^ v2 ^ v3\n+\n+\n+def siphash256(k0, k1, num):\n+    assert(type(num) == int)\n+    return siphash(k0, k1, num.to_bytes(32, 'little'))\n\n\n###\n\n", "completion": "test: add SipHash implementation for generic data in Python"}
{"prompt": " file path A: src/test/util/txmempool.h | file path B: src/test/util/txmempool.h\n\n@@ -16,17 +16,13 @@ CTxMemPool::Options MemPoolOptionsForTest(const node::NodeContext& node);\n struct TestMemPoolEntryHelper\n {\n     // Default values\n-    CAmount nFee;\n-    int64_t nTime;\n-    unsigned int nHeight;\n-    bool spendsCoinbase;\n-    unsigned int sigOpCost;\n+    CAmount nFee{0};\n+    int64_t nTime{0};\n+    unsigned int nHeight{1};\n+    bool spendsCoinbase{false};\n+    unsigned int sigOpCost{4};\n     LockPoints lp;\n \n-    TestMemPoolEntryHelper() :\n-        nFee(0), nTime(0), nHeight(1),\n-        spendsCoinbase(false), sigOpCost(4) { }\n-\n     CTxMemPoolEntry FromTx(const CMutableTransaction& tx) const;\n     CTxMemPoolEntry FromTx(const CTransactionRef& tx) const;\n \n\n\n###\n\n", "completion": "test: Use C++11 member initializers for TestMemPoolEntryHelper"}
{"prompt": " file path A: build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj | file path B: build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj\n\n@@ -54,6 +54,9 @@\n     <ProjectReference Include=\"..\\libbitcoin_zmq\\libbitcoin_zmq.vcxproj\">\n       <Project>{792d487f-f14c-49fc-a9de-3fc150f31c3f}</Project>\n     </ProjectReference>\n+    <ProjectReference Include=\"..\\libtest_util\\libtest_util.vcxproj\">\n+      <Project>{1e065f03-3566-47d0-8fa9-daa72b084e7d}</Project>\n+    </ProjectReference>\n     <ProjectReference Include=\"..\\libleveldb\\libleveldb.vcxproj\">\n       <Project>{18430fef-6b61-4c53-b396-718e02850f1b}</Project>\n     </ProjectReference>\n\n---\n file path A: src/Makefile.test_util.include | file path B: src/Makefile.test_util.include\n\n@@ -5,20 +5,21 @@\n LIBTEST_UTIL=libtest_util.a\n \n EXTRA_LIBRARIES += \\\n-    $(LIBTEST_UTIL)\n+  $(LIBTEST_UTIL)\n \n TEST_UTIL_H = \\\n-    test/util/blockfilter.h \\\n-    test/util/chainstate.h \\\n-    test/util/logging.h \\\n-    test/util/mining.h \\\n-    test/util/net.h \\\n-    test/util/script.h \\\n-    test/util/setup_common.h \\\n-    test/util/str.h \\\n-    test/util/transaction_utils.h \\\n-    test/util/validation.h \\\n-    test/util/wallet.h\n+  test/util/blockfilter.h \\\n+  test/util/chainstate.h \\\n+  test/util/logging.h \\\n+  test/util/mining.h \\\n+  test/util/net.h \\\n+  test/util/script.h \\\n+  test/util/setup_common.h \\\n+  test/util/str.h \\\n+  test/util/transaction_utils.h \\\n+  test/util/txmempool.h \\\n+  test/util/validation.h \\\n+  test/util/wallet.h\n \n libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libtest_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -31,6 +32,7 @@ libtest_util_a_SOURCES = \\\n   test/util/setup_common.cpp \\\n   test/util/str.cpp \\\n   test/util/transaction_utils.cpp \\\n+  test/util/txmempool.cpp \\\n   test/util/validation.cpp \\\n   test/util/wallet.cpp \\\n   $(TEST_UTIL_H)\n\n---\n file path A: src/test/blockencodings_tests.cpp | file path B: src/test/blockencodings_tests.cpp\n\n@@ -7,6 +7,7 @@\n #include <consensus/merkle.h>\n #include <pow.h>\n #include <streams.h>\n+#include <test/util/txmempool.h>\n \n #include <test/util/setup_common.h>\n \n\n---\n file path A: src/test/fuzz/rbf.cpp | file path B: src/test/fuzz/rbf.cpp\n\n@@ -11,6 +11,7 @@\n #include <test/fuzz/util.h>\n #include <test/fuzz/util/mempool.h>\n #include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n #include <txmempool.h>\n \n #include <cstdint>\n\n---\n file path A: src/test/fuzz/tx_pool.cpp | file path B: src/test/fuzz/tx_pool.cpp\n\n@@ -13,6 +13,7 @@\n #include <test/util/mining.h>\n #include <test/util/script.h>\n #include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n #include <util/rbf.h>\n #include <validation.h>\n #include <validationinterface.h>\n\n---\n file path A: src/test/fuzz/validation_load_mempool.cpp | file path B: src/test/fuzz/validation_load_mempool.cpp\n\n@@ -12,6 +12,7 @@\n #include <test/fuzz/util.h>\n #include <test/fuzz/util/mempool.h>\n #include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n #include <txmempool.h>\n #include <util/time.h>\n #include <validation.h>\n\n---\n file path A: src/test/mempool_tests.cpp | file path B: src/test/mempool_tests.cpp\n\n@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <policy/policy.h>\n+#include <test/util/txmempool.h>\n #include <txmempool.h>\n #include <util/system.h>\n #include <util/time.h>\n\n---\n file path A: src/test/miner_tests.cpp | file path B: src/test/miner_tests.cpp\n\n@@ -9,6 +9,7 @@\n #include <node/miner.h>\n #include <policy/policy.h>\n #include <script/standard.h>\n+#include <test/util/txmempool.h>\n #include <timedata.h>\n #include <txmempool.h>\n #include <uint256.h>\n\n---\n file path A: src/test/policyestimator_tests.cpp | file path B: src/test/policyestimator_tests.cpp\n\n@@ -4,6 +4,7 @@\n \n #include <policy/fees.h>\n #include <policy/policy.h>\n+#include <test/util/txmempool.h>\n #include <txmempool.h>\n #include <uint256.h>\n #include <util/time.h>\n\n---\n file path A: src/test/rbf_tests.cpp | file path B: src/test/rbf_tests.cpp\n\n@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include <policy/rbf.h>\n #include <random.h>\n+#include <test/util/txmempool.h>\n #include <txmempool.h>\n #include <util/system.h>\n #include <util/time.h>\n\n---\n file path A: src/test/sigopcount_tests.cpp | file path B: src/test/sigopcount_tests.cpp\n\n@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <coins.h>\n #include <consensus/consensus.h>\n #include <consensus/tx_verify.h>\n #include <key.h>\n\n---\n file path A: src/test/util/setup_common.cpp | file path B: src/test/util/setup_common.cpp\n\n@@ -36,6 +36,7 @@\n #include <shutdown.h>\n #include <streams.h>\n #include <test/util/net.h>\n+#include <test/util/txmempool.h>\n #include <timedata.h>\n #include <txdb.h>\n #include <txmempool.h>\n@@ -60,7 +61,6 @@ using node::ApplyArgsManOptions;\n using node::BlockAssembler;\n using node::CalculateCacheSizes;\n using node::LoadChainstate;\n-using node::NodeContext;\n using node::RegenerateCommitments;\n using node::VerifyLoadedChainstate;\n \n@@ -162,19 +162,6 @@ BasicTestingSetup::~BasicTestingSetup()\n     gArgs.ClearArgs();\n }\n \n-CTxMemPool::Options MemPoolOptionsForTest(const NodeContext& node)\n-{\n-    CTxMemPool::Options mempool_opts{\n-        .estimator = node.fee_estimator.get(),\n-        // Default to always checking mempool regardless of\n-        // chainparams.DefaultConsistencyChecks for tests\n-        .check_ratio = 1,\n-    };\n-    const auto err{ApplyArgsManOptions(*node.args, ::Params(), mempool_opts)};\n-    Assert(!err);\n-    return mempool_opts;\n-}\n-\n ChainTestingSetup::ChainTestingSetup(const std::string& chainName, const std::vector<const char*>& extra_args)\n     : BasicTestingSetup(chainName, extra_args)\n {\n@@ -438,17 +425,6 @@ std::vector<CTransactionRef> TestChain100Setup::PopulateMempool(FastRandomContex\n     return mempool_transactions;\n }\n \n-CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction& tx) const\n-{\n-    return FromTx(MakeTransactionRef(tx));\n-}\n-\n-CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransactionRef& tx) const\n-{\n-    return CTxMemPoolEntry(tx, nFee, nTime, nHeight,\n-                           spendsCoinbase, sigOpCost, lp);\n-}\n-\n /**\n  * @returns a real block (0000000000013b8ab2cd513b0261a14096412195a72a0c4827d229dcc7e0f7af)\n  *      with 9 txs.\n\n---\n file path A: src/test/util/setup_common.h | file path B: src/test/util/setup_common.h\n\n@@ -8,21 +8,23 @@\n #include <chainparamsbase.h>\n #include <fs.h>\n #include <key.h>\n-#include <util/system.h>\n #include <node/caches.h>\n #include <node/context.h>\n+#include <primitives/transaction.h>\n #include <pubkey.h>\n #include <random.h>\n #include <stdexcept>\n-#include <txmempool.h>\n #include <util/check.h>\n #include <util/string.h>\n+#include <util/system.h>\n #include <util/vector.h>\n \n #include <functional>\n #include <type_traits>\n #include <vector>\n \n+class Chainstate;\n+\n /** This is connected to the logger. Can be used to redirect logs to any other log */\n extern const std::function<void(const std::string&)> G_TEST_LOG_FUN;\n \n@@ -90,9 +92,6 @@ struct BasicTestingSetup {\n     ArgsManager m_args;\n };\n \n-\n-CTxMemPool::Options MemPoolOptionsForTest(const node::NodeContext& node);\n-\n /** Testing setup that performs all steps up until right before\n  * ChainstateManager gets initialized. Meant for testing ChainstateManager\n  * initialization behaviour.\n@@ -213,33 +212,6 @@ std::unique_ptr<T> MakeNoLogFileContext(const std::string& chain_name = CBaseCha\n     return std::make_unique<T>(chain_name, arguments);\n }\n \n-class CTxMemPoolEntry;\n-\n-struct TestMemPoolEntryHelper\n-{\n-    // Default values\n-    CAmount nFee;\n-    int64_t nTime;\n-    unsigned int nHeight;\n-    bool spendsCoinbase;\n-    unsigned int sigOpCost;\n-    LockPoints lp;\n-\n-    TestMemPoolEntryHelper() :\n-        nFee(0), nTime(0), nHeight(1),\n-        spendsCoinbase(false), sigOpCost(4) { }\n-\n-    CTxMemPoolEntry FromTx(const CMutableTransaction& tx) const;\n-    CTxMemPoolEntry FromTx(const CTransactionRef& tx) const;\n-\n-    // Change the default value\n-    TestMemPoolEntryHelper &Fee(CAmount _fee) { nFee = _fee; return *this; }\n-    TestMemPoolEntryHelper &Time(int64_t _time) { nTime = _time; return *this; }\n-    TestMemPoolEntryHelper &Height(unsigned int _height) { nHeight = _height; return *this; }\n-    TestMemPoolEntryHelper &SpendsCoinbase(bool _flag) { spendsCoinbase = _flag; return *this; }\n-    TestMemPoolEntryHelper &SigOpsCost(unsigned int _sigopsCost) { sigOpCost = _sigopsCost; return *this; }\n-};\n-\n CBlock getBlock13b8a();\n \n // define an implicit conversion here so that uint256 may be used directly in BOOST_CHECK_*\n\n---\n file path A: None | file path B: src/test/util/txmempool.cpp\n\n@@ -0,0 +1,39 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <test/util/txmempool.h>\n+\n+#include <chainparams.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <txmempool.h>\n+#include <util/check.h>\n+#include <util/time.h>\n+#include <util/translation.h>\n+\n+using node::NodeContext;\n+\n+CTxMemPool::Options MemPoolOptionsForTest(const NodeContext& node)\n+{\n+    CTxMemPool::Options mempool_opts{\n+        .estimator = node.fee_estimator.get(),\n+        // Default to always checking mempool regardless of\n+        // chainparams.DefaultConsistencyChecks for tests\n+        .check_ratio = 1,\n+    };\n+    const auto err{ApplyArgsManOptions(*node.args, ::Params(), mempool_opts)};\n+    Assert(!err);\n+    return mempool_opts;\n+}\n+\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction& tx) const\n+{\n+    return FromTx(MakeTransactionRef(tx));\n+}\n+\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransactionRef& tx) const\n+{\n+    return CTxMemPoolEntry(tx, nFee, nTime, nHeight,\n+                           spendsCoinbase, sigOpCost, lp);\n+}\n\n---\n file path A: None | file path B: src/test/util/txmempool.h\n\n@@ -0,0 +1,41 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_TXMEMPOOL_H\n+#define BITCOIN_TEST_UTIL_TXMEMPOOL_H\n+\n+#include <txmempool.h>\n+\n+namespace node {\n+struct NodeContext;\n+}\n+\n+CTxMemPool::Options MemPoolOptionsForTest(const node::NodeContext& node);\n+\n+struct TestMemPoolEntryHelper\n+{\n+    // Default values\n+    CAmount nFee;\n+    int64_t nTime;\n+    unsigned int nHeight;\n+    bool spendsCoinbase;\n+    unsigned int sigOpCost;\n+    LockPoints lp;\n+\n+    TestMemPoolEntryHelper() :\n+        nFee(0), nTime(0), nHeight(1),\n+        spendsCoinbase(false), sigOpCost(4) { }\n+\n+    CTxMemPoolEntry FromTx(const CMutableTransaction& tx) const;\n+    CTxMemPoolEntry FromTx(const CTransactionRef& tx) const;\n+\n+    // Change the default value\n+    TestMemPoolEntryHelper &Fee(CAmount _fee) { nFee = _fee; return *this; }\n+    TestMemPoolEntryHelper &Time(int64_t _time) { nTime = _time; return *this; }\n+    TestMemPoolEntryHelper &Height(unsigned int _height) { nHeight = _height; return *this; }\n+    TestMemPoolEntryHelper &SpendsCoinbase(bool _flag) { spendsCoinbase = _flag; return *this; }\n+    TestMemPoolEntryHelper &SigOpsCost(unsigned int _sigopsCost) { sigOpCost = _sigopsCost; return *this; }\n+};\n+\n+#endif // BITCOIN_TEST_UTIL_TXMEMPOOL_H\n\n---\n file path A: src/test/util_tests.cpp | file path B: src/test/util_tests.cpp\n\n@@ -26,6 +26,7 @@\n #include <util/bitdeque.h>\n \n #include <array>\n+#include <cmath>\n #include <fstream>\n #include <limits>\n #include <map>\n\n---\n file path A: src/wallet/test/feebumper_tests.cpp | file path B: src/wallet/test/feebumper_tests.cpp\n\n@@ -2,6 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or https://www.opensource.org/licenses/mit-license.php.\n \n+#include <consensus/validation.h>\n+#include <policy/policy.h>\n #include <primitives/transaction.h>\n #include <script/script.h>\n #include <util/strencodings.h>\n\n\n###\n\n", "completion": "test: Remove unused txmempool include from tests"}
{"prompt": " file path A: test/functional/p2p_sendtxrcncl.py | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -146,6 +146,34 @@ class SendTxRcnclTest(BitcoinTestFramework):\n             peer.send_message(msg_verack())\n         peer.peer_disconnect()\n \n+        self.log.info('SENDTXRCNCL sent to an outbound')\n+        peer = self.nodes[0].add_outbound_p2p_connection(\n+            SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        assert peer.sendtxrcncl_msg_received\n+        assert peer.sendtxrcncl_msg_received.initiator\n+        assert not peer.sendtxrcncl_msg_received.responder\n+        assert_equal(peer.sendtxrcncl_msg_received.version, 1)\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL should not be sent if block-relay-only')\n+        peer = self.nodes[0].add_outbound_p2p_connection(\n+            SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=2, connection_type=\"block-relay-only\")\n+        assert not peer.sendtxrcncl_msg_received\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL if block-relay-only triggers a disconnect')\n+        peer = self.nodes[0].add_outbound_p2p_connection(\n+            PeerNoVerack(), wait_for_verack=False, p2p_idx=3, connection_type=\"block-relay-only\")\n+        peer.send_message(create_sendtxrcncl_msg(initiator=False))\n+        peer.wait_for_disconnect()\n+\n+        self.log.info('SENDTXRCNCL with initiator=1 and responder=0 from outbound triggers a disconnect')\n+        sendtxrcncl_wrong_role = create_sendtxrcncl_msg(initiator=True)\n+        peer = self.nodes[0].add_outbound_p2p_connection(\n+            P2PInterface(), wait_for_verack=False, p2p_idx=4, connection_type=\"outbound-full-relay\")\n+        peer.send_message(sendtxrcncl_wrong_role)\n+        peer.wait_for_disconnect()\n+\n         self.log.info('SENDTXRCNCL not sent if -txreconciliation flag is not set')\n         self.restart_node(0, [])\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n\n---\n file path A: test/functional/test_framework/test_node.py | file path B: test/functional/test_framework/test_node.py\n\n@@ -618,7 +618,7 @@ class TestNode():\n \n         return p2p_conn\n \n-    def add_outbound_p2p_connection(self, p2p_conn, *, p2p_idx, connection_type=\"outbound-full-relay\", **kwargs):\n+    def add_outbound_p2p_connection(self, p2p_conn, *, wait_for_verack=True, p2p_idx, connection_type=\"outbound-full-relay\", **kwargs):\n         \"\"\"Add an outbound p2p connection from node. Must be an\n         \"outbound-full-relay\", \"block-relay-only\", \"addr-fetch\" or \"feeler\" connection.\n \n@@ -640,8 +640,9 @@ class TestNode():\n             p2p_conn.wait_for_connect()\n             self.p2ps.append(p2p_conn)\n \n-            p2p_conn.wait_for_verack()\n-            p2p_conn.sync_with_ping()\n+            if wait_for_verack:\n+                p2p_conn.wait_for_verack()\n+                p2p_conn.sync_with_ping()\n \n         return p2p_conn\n \n\n\n###\n\n", "completion": "test: Add functional tests for sendtxrcncl message from outbound"}
{"prompt": " file path A: None | file path B: test/functional/p2p_sendtxrcncl.py\n\n@@ -0,0 +1,163 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test SENDTXRCNCL message\n+\"\"\"\n+\n+from test_framework.messages import (\n+    msg_sendtxrcncl,\n+    msg_verack,\n+    msg_version,\n+    msg_wtxidrelay,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    P2P_SERVICES,\n+    P2P_SUBVERSION,\n+    P2P_VERSION,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+class PeerNoVerack(P2PInterface):\n+    def __init__(self, wtxidrelay=True):\n+        super().__init__(wtxidrelay=wtxidrelay)\n+\n+    def on_version(self, message):\n+        # Avoid sending verack in response to version.\n+        # When calling add_p2p_connection, wait_for_verack=False must be set (see\n+        # comment in add_p2p_connection).\n+        if message.nVersion >= 70016 and self.wtxidrelay:\n+            self.send_message(msg_wtxidrelay())\n+\n+class SendTxrcnclReceiver(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.sendtxrcncl_msg_received = None\n+\n+    def on_sendtxrcncl(self, message):\n+        self.sendtxrcncl_msg_received = message\n+\n+class PeerTrackMsgOrder(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.messages = []\n+\n+    def on_message(self, message):\n+        super().on_message(message)\n+        self.messages.append(message)\n+\n+def create_sendtxrcncl_msg(initiator=True):\n+    sendtxrcncl_msg = msg_sendtxrcncl()\n+    sendtxrcncl_msg.initiator = initiator\n+    sendtxrcncl_msg.responder = not initiator\n+    sendtxrcncl_msg.version = 1\n+    sendtxrcncl_msg.salt = 2\n+    return sendtxrcncl_msg\n+\n+class SendTxRcnclTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [['-txreconciliation']]\n+\n+    def run_test(self):\n+        self.log.info('SENDTXRCNCL sent to an inbound')\n+        peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n+        assert peer.sendtxrcncl_msg_received\n+        assert not peer.sendtxrcncl_msg_received.initiator\n+        assert peer.sendtxrcncl_msg_received.responder\n+        assert_equal(peer.sendtxrcncl_msg_received.version, 1)\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL should be sent before VERACK')\n+        peer = self.nodes[0].add_p2p_connection(PeerTrackMsgOrder(), send_version=True, wait_for_verack=True)\n+        peer.wait_for_verack()\n+        verack_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'verack'][0]\n+        sendtxrcncl_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'sendtxrcncl'][0]\n+        assert(sendtxrcncl_index < verack_index)\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL on pre-WTXID version should not be sent')\n+        peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=False, wait_for_verack=False)\n+        pre_wtxid_version_msg = msg_version()\n+        pre_wtxid_version_msg.nVersion = 70015\n+        pre_wtxid_version_msg.strSubVer = P2P_SUBVERSION\n+        pre_wtxid_version_msg.nServices = P2P_SERVICES\n+        pre_wtxid_version_msg.relay = 1\n+        peer.send_message(pre_wtxid_version_msg)\n+        peer.wait_for_verack()\n+        assert not peer.sendtxrcncl_msg_received\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL for fRelay=false should not be sent')\n+        peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=False, wait_for_verack=False)\n+        no_txrelay_version_msg = msg_version()\n+        no_txrelay_version_msg.nVersion = P2P_VERSION\n+        no_txrelay_version_msg.strSubVer = P2P_SUBVERSION\n+        no_txrelay_version_msg.nServices = P2P_SERVICES\n+        no_txrelay_version_msg.relay = 0\n+        peer.send_message(no_txrelay_version_msg)\n+        peer.wait_for_verack()\n+        assert not peer.sendtxrcncl_msg_received\n+        peer.peer_disconnect()\n+\n+        self.log.info('valid SENDTXRCNCL received')\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n+        peer.send_message(create_sendtxrcncl_msg())\n+        self.wait_until(lambda : \"sendtxrcncl\" in self.nodes[0].getpeerinfo()[-1][\"bytesrecv_per_msg\"])\n+        self.log.info('second SENDTXRCNCL triggers a disconnect')\n+        peer.send_message(create_sendtxrcncl_msg())\n+        peer.wait_for_disconnect()\n+\n+        self.log.info('SENDTXRCNCL with initiator=responder=0 triggers a disconnect')\n+        sendtxrcncl_no_role = create_sendtxrcncl_msg()\n+        sendtxrcncl_no_role.initiator = False\n+        sendtxrcncl_no_role.responder = False\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n+        peer.send_message(sendtxrcncl_no_role)\n+        peer.wait_for_disconnect()\n+\n+        self.log.info('SENDTXRCNCL with initiator=0 and responder=1 from inbound triggers a disconnect')\n+        sendtxrcncl_wrong_role = create_sendtxrcncl_msg(initiator=False)\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n+        peer.send_message(sendtxrcncl_wrong_role)\n+        peer.wait_for_disconnect()\n+\n+        self.log.info('SENDTXRCNCL with version=0 triggers a disconnect')\n+        sendtxrcncl_low_version = create_sendtxrcncl_msg()\n+        sendtxrcncl_low_version.version = 0\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n+        peer.send_message(sendtxrcncl_low_version)\n+        peer.wait_for_disconnect()\n+\n+        self.log.info('sending SENDTXRCNCL after sending VERACK triggers a disconnect')\n+        # We use PeerNoVerack even though verack is sent right after, to make sure it was actually\n+        # sent before sendtxrcncl is sent.\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n+        peer.send_and_ping(msg_verack())\n+        peer.send_message(create_sendtxrcncl_msg())\n+        peer.wait_for_disconnect()\n+\n+        self.log.info('SENDTXRCNCL without WTXIDRELAY is ignored (recon state is erased after VERACK)')\n+        peer = self.nodes[0].add_p2p_connection(PeerNoVerack(wtxidrelay=False), send_version=True, wait_for_verack=False)\n+        with self.nodes[0].assert_debug_log(['Forget txreconciliation state of peer']):\n+            peer.send_message(create_sendtxrcncl_msg())\n+            peer.send_message(msg_verack())\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL not sent if -txreconciliation flag is not set')\n+        self.restart_node(0, [])\n+        peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n+        assert not peer.sendtxrcncl_msg_received\n+        peer.peer_disconnect()\n+\n+        self.log.info('SENDTXRCNCL not sent if blocksonly is set')\n+        self.restart_node(0, [\"-txreconciliation\", \"-blocksonly\"])\n+        peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n+        assert not peer.sendtxrcncl_msg_received\n+        peer.peer_disconnect()\n+\n+\n+if __name__ == '__main__':\n+    SendTxRcnclTest().main()\n\n---\n file path A: test/functional/test_framework/messages.py | file path B: test/functional/test_framework/messages.py\n\n@@ -1838,3 +1838,31 @@ class msg_cfcheckpt:\n     def __repr__(self):\n         return \"msg_cfcheckpt(filter_type={:#x}, stop_hash={:x})\".format(\n             self.filter_type, self.stop_hash)\n+\n+class msg_sendtxrcncl:\n+    __slots__ = (\"initiator\", \"responder\", \"version\", \"salt\")\n+    msgtype = b\"sendtxrcncl\"\n+\n+    def __init__(self):\n+        self.initiator = False\n+        self.responder = False\n+        self.version = 0\n+        self.salt = 0\n+\n+    def deserialize(self, f):\n+        self.initiator = struct.unpack(\"<?\", f.read(1))[0]\n+        self.responder = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<I\", f.read(4))[0]\n+        self.salt = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.initiator)\n+        r += struct.pack(\"<?\", self.responder)\n+        r += struct.pack(\"<I\", self.version)\n+        r += struct.pack(\"<Q\", self.salt)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendtxrcncl(initiator=%i, responder=%i, version=%lu, salt=%lu)\" %\\\n+            (self.initiator, self.responder, self.version, self.salt)\n\n---\n file path A: test/functional/test_framework/p2p.py | file path B: test/functional/test_framework/p2p.py\n\n@@ -62,6 +62,7 @@ from test_framework.messages import (\n     msg_sendaddrv2,\n     msg_sendcmpct,\n     msg_sendheaders,\n+    msg_sendtxrcncl,\n     msg_tx,\n     MSG_TX,\n     MSG_TYPE_MASK,\n@@ -126,6 +127,7 @@ MESSAGEMAP = {\n     b\"sendaddrv2\": msg_sendaddrv2,\n     b\"sendcmpct\": msg_sendcmpct,\n     b\"sendheaders\": msg_sendheaders,\n+    b\"sendtxrcncl\": msg_sendtxrcncl,\n     b\"tx\": msg_tx,\n     b\"verack\": msg_verack,\n     b\"version\": msg_version,\n@@ -421,6 +423,7 @@ class P2PInterface(P2PConnection):\n     def on_sendaddrv2(self, message): pass\n     def on_sendcmpct(self, message): pass\n     def on_sendheaders(self, message): pass\n+    def on_sendtxrcncl(self, message): pass\n     def on_tx(self, message): pass\n     def on_wtxidrelay(self, message): pass\n \n\n---\n file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -318,6 +318,7 @@ BASE_SCRIPTS = [\n     'rpc_deriveaddresses.py --usecli',\n     'p2p_ping.py',\n     'rpc_scanblocks.py',\n+    'p2p_sendtxrcncl.py',\n     'rpc_scantxoutset.py',\n     'feature_txindex_compatibility.py',\n     'feature_unsupported_utxo_db.py',\n\n\n###\n\n", "completion": "test: Add functional tests for sendtxrcncl from inbound"}
{"prompt": " file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -148,6 +148,7 @@ BITCOIN_TESTS =\\\n   test/transaction_tests.cpp \\\n   test/txindex_tests.cpp \\\n   test/txpackage_tests.cpp \\\n+  test/txreconciliation_tests.cpp \\\n   test/txrequest_tests.cpp \\\n   test/txvalidation_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n\n---\n file path A: None | file path B: src/test/txreconciliation_tests.cpp\n\n@@ -0,0 +1,86 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(RegisterPeerTest)\n+{\n+    TxReconciliationTracker tracker(1);\n+    const uint64_t salt = 0;\n+\n+    // Prepare a peer for reconciliation.\n+    tracker.PreRegisterPeer(0);\n+\n+    // Both roles are false, don't register.\n+    BOOST_CHECK(tracker.RegisterPeer(/*peer_id=*/0, /*is_peer_inbound=*/true,\n+                                      /*is_peer_recon_initiator=*/false,\n+                                      /*is_peer_recon_responder=*/false,\n+                                      /*peer_recon_version=*/1, salt) ==\n+                    ReconciliationRegisterResult::PROTOCOL_VIOLATION);\n+\n+    // Invalid roles for the given connection direction.\n+    BOOST_CHECK(tracker.RegisterPeer(0, true, false, true, 1, salt) == ReconciliationRegisterResult::PROTOCOL_VIOLATION);\n+    BOOST_CHECK(tracker.RegisterPeer(0, false, true, false, 1, salt) == ReconciliationRegisterResult::PROTOCOL_VIOLATION);\n+\n+    // Invalid version.\n+    BOOST_CHECK(tracker.RegisterPeer(0, true, true, false, 0, salt) == ReconciliationRegisterResult::PROTOCOL_VIOLATION);\n+\n+    // Valid registration.\n+    BOOST_REQUIRE(!tracker.IsPeerRegistered(0));\n+    BOOST_REQUIRE(tracker.RegisterPeer(0, true, true, false, 1, salt) == ReconciliationRegisterResult::SUCCESS);\n+    BOOST_CHECK(tracker.IsPeerRegistered(0));\n+\n+    // Reconciliation version is higher than ours, should be able to register.\n+    BOOST_REQUIRE(!tracker.IsPeerRegistered(1));\n+    tracker.PreRegisterPeer(1);\n+    BOOST_REQUIRE(tracker.RegisterPeer(1, true, true, false, 2, salt) == ReconciliationRegisterResult::SUCCESS);\n+    BOOST_CHECK(tracker.IsPeerRegistered(1));\n+\n+    // Do not register if there were no pre-registration for the peer.\n+    BOOST_REQUIRE(tracker.RegisterPeer(100, true, true, false, 1, salt) == ReconciliationRegisterResult::NOT_FOUND);\n+    BOOST_CHECK(!tracker.IsPeerRegistered(100));\n+}\n+\n+BOOST_AUTO_TEST_CASE(ForgetPeerTest)\n+{\n+    TxReconciliationTracker tracker(1);\n+    NodeId peer_id0 = 0;\n+\n+    // Removing peer after pre-registring works and does not let to register the peer.\n+    tracker.PreRegisterPeer(peer_id0);\n+    tracker.ForgetPeer(peer_id0);\n+    BOOST_CHECK(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1) == ReconciliationRegisterResult::NOT_FOUND);\n+\n+    // Removing peer after it is registered works.\n+    tracker.PreRegisterPeer(peer_id0);\n+    BOOST_REQUIRE(!tracker.IsPeerRegistered(peer_id0));\n+    BOOST_REQUIRE(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1) == ReconciliationRegisterResult::SUCCESS);\n+    BOOST_CHECK(tracker.IsPeerRegistered(peer_id0));\n+    tracker.ForgetPeer(peer_id0);\n+    BOOST_CHECK(!tracker.IsPeerRegistered(peer_id0));\n+}\n+\n+BOOST_AUTO_TEST_CASE(IsPeerRegisteredTest)\n+{\n+    TxReconciliationTracker tracker(1);\n+    NodeId peer_id0 = 0;\n+\n+    BOOST_REQUIRE(!tracker.IsPeerRegistered(peer_id0));\n+    tracker.PreRegisterPeer(peer_id0);\n+    BOOST_REQUIRE(!tracker.IsPeerRegistered(peer_id0));\n+\n+    BOOST_REQUIRE(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1) == ReconciliationRegisterResult::SUCCESS);\n+    BOOST_CHECK(tracker.IsPeerRegistered(peer_id0));\n+\n+    tracker.ForgetPeer(peer_id0);\n+    BOOST_CHECK(!tracker.IsPeerRegistered(peer_id0));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: Add unit tests for reconciliation negotiation"}
{"prompt": " file path A: test/functional/rpc_scanblocks.py | file path B: test/functional/rpc_scanblocks.py\n\n@@ -3,8 +3,16 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the scanblocks RPC call.\"\"\"\n+from test_framework.messages import COIN\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    getnewdestination,\n+)\n \n \n class ScanblocksTest(BitcoinTestFramework):\n@@ -12,19 +20,21 @@ class ScanblocksTest(BitcoinTestFramework):\n         self.num_nodes = 2\n         self.extra_args = [[\"-blockfilterindex=1\"], []]\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n     def run_test(self):\n         node = self.nodes[0]\n+        wallet = MiniWallet(node)\n+        wallet.rescan_utxos()\n+\n         # send 1.0, mempool only\n-        addr_1 = node.getnewaddress()\n-        node.sendtoaddress(addr_1, 1.0)\n+        _, spk_1, addr_1 = getnewdestination()\n+        wallet.send_to(from_node=node, scriptPubKey=spk_1, amount=1 * COIN)\n \n         parent_key = \"tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B\"\n         # send 1.0, mempool only\n         # childkey 5 of `parent_key`\n-        node.sendtoaddress(\"mkS4HXoTYWRTescLGaUTGbtTTYX5EjJyEE\", 1.0)\n+        wallet.send_to(from_node=node,\n+                       scriptPubKey=bytes.fromhex(node.validateaddress(\"mkS4HXoTYWRTescLGaUTGbtTTYX5EjJyEE\")['scriptPubKey']),\n+                       amount=1 * COIN)\n \n         # mine a block and assure that the mined blockhash is in the filterresult\n         blockhash = self.generate(node, 1)[0]\n\n\n###\n\n", "completion": "test: use MiniWallet for rpc_scanblocks.py"}
{"prompt": " file path A: src/wallet/wallet.cpp | file path B: src/wallet/wallet.cpp\n\n@@ -1916,12 +1916,12 @@ bool CWallet::ShouldResend() const\n \n     // Do this infrequently and randomly to avoid giving away\n     // that these are our transactions.\n-    if (GetTime() < m_next_resend) return false;\n+    if (NodeClock::now() < m_next_resend) return false;\n \n     return true;\n }\n \n-int64_t CWallet::GetDefaultNextResend() { return GetTime() + (12 * 60 * 60) + GetRand(24 * 60 * 60); }\n+NodeClock::time_point CWallet::GetDefaultNextResend() { return FastRandomContext{}.rand_uniform_delay(NodeClock::now() + 12h, 24h); }\n \n // Resubmit transactions from the wallet to the mempool, optionally asking the\n // mempool to relay them. On startup, we will do this for all unconfirmed\n\n---\n file path A: src/wallet/wallet.h | file path B: src/wallet/wallet.h\n\n@@ -20,6 +20,7 @@\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/system.h>\n+#include <util/time.h>\n #include <util/ui_change_type.h>\n #include <validationinterface.h>\n #include <wallet/crypter.h>\n@@ -250,7 +251,7 @@ private:\n     int nWalletVersion GUARDED_BY(cs_wallet){FEATURE_BASE};\n \n     /** The next scheduled rebroadcast of wallet transactions. */\n-    int64_t m_next_resend{GetDefaultNextResend()};\n+    NodeClock::time_point m_next_resend{GetDefaultNextResend()};\n     /** Whether this wallet will submit newly created transactions to the node's mempool and\n      * prompt rebroadcasts (see ResendWalletTransactions()). */\n     bool fBroadcastTransactions = false;\n@@ -348,7 +349,7 @@ private:\n      */\n     static bool AttachChain(const std::shared_ptr<CWallet>& wallet, interfaces::Chain& chain, const bool rescan_required, bilingual_str& error, std::vector<bilingual_str>& warnings);\n \n-    static int64_t GetDefaultNextResend();\n+    static NodeClock::time_point GetDefaultNextResend();\n \n public:\n     /**\n\n\n###\n\n", "completion": "refactor: Use type-safe time point for CWallet::m_next_resend"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -171,7 +171,7 @@ task:\n     - cd %CIRRUS_WORKING_DIR%\n     - ccache --zero-stats --max-size=%CCACHE_SIZE%\n     - python build_msvc\\msvc-autogen.py\n-    - msbuild build_msvc\\bitcoin.sln -property:CLToolExe=%WRAPPED_CL% -property:Configuration=Release -maxCpuCount -verbosity:minimal -noLogo\n+    - msbuild build_msvc\\bitcoin.sln -property:CLToolExe=%WRAPPED_CL%;UseMultiToolTask=true;Configuration=Release -maxCpuCount -verbosity:minimal -noLogo\n     - ccache --show-stats\n   check_script:\n     - src\\test_bitcoin.exe -l test_suite\n\n\n###\n\n", "completion": "ci: Use Multi-ToolTask in \"Win64 native\" task"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -184,7 +184,7 @@ task:\n     - netsh int ipv4 set dynamicport tcp start=1025 num=64511\n     - netsh int ipv6 set dynamicport tcp start=1025 num=64511\n     # Exclude feature_dbcrash for now due to timeout\n-    - python test\\functional\\test_runner.py --nocleanup --ci --quiet --combinedlogslen=4000 --jobs=4 --timeout-factor=8 --extended --exclude feature_dbcrash\n+    - python test\\functional\\test_runner.py --nocleanup --ci --quiet --combinedlogslen=4000 --jobs=6 --timeout-factor=8 --extended --exclude feature_dbcrash\n \n task:\n   name: 'ARM [unit tests, no functional tests] [bullseye]'\n\n\n###\n\n", "completion": "ci: Use all available CPUs for functional tests in \"Win64 native\" task"}
{"prompt": " file path A: src/test/txindex_tests.cpp | file path B: src/test/txindex_tests.cpp\n\n@@ -69,11 +69,16 @@ BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)\n         }\n     }\n \n+    // It is not safe to stop and destroy the index until it finishes handling\n+    // the last BlockConnected notification. The BlockUntilSyncedToCurrentChain()\n+    // call above is sufficient to ensure this, but the\n+    // SyncWithValidationInterfaceQueue() call below is also needed to ensure\n+    // TSAN always sees the test thread waiting for the notification thread, and\n+    // avoid potential false positive reports.\n+    SyncWithValidationInterfaceQueue();\n+\n     // shutdown sequence (c.f. Shutdown() in init.cpp)\n     txindex.Stop();\n-\n-    // Let scheduler events finish running to avoid accessing any memory related to txindex after it is destructed\n-    SyncWithValidationInterfaceQueue();\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: move SyncWithValidationInterfaceQueue() before Stop() in txindex_tests"}
{"prompt": " file path A: src/test/coinstatsindex_tests.cpp | file path B: src/test/coinstatsindex_tests.cpp\n\n@@ -76,10 +76,16 @@ BOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)\n \n     BOOST_CHECK(block_index != new_block_index);\n \n+    // It is not safe to stop and destroy the index until it finishes handling\n+    // the last BlockConnected notification. The BlockUntilSyncedToCurrentChain()\n+    // call above is sufficient to ensure this, but the\n+    // SyncWithValidationInterfaceQueue() call below is also needed to ensure\n+    // TSAN always sees the test thread waiting for the notification thread, and\n+    // avoid potential false positive reports.\n+    SyncWithValidationInterfaceQueue();\n+\n     // Shutdown sequence (c.f. Shutdown() in init.cpp)\n     coin_stats_index.Stop();\n-\n-    // Rest of shutdown sequence and destructors happen in ~TestingSetup()\n }\n \n // Test shutdown between BlockConnected and ChainStateFlushed notifications,\n\n\n###\n\n", "completion": "test: silence TSAN false positive in coinstatsindex_initial_sync"}
{"prompt": " file path A: src/txmempool.cpp | file path B: src/txmempool.cpp\n\n@@ -145,7 +145,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256>& vHashes\n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n     // This maximizes the benefit of the descendant cache and guarantees that\n-    // CTxMemPool::m_children will be updated, an assumption made in\n+    // CTxMemPoolEntry::m_children will be updated, an assumption made in\n     // UpdateForDescendants.\n     for (const uint256 &hash : reverse_iterate(vHashesToUpdate)) {\n         // calculate children from mapNextTx\n@@ -154,7 +154,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256>& vHashes\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update CTxMemPool::m_children to\n+        // First calculate the children, and update CTxMemPoolEntry::m_children to\n         // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n         // we cache the in-mempool children to avoid duplicate updates\n         {\n\n---\n file path A: src/txmempool.h | file path B: src/txmempool.h\n\n@@ -825,7 +825,7 @@ private:\n      *  mempool but may have child transactions in the mempool, eg during a\n      *  chain reorg.\n      *\n-     * @pre CTxMemPool::m_children is correct for the given tx and all\n+     * @pre CTxMemPoolEntry::m_children is correct for the given tx and all\n      *      descendants.\n      * @pre cachedDescendants is an accurate cache where each entry has all\n      *      descendants of the corresponding key, including those that should\n\n\n###\n\n", "completion": "docs: fix m_children to be a member of CTxMemPoolEntry"}
{"prompt": " file path A: test/functional/feature_bip68_sequence.py | file path B: test/functional/feature_bip68_sequence.py\n\n@@ -10,15 +10,21 @@ from test_framework.blocktools import (\n     NORMAL_GBT_REQUEST_PARAMS,\n     add_witness_commitment,\n     create_block,\n+    script_to_p2wsh_script,\n )\n from test_framework.messages import (\n     COIN,\n     COutPoint,\n     CTransaction,\n     CTxIn,\n+    CTxInWitness,\n     CTxOut,\n     tx_from_hex,\n )\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -26,7 +32,8 @@ from test_framework.util import (\n     assert_raises_rpc_error,\n     softfork_active,\n )\n-from test_framework.script_util import DUMMY_P2WPKH_SCRIPT\n+\n+SCRIPT_W0_SH_OP_TRUE = script_to_p2wsh_script(CScript([OP_TRUE]))\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n@@ -42,11 +49,9 @@ class BIP68Test(BitcoinTestFramework):\n         self.extra_args = [\n             [\n                 '-testactivationheight=csv@432',\n-                \"-acceptnonstdtxn=1\",\n             ],\n             [\n                 '-testactivationheight=csv@432',\n-                \"-acceptnonstdtxn=0\",\n             ],\n         ]\n \n@@ -100,7 +105,7 @@ class BIP68Test(BitcoinTestFramework):\n         # input to mature.\n         sequence_value = SEQUENCE_LOCKTIME_DISABLE_FLAG | 1\n         tx1.vin = [CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=sequence_value)]\n-        tx1.vout = [CTxOut(value, DUMMY_P2WPKH_SCRIPT)]\n+        tx1.vout = [CTxOut(value, SCRIPT_W0_SH_OP_TRUE)]\n \n         tx1_signed = self.nodes[0].signrawtransactionwithwallet(tx1.serialize().hex())[\"hex\"]\n         tx1_id = self.nodes[0].sendrawtransaction(tx1_signed)\n@@ -112,7 +117,9 @@ class BIP68Test(BitcoinTestFramework):\n         tx2.nVersion = 2\n         sequence_value = sequence_value & 0x7fffffff\n         tx2.vin = [CTxIn(COutPoint(tx1_id, 0), nSequence=sequence_value)]\n-        tx2.vout = [CTxOut(int(value - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n+        tx2.wit.vtxinwit = [CTxInWitness()]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        tx2.vout = [CTxOut(int(value - self.relayfee * COIN), SCRIPT_W0_SH_OP_TRUE)]\n         tx2.rehash()\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, tx2.serialize().hex())\n@@ -207,7 +214,7 @@ class BIP68Test(BitcoinTestFramework):\n                 value += utxos[j][\"amount\"]*COIN\n             # Overestimate the size of the tx - signatures should be less than 120 bytes, and leave 50 for the output\n             tx_size = len(tx.serialize().hex())//2 + 120*num_inputs + 50\n-            tx.vout.append(CTxOut(int(value-self.relayfee*tx_size*COIN/1000), DUMMY_P2WPKH_SCRIPT))\n+            tx.vout.append(CTxOut(int(value - self.relayfee * tx_size * COIN / 1000), SCRIPT_W0_SH_OP_TRUE))\n             rawtx = self.nodes[0].signrawtransactionwithwallet(tx.serialize().hex())[\"hex\"]\n \n             if (using_sequence_locks and not should_pass):\n@@ -236,7 +243,7 @@ class BIP68Test(BitcoinTestFramework):\n         tx2 = CTransaction()\n         tx2.nVersion = 2\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n-        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee * COIN), SCRIPT_W0_SH_OP_TRUE)]\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(tx2.serialize().hex())[\"hex\"]\n         tx2 = tx_from_hex(tx2_raw)\n         tx2.rehash()\n@@ -254,7 +261,9 @@ class BIP68Test(BitcoinTestFramework):\n             tx = CTransaction()\n             tx.nVersion = 2\n             tx.vin = [CTxIn(COutPoint(orig_tx.sha256, 0), nSequence=sequence_value)]\n-            tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n+            tx.wit.vtxinwit = [CTxInWitness()]\n+            tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+            tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee * COIN), SCRIPT_W0_SH_OP_TRUE)]\n             tx.rehash()\n \n             if (orig_tx.hash in node.getrawmempool()):\n@@ -367,7 +376,7 @@ class BIP68Test(BitcoinTestFramework):\n         tx2 = CTransaction()\n         tx2.nVersion = 1\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n-        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee * COIN), SCRIPT_W0_SH_OP_TRUE)]\n \n         # sign tx2\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(tx2.serialize().hex())[\"hex\"]\n@@ -382,7 +391,9 @@ class BIP68Test(BitcoinTestFramework):\n         tx3 = CTransaction()\n         tx3.nVersion = 2\n         tx3.vin = [CTxIn(COutPoint(tx2.sha256, 0), nSequence=sequence_value)]\n-        tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n+        tx3.wit.vtxinwit = [CTxInWitness()]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee * COIN), SCRIPT_W0_SH_OP_TRUE)]\n         tx3.rehash()\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, tx3.serialize().hex())\n\n\n###\n\n", "completion": "test: Remove confusing DUMMY_P2WPKH_SCRIPT"}
{"prompt": " file path A: test/functional/feature_config_args.py | file path B: test/functional/feature_config_args.py\n\n@@ -20,11 +20,25 @@ class ConfArgsTest(BitcoinTestFramework):\n         self.disable_autoconnect = False\n \n     def test_config_file_parser(self):\n+        self.log.info('Test config file parser')\n         self.stop_node(0)\n \n+        # Check that startup fails if conf= is set in bitcoin.conf or in an included conf file\n+        bad_conf_file_path = os.path.join(self.options.tmpdir, 'node0', 'bitcoin_bad.conf')\n+        util.write_config(bad_conf_file_path, n=0, chain='', extra_config=f'conf=some.conf\\n')\n+        conf_in_config_file_err = 'Error: Error reading configuration file: conf cannot be set in the configuration file; use includeconf= if you want to include additional config files'\n+        self.nodes[0].assert_start_raises_init_error(\n+            extra_args=[f'-conf={bad_conf_file_path}'],\n+            expected_msg=conf_in_config_file_err,\n+        )\n         inc_conf_file_path = os.path.join(self.nodes[0].datadir, 'include.conf')\n         with open(os.path.join(self.nodes[0].datadir, 'bitcoin.conf'), 'a', encoding='utf-8') as conf:\n             conf.write(f'includeconf={inc_conf_file_path}\\n')\n+        with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n+            conf.write('conf=some.conf\\n')\n+        self.nodes[0].assert_start_raises_init_error(\n+            expected_msg=conf_in_config_file_err,\n+        )\n \n         self.nodes[0].assert_start_raises_init_error(\n             expected_msg='Error: Error parsing command line arguments: Invalid parameter -dash_cli=1',\n@@ -32,10 +46,18 @@ class ConfArgsTest(BitcoinTestFramework):\n         )\n         with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n             conf.write('dash_conf=1\\n')\n+\n         with self.nodes[0].assert_debug_log(expected_msgs=['Ignoring unknown configuration value dash_conf']):\n             self.start_node(0)\n         self.stop_node(0)\n \n+        with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n+            conf.write('reindex=1\\n')\n+\n+        with self.nodes[0].assert_debug_log(expected_msgs=['Warning: reindex=1 is set in the configuration file, which will significantly slow down startup. Consider removing or commenting out this option for better performance, unless there is currently a condition which makes rebuilding the indexes necessary']):\n+            self.start_node(0)\n+        self.stop_node(0)\n+\n         with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n             conf.write('-dash=1\\n')\n         self.nodes[0].assert_start_raises_init_error(expected_msg='Error: Error reading configuration file: parse error on line 1: -dash=1, options in configuration file must be specified without leading -')\n\n\n###\n\n", "completion": "test: update feature_config_args.py"}
{"prompt": " file path A: src/test/minisketch_tests.cpp | file path B: src/test/minisketch_tests.cpp\n\n@@ -40,7 +40,7 @@ BOOST_AUTO_TEST_CASE(minisketch_test)\n         Minisketch sketch_c = std::move(sketch_ar);\n         sketch_c.Merge(sketch_br);\n         auto dec = sketch_c.Decode(errors);\n-        BOOST_CHECK(dec.has_value());\n+        BOOST_REQUIRE(dec.has_value());\n         auto sols = std::move(*dec);\n         std::sort(sols.begin(), sols.end());\n         for (uint32_t i = 0; i < a_not_b; ++i) BOOST_CHECK_EQUAL(sols[i], start_a + i);\n\n\n###\n\n", "completion": "test: Prevent UB in `minisketch_tests.cpp`"}
{"prompt": " file path A: src/txmempool.h | file path B: src/txmempool.h\n\n@@ -547,10 +547,16 @@ private:\n     /**\n      * Helper function to calculate all in-mempool ancestors of staged_ancestors and apply ancestor\n      * and descendant limits (including staged_ancestors thsemselves, entry_size and entry_count).\n-     * param@[in]   entry_size          Virtual size to include in the limits.\n-     * param@[in]   entry_count         How many entries to include in the limits.\n-     * param@[in]   staged_ancestors    Should contain entries in the mempool.\n-     * param@[out]  setAncestors        Will be populated with all mempool ancestors.\n+     *\n+     * @param[in]   entry_size          Virtual size to include in the limits.\n+     * @param[in]   entry_count         How many entries to include in the limits.\n+     * @param[out]  setAncestors        Will be populated with all mempool ancestors.\n+     * @param[in]   staged_ancestors    Should contain entries in the mempool.\n+     * @param[in]   limits              Maximum number and size of ancestors and descendants\n+     * @param[out]  errString           Populated with error reason if any limits are hit\n+     *\n+     * @return true if no limits were hit and all in-mempool ancestors were calculated, false\n+     * otherwise\n      */\n     bool CalculateAncestorsAndCheckLimits(size_t entry_size,\n                                           size_t entry_count,\n@@ -665,12 +671,20 @@ public:\n      */\n     void UpdateTransactionsFromBlock(const std::vector<uint256>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main) LOCKS_EXCLUDED(m_epoch);\n \n-    /** Try to calculate all in-mempool ancestors of entry.\n-     *  (these are all calculated including the tx itself)\n-     *  limits = maximum number and size of ancestors and descendants\n-     *  errString = populated with error reason if any limits are hit\n-     *  fSearchForParents = whether to search a tx's vin for in-mempool parents, or\n-     *    look up parents from mapLinks. Must be true for entries not in the mempool\n+    /**\n+     * Try to calculate all in-mempool ancestors of entry.\n+     * (these are all calculated including the tx itself)\n+     *\n+     * @param[in]   entry               CTxMemPoolEntry of which all in-mempool ancestors are calculated\n+     * @param[out]  setAncestors        Will be populated with all mempool ancestors.\n+     * @param[in]   limits              Maximum number and size of ancestors and descendants\n+     * @param[out]  errString           Populated with error reason if any limits are hit\n+     * @param[in]   fSearchForParents   Whether to search a tx's vin for in-mempool parents, or look\n+     *                                  up parents from mapLinks. Must be true for entries not in\n+     *                                  the mempool\n+     *\n+     * @return true if no limits were hit and all in-mempool ancestors were calculated, false\n+     * otherwise\n      */\n     bool CalculateMemPoolAncestors(const CTxMemPoolEntry& entry,\n                                    setEntries& setAncestors,\n\n\n###\n\n", "completion": "docs: improve docs where MemPoolLimits is used"}
{"prompt": " file path A: src/test/mempool_tests.cpp | file path B: src/test/mempool_tests.cpp\n\n@@ -203,7 +203,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n \n     CTxMemPool::setEntries setAncestorsCalculated;\n     std::string dummy;\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(2000000LL).FromTx(tx7), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(2'000'000LL).FromTx(tx7), setAncestorsCalculated, CTxMemPool::Limits::NoLimits(), dummy), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(entry.FromTx(tx7), setAncestors);\n@@ -261,7 +261,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx10.vout[0].nValue = 10 * COIN;\n \n     setAncestorsCalculated.clear();\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(200000LL).Time(4).FromTx(tx10), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(200'000LL).Time(4).FromTx(tx10), setAncestorsCalculated, CTxMemPool::Limits::NoLimits(), dummy), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(entry.FromTx(tx10), setAncestors);\n\n\n###\n\n", "completion": "test: use NoLimits() in MempoolIndexingTest"}
{"prompt": " file path A: src/kernel/mempool_limits.h | file path B: src/kernel/mempool_limits.h\n\n@@ -24,6 +24,15 @@ struct MemPoolLimits {\n     int64_t descendant_count{DEFAULT_DESCENDANT_LIMIT};\n     //! The maximum allowed size in virtual bytes of an entry and its descendants within a package.\n     int64_t descendant_size_vbytes{DEFAULT_DESCENDANT_SIZE_LIMIT_KVB * 1'000};\n+\n+    /**\n+     * @return MemPoolLimits with all the limits set to the maximum\n+     */\n+    static constexpr MemPoolLimits NoLimits()\n+    {\n+        int64_t no_limit{std::numeric_limits<int64_t>::max()};\n+        return {no_limit, no_limit, no_limit, no_limit};\n+    }\n };\n } // namespace kernel\n \n\n\n###\n\n", "completion": "refactor: mempool: add MemPoolLimits::NoLimits()"}
{"prompt": " file path A: src/test/miner_tests.cpp | file path B: src/test/miner_tests.cpp\n\n@@ -30,7 +30,7 @@ using node::CBlockTemplate;\n \n namespace miner_tests {\n struct MinerTestingSetup : public TestingSetup {\n-    void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n+    void TestPackageSelection(const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n     void TestBasicMining(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst, int baseheight) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n     void TestPrioritisedMining(const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n     bool TestSequenceLocks(const CTransaction& tx) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs)\n@@ -98,9 +98,10 @@ static CBlockIndex CreateBlockIndex(int nHeight, CBlockIndex* active_chain_tip)\n // Test suite for ancestor feerate transaction selection.\n // Implemented as an additional function, rather than a separate test case,\n // to allow reusing the blockchain created in CreateNewBlock_validity.\n-void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n+void MinerTestingSetup::TestPackageSelection(const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n {\n-    CTxMemPool& tx_mempool{*m_node.mempool};\n+    CTxMemPool& tx_mempool{MakeMempool()};\n+    LOCK(tx_mempool.cs);\n     // Test the ancestor feerate transaction selection.\n     TestMemPoolEntryHelper entry;\n \n@@ -115,19 +116,19 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 1000;\n     // This tx has a low fee: 1000 satoshis\n     uint256 hashParentTx = tx.GetHash(); // save this txid for later use\n-    m_node.mempool->addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx has a medium fee: 10000 satoshis\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vout[0].nValue = 5000000000LL - 10000;\n     uint256 hashMediumFeeTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx has a high fee, but depends on the first transaction\n     tx.vin[0].prevout.hash = hashParentTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000; // 50k satoshi fee\n     uint256 hashHighFeeTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n     std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);\n@@ -139,7 +140,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.hash = hashHighFeeTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000; // 0 fee\n     uint256 hashFreeTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(0).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(0).FromTx(tx));\n     size_t freeTxSize = ::GetSerializeSize(tx, PROTOCOL_VERSION);\n \n     // Calculate a fee on child transaction that will put the package just\n@@ -149,7 +150,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.hash = hashFreeTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n     uint256 hashLowFeeTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n     pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n@@ -160,10 +161,10 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     // Test that packages above the min relay fee do get included, even if one\n     // of the transactions is below the min relay fee\n     // Remove the low fee transaction and replace with a higher fee transaction\n-    m_node.mempool->removeRecursive(CTransaction(tx), MemPoolRemovalReason::REPLACED);\n+    tx_mempool.removeRecursive(CTransaction(tx), MemPoolRemovalReason::REPLACED);\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(feeToUse + 2).FromTx(tx));\n     pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);\n@@ -177,7 +178,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 100000000;\n     tx.vout[1].nValue = 100000000; // 1BTC output\n     uint256 hashFreeTx2 = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx can't be mined by itself\n     tx.vin[0].prevout.hash = hashFreeTx2;\n@@ -185,7 +186,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     feeToUse = blockMinFeeRate.GetFee(freeTxSize);\n     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n     uint256 hashLowFeeTx2 = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n     pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n \n     // Verify that this tx isn't selected.\n@@ -198,7 +199,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     // as well.\n     tx.vin[0].prevout.n = 1;\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n-    m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(10000).FromTx(tx));\n     pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 9U);\n     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);\n@@ -612,9 +613,8 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     m_node.chainman->ActiveChain().Tip()->nHeight--;\n     SetMockTime(0);\n-    m_node.mempool->clear();\n \n-    TestPackageSelection(chainparams, scriptPubKey, txFirst);\n+    TestPackageSelection(scriptPubKey, txFirst);\n \n     m_node.chainman->ActiveChain().Tip()->nHeight--;\n     SetMockTime(0);\n\n\n###\n\n", "completion": "test: Use dedicated mempool in TestPackageSelection"}
{"prompt": " file path A: src/test/miner_tests.cpp | file path B: src/test/miner_tests.cpp\n\n@@ -32,12 +32,21 @@ namespace miner_tests {\n struct MinerTestingSetup : public TestingSetup {\n     void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n     void TestBasicMining(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst, int baseheight) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n-    void TestPrioritisedMining(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n+    void TestPrioritisedMining(const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n     bool TestSequenceLocks(const CTransaction& tx) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs)\n     {\n         CCoinsViewMemPool view_mempool(&m_node.chainman->ActiveChainstate().CoinsTip(), *m_node.mempool);\n         return CheckSequenceLocksAtTip(m_node.chainman->ActiveChain().Tip(), view_mempool, tx);\n     }\n+    CTxMemPool& MakeMempool()\n+    {\n+        // Delete the previous mempool to ensure with valgrind that the old\n+        // pointer is not accessed, when the new one should be accessed\n+        // instead.\n+        m_node.mempool.reset();\n+        m_node.mempool = std::make_unique<CTxMemPool>(MemPoolOptionsForTest(m_node));\n+        return *m_node.mempool;\n+    }\n     BlockAssembler AssemblerForTest(CTxMemPool& tx_mempool);\n };\n } // namespace miner_tests\n@@ -476,9 +485,10 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n }\n \n-void MinerTestingSetup::TestPrioritisedMining(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n+void MinerTestingSetup::TestPrioritisedMining(const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n {\n-    CTxMemPool& tx_mempool{*m_node.mempool};\n+    CTxMemPool& tx_mempool{MakeMempool()};\n+    LOCK(tx_mempool.cs);\n \n     TestMemPoolEntryHelper entry;\n \n@@ -491,29 +501,29 @@ void MinerTestingSetup::TestPrioritisedMining(const CChainParams& chainparams, c\n     tx.vout.resize(1);\n     tx.vout[0].nValue = 5000000000LL; // 0 fee\n     uint256 hashFreePrioritisedTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(0).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    m_node.mempool->PrioritiseTransaction(hashFreePrioritisedTx, 5 * COIN);\n+    tx_mempool.addUnchecked(entry.Fee(0).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.PrioritiseTransaction(hashFreePrioritisedTx, 5 * COIN);\n \n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vin[0].prevout.n = 0;\n     tx.vout[0].nValue = 5000000000LL - 1000;\n     // This tx has a low fee: 1000 satoshis\n     uint256 hashParentTx = tx.GetHash(); // save this txid for later use\n-    m_node.mempool->addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx has a medium fee: 10000 satoshis\n     tx.vin[0].prevout.hash = txFirst[2]->GetHash();\n     tx.vout[0].nValue = 5000000000LL - 10000;\n     uint256 hashMediumFeeTx = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    m_node.mempool->PrioritiseTransaction(hashMediumFeeTx, -5 * COIN);\n+    tx_mempool.addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.PrioritiseTransaction(hashMediumFeeTx, -5 * COIN);\n \n     // This tx also has a low fee, but is prioritised\n     tx.vin[0].prevout.hash = hashParentTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 1000; // 1000 satoshi fee\n     uint256 hashPrioritsedChild = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n-    m_node.mempool->PrioritiseTransaction(hashPrioritsedChild, 2 * COIN);\n+    tx_mempool.addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n+    tx_mempool.PrioritiseTransaction(hashPrioritsedChild, 2 * COIN);\n \n     // Test that transaction selection properly updates ancestor fee calculations as prioritised\n     // parents get included in a block. Create a transaction with two prioritised ancestors, each\n@@ -524,19 +534,19 @@ void MinerTestingSetup::TestPrioritisedMining(const CChainParams& chainparams, c\n     tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n     tx.vout[0].nValue = 5000000000LL; // 0 fee\n     uint256 hashFreeParent = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n-    m_node.mempool->PrioritiseTransaction(hashFreeParent, 10 * COIN);\n+    tx_mempool.addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n+    tx_mempool.PrioritiseTransaction(hashFreeParent, 10 * COIN);\n \n     tx.vin[0].prevout.hash = hashFreeParent;\n     tx.vout[0].nValue = 5000000000LL; // 0 fee\n     uint256 hashFreeChild = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(0).SpendsCoinbase(false).FromTx(tx));\n-    m_node.mempool->PrioritiseTransaction(hashFreeChild, 1 * COIN);\n+    tx_mempool.addUnchecked(entry.Fee(0).SpendsCoinbase(false).FromTx(tx));\n+    tx_mempool.PrioritiseTransaction(hashFreeChild, 1 * COIN);\n \n     tx.vin[0].prevout.hash = hashFreeChild;\n     tx.vout[0].nValue = 5000000000LL; // 0 fee\n     uint256 hashFreeGrandchild = tx.GetHash();\n-    m_node.mempool->addUnchecked(entry.Fee(0).SpendsCoinbase(false).FromTx(tx));\n+    tx_mempool.addUnchecked(entry.Fee(0).SpendsCoinbase(false).FromTx(tx));\n \n     auto pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n@@ -608,9 +618,8 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     m_node.chainman->ActiveChain().Tip()->nHeight--;\n     SetMockTime(0);\n-    m_node.mempool->clear();\n \n-    TestPrioritisedMining(chainparams, scriptPubKey, txFirst);\n+    TestPrioritisedMining(scriptPubKey, txFirst);\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: Use dedicated mempool in TestPrioritisedMining"}
{"prompt": " file path A: src/test/miner_tests.cpp | file path B: src/test/miner_tests.cpp\n\n@@ -38,7 +38,7 @@ struct MinerTestingSetup : public TestingSetup {\n         CCoinsViewMemPool view_mempool(&m_node.chainman->ActiveChainstate().CoinsTip(), *m_node.mempool);\n         return CheckSequenceLocksAtTip(m_node.chainman->ActiveChain().Tip(), view_mempool, tx);\n     }\n-    BlockAssembler AssemblerForTest(const CChainParams& params);\n+    BlockAssembler AssemblerForTest(CTxMemPool& tx_mempool);\n };\n } // namespace miner_tests\n \n@@ -46,13 +46,13 @@ BOOST_FIXTURE_TEST_SUITE(miner_tests, MinerTestingSetup)\n \n static CFeeRate blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n \n-BlockAssembler MinerTestingSetup::AssemblerForTest(const CChainParams& params)\n+BlockAssembler MinerTestingSetup::AssemblerForTest(CTxMemPool& tx_mempool)\n {\n     BlockAssembler::Options options;\n \n     options.nBlockMaxWeight = MAX_BLOCK_WEIGHT;\n     options.blockMinFeeRate = blockMinFeeRate;\n-    return BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options};\n+    return BlockAssembler{m_node.chainman->ActiveChainstate(), &tx_mempool, options};\n }\n \n constexpr static struct {\n@@ -91,6 +91,7 @@ static CBlockIndex CreateBlockIndex(int nHeight, CBlockIndex* active_chain_tip)\n // to allow reusing the blockchain created in CreateNewBlock_validity.\n void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n {\n+    CTxMemPool& tx_mempool{*m_node.mempool};\n     // Test the ancestor feerate transaction selection.\n     TestMemPoolEntryHelper entry;\n \n@@ -119,7 +120,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     uint256 hashHighFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n-    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);\n     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashHighFeeTx);\n@@ -140,7 +141,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n     uint256 hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n         BOOST_CHECK(pblocktemplate->block.vtx[i]->GetHash() != hashFreeTx);\n@@ -154,7 +155,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[5]->GetHash() == hashLowFeeTx);\n@@ -176,7 +177,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n     uint256 hashLowFeeTx2 = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n \n     // Verify that this tx isn't selected.\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n@@ -189,13 +190,14 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.n = 1;\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n     m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 9U);\n     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);\n }\n \n void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst, int baseheight)\n {\n+    CTxMemPool& tx_mempool{*m_node.mempool};\n     uint256 hash;\n     CMutableTransaction tx;\n     TestMemPoolEntryHelper entry;\n@@ -203,7 +205,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     entry.nHeight = 11;\n \n     // Just to make sure we can still make simple blocks\n-    auto pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    auto pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_CHECK(pblocktemplate);\n \n     const CAmount BLOCKSUBSIDY = 50*COIN;\n@@ -229,7 +231,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n         tx.vin[0].prevout.hash = hash;\n     }\n \n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n     m_node.mempool->clear();\n \n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -243,7 +245,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n     m_node.mempool->clear();\n \n     // block size > limit\n@@ -263,13 +265,13 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n     m_node.mempool->clear();\n \n     // orphan in *m_node.mempool, template creation fails\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // child with higher feerate than parent\n@@ -286,7 +288,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n     m_node.mempool->clear();\n \n     // coinbase in *m_node.mempool, template creation fails\n@@ -298,7 +300,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     // give it a fee so it'll get mined\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw bad-cb-multiple\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n     m_node.mempool->clear();\n \n     // double spend txn pair in *m_node.mempool, template creation fails\n@@ -311,7 +313,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // subsidy changing\n@@ -327,7 +329,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n         next->BuildSkip();\n         m_node.chainman->ActiveChain().SetTip(*next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n     // Extend to a 210000-long block chain.\n     while (m_node.chainman->ActiveChain().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = m_node.chainman->ActiveChain().Tip();\n@@ -339,7 +341,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n         next->BuildSkip();\n         m_node.chainman->ActiveChain().SetTip(*next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n \n     // invalid p2sh txn in *m_node.mempool, template creation fails\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -356,7 +358,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw block-validation-failed\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n     m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n@@ -455,7 +457,7 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n     BOOST_CHECK(!TestSequenceLocks(CTransaction{tx})); // Sequence locks fail\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n \n     // None of the of the absolute height/time locked tx should have made\n     // it into the template because we still check IsFinalTx in CreateNewBlock,\n@@ -470,12 +472,14 @@ void MinerTestingSetup::TestBasicMining(const CChainParams& chainparams, const C\n     m_node.chainman->ActiveChain().Tip()->nHeight++;\n     SetMockTime(m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n }\n \n void MinerTestingSetup::TestPrioritisedMining(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n {\n+    CTxMemPool& tx_mempool{*m_node.mempool};\n+\n     TestMemPoolEntryHelper entry;\n \n     // Test that a tx below min fee but prioritised is included\n@@ -534,7 +538,7 @@ void MinerTestingSetup::TestPrioritisedMining(const CChainParams& chainparams, c\n     uint256 hashFreeGrandchild = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(0).SpendsCoinbase(false).FromTx(tx));\n \n-    auto pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    auto pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashFreeParent);\n     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashFreePrioritisedTx);\n@@ -558,8 +562,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     std::unique_ptr<CBlockTemplate> pblocktemplate;\n \n+    CTxMemPool& tx_mempool{*m_node.mempool};\n     // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 110 blocks :)\n\n\n###\n\n", "completion": "test: Pass mempool reference to AssemblerForTest"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -133,6 +133,7 @@ BITCOIN_CORE_H = \\\n   clientversion.h \\\n   coins.h \\\n   common/bloom.h \\\n+  common/run_command.h \\\n   compat/assumptions.h \\\n   compat/byteswap.h \\\n   compat/compat.h \\\n@@ -284,7 +285,6 @@ BITCOIN_CORE_H = \\\n   util/rbf.h \\\n   util/readwritefile.h \\\n   util/result.h \\\n-  util/run_command.h \\\n   util/serfloat.h \\\n   util/settings.h \\\n   util/sock.h \\\n@@ -617,7 +617,7 @@ libbitcoin_consensus_a_SOURCES = \\\n   version.h\n \n # common: shared between bitcoind, and bitcoin-qt and non-server tools\n-libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n   base58.cpp \\\n@@ -625,6 +625,7 @@ libbitcoin_common_a_SOURCES = \\\n   chainparams.cpp \\\n   coins.cpp \\\n   common/bloom.cpp \\\n+  common/run_command.cpp \\\n   compressor.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\\n@@ -681,7 +682,6 @@ libbitcoin_util_a_SOURCES = \\\n   util/fees.cpp \\\n   util/getuniquepath.cpp \\\n   util/hasher.cpp \\\n-  util/run_command.cpp \\\n   util/sock.cpp \\\n   util/syserror.cpp \\\n   util/system.cpp \\\n\n---\n file path A: src/util/run_command.cpp | file path B: src/common/run_command.cpp\n\n@@ -6,7 +6,7 @@\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <util/run_command.h>\n+#include <common/run_command.h>\n \n #include <tinyformat.h>\n #include <univalue.h>\n\n---\n file path A: src/util/run_command.h | file path B: src/common/run_command.h\n\n@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_UTIL_RUN_COMMAND_H\n-#define BITCOIN_UTIL_RUN_COMMAND_H\n+#ifndef BITCOIN_COMMON_RUN_COMMAND_H\n+#define BITCOIN_COMMON_RUN_COMMAND_H\n \n #include <string>\n \n@@ -18,4 +18,4 @@ class UniValue;\n  */\n UniValue RunCommandParseJSON(const std::string& str_command, const std::string& str_std_in=\"\");\n \n-#endif // BITCOIN_UTIL_RUN_COMMAND_H\n+#endif // BITCOIN_COMMON_RUN_COMMAND_H\n\n---\n file path A: src/external_signer.cpp | file path B: src/external_signer.cpp\n\n@@ -3,9 +3,9 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <chainparams.h>\n+#include <common/run_command.h>\n #include <core_io.h>\n #include <psbt.h>\n-#include <util/run_command.h>\n #include <util/strencodings.h>\n #include <external_signer.h>\n \n\n---\n file path A: src/test/system_tests.cpp | file path B: src/test/system_tests.cpp\n\n@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n #include <test/util/setup_common.h>\n-#include <util/run_command.h>\n+#include <common/run_command.h>\n #include <univalue.h>\n \n #ifdef ENABLE_EXTERNAL_SIGNER\n\n\n###\n\n", "completion": "refactor: move run_command from util to common"}
{"prompt": " file path A: build_msvc/common.init.vcxproj.in | file path B: build_msvc/common.init.vcxproj.in\n\n@@ -88,7 +88,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <PrecompiledHeader>NotUsing</PrecompiledHeader>\n       <AdditionalOptions>/utf-8 /Zc:__cplusplus /std:c++20 %(AdditionalOptions)</AdditionalOptions>\n-      <DisableSpecificWarnings>4018;4244;4267;4334;4715;4805</DisableSpecificWarnings>\n+      <DisableSpecificWarnings>4018;4244;4267;4715;4805</DisableSpecificWarnings>\n       <TreatWarningAsError>true</TreatWarningAsError>\n       <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;ZMQ_STATIC;NOMINMAX;WIN32;HAVE_CONFIG_H;_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;_CONSOLE;_WIN32_WINNT=0x0601;_WIN32_IE=0x0501;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n       <AdditionalIncludeDirectories>..\\..\\src;..\\..\\src\\minisketch\\include;..\\..\\src\\univalue\\include;..\\..\\src\\secp256k1\\include;..\\..\\src\\leveldb\\include;..\\..\\src\\leveldb\\helpers\\memenv;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n\n---\n file path A: src/bech32.cpp | file path B: src/bech32.cpp\n\n@@ -241,7 +241,7 @@ constexpr std::array<uint32_t, 25> GenerateSyndromeConstants() {\n     std::array<uint32_t, 25> SYNDROME_CONSTS{};\n     for (int k = 1; k < 6; ++k) {\n         for (int shift = 0; shift < 5; ++shift) {\n-            int16_t b = GF1024_LOG.at(1 << shift);\n+            int16_t b = GF1024_LOG.at(size_t{1} << shift);\n             int16_t c0 = GF1024_EXP.at((997*k + b) % 1023);\n             int16_t c1 = GF1024_EXP.at((998*k + b) % 1023);\n             int16_t c2 = GF1024_EXP.at((999*k + b) % 1023);\n\n\n###\n\n", "completion": "refactor: Make 64-bit shift explicit"}
{"prompt": " file path A: None | file path B: test/functional/rpc_scanblocks.py\n\n@@ -0,0 +1,93 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scanblocks RPC call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, assert_raises_rpc_error\n+\n+\n+class ScanblocksTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-blockfilterindex=1\"], []]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        # send 1.0, mempool only\n+        addr_1 = node.getnewaddress()\n+        node.sendtoaddress(addr_1, 1.0)\n+\n+        parent_key = \"tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B\"\n+        # send 1.0, mempool only\n+        # childkey 5 of `parent_key`\n+        node.sendtoaddress(\"mkS4HXoTYWRTescLGaUTGbtTTYX5EjJyEE\", 1.0)\n+\n+        # mine a block and assure that the mined blockhash is in the filterresult\n+        blockhash = self.generate(node, 1)[0]\n+        height = node.getblockheader(blockhash)['height']\n+        self.wait_until(lambda: all(i[\"synced\"] for i in node.getindexinfo().values()))\n+\n+        out = node.scanblocks(\"start\", [f\"addr({addr_1})\"])\n+        assert(blockhash in out['relevant_blocks'])\n+        assert_equal(height, out['to_height'])\n+        assert_equal(0, out['from_height'])\n+\n+        # mine another block\n+        blockhash_new = self.generate(node, 1)[0]\n+        height_new = node.getblockheader(blockhash_new)['height']\n+\n+        # make sure the blockhash is not in the filter result if we set the start_height\n+        # to the just mined block (unlikely to hit a false positive)\n+        assert(blockhash not in node.scanblocks(\n+            \"start\", [f\"addr({addr_1})\"], height_new)['relevant_blocks'])\n+\n+        # make sure the blockhash is present when using the first mined block as start_height\n+        assert(blockhash in node.scanblocks(\n+            \"start\", [f\"addr({addr_1})\"], height)['relevant_blocks'])\n+\n+        # also test the stop height\n+        assert(blockhash in node.scanblocks(\n+            \"start\", [f\"addr({addr_1})\"], height, height)['relevant_blocks'])\n+\n+        # use the stop_height to exclude the relevant block\n+        assert(blockhash not in node.scanblocks(\n+            \"start\", [f\"addr({addr_1})\"], 0, height - 1)['relevant_blocks'])\n+\n+        # make sure the blockhash is present when using the first mined block as start_height\n+        assert(blockhash in node.scanblocks(\n+            \"start\", [{\"desc\": f\"pkh({parent_key}/*)\", \"range\": [0, 100]}], height)['relevant_blocks'])\n+\n+        # test node with disabled blockfilterindex\n+        assert_raises_rpc_error(-1, \"Index is not enabled for filtertype basic\",\n+                                self.nodes[1].scanblocks, \"start\", [f\"addr({addr_1})\"])\n+\n+        # test unknown filtertype\n+        assert_raises_rpc_error(-5, \"Unknown filtertype\",\n+                                node.scanblocks, \"start\", [f\"addr({addr_1})\"], 0, 10, \"extended\")\n+\n+        # test invalid start_height\n+        assert_raises_rpc_error(-1, \"Invalid start_height\",\n+                                node.scanblocks, \"start\", [f\"addr({addr_1})\"], 100000000)\n+\n+        # test invalid stop_height\n+        assert_raises_rpc_error(-1, \"Invalid stop_height\",\n+                                node.scanblocks, \"start\", [f\"addr({addr_1})\"], 10, 0)\n+        assert_raises_rpc_error(-1, \"Invalid stop_height\",\n+                                node.scanblocks, \"start\", [f\"addr({addr_1})\"], 10, 100000000)\n+\n+        # test accessing the status (must be empty)\n+        assert_equal(node.scanblocks(\"status\"), None)\n+\n+        # test aborting the current scan (there is no, must return false)\n+        assert_equal(node.scanblocks(\"abort\"), False)\n+\n+        # test invalid command\n+        assert_raises_rpc_error(-8, \"Invalid command\", node.scanblocks, \"foobar\")\n+\n+\n+if __name__ == '__main__':\n+    ScanblocksTest().main()\n\n---\n file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -316,6 +316,7 @@ BASE_SCRIPTS = [\n     'rpc_deriveaddresses.py',\n     'rpc_deriveaddresses.py --usecli',\n     'p2p_ping.py',\n+    'rpc_scanblocks.py',\n     'rpc_scantxoutset.py',\n     'feature_txindex_compatibility.py',\n     'feature_unsupported_utxo_db.py',\n\n\n###\n\n", "completion": "test: rpc: add scanblocks functional test"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -114,7 +114,7 @@ task:\n     QT_CONFIGURE_COMMAND: '..\\configure -release -silent -opensource -confirm-license -opengl desktop -static -static-runtime -mp -qt-zlib -qt-pcre -qt-libpng -nomake examples -nomake tests -nomake tools -no-angle -no-dbus -no-gif -no-gtk -no-ico -no-icu -no-libjpeg -no-libudev -no-sql-sqlite -no-sql-odbc -no-sqlite -no-vulkan -skip qt3d -skip qtactiveqt -skip qtandroidextras -skip qtcharts -skip qtconnectivity -skip qtdatavis3d -skip qtdeclarative -skip doc -skip qtdoc -skip qtgamepad -skip qtgraphicaleffects -skip qtimageformats -skip qtlocation -skip qtlottie -skip qtmacextras -skip qtmultimedia -skip qtnetworkauth -skip qtpurchasing -skip qtquick3d -skip qtquickcontrols -skip qtquickcontrols2 -skip qtquicktimeline -skip qtremoteobjects -skip qtscript -skip qtscxml -skip qtsensors -skip qtserialbus -skip qtserialport -skip qtspeech -skip qtsvg -skip qtvirtualkeyboard -skip qtwayland -skip qtwebchannel -skip qtwebengine -skip qtwebglplugin -skip qtwebsockets -skip qtwebview -skip qtx11extras -skip qtxmlpatterns -no-openssl -no-feature-bearermanagement -no-feature-printdialog -no-feature-printer -no-feature-printpreviewdialog -no-feature-printpreviewwidget -no-feature-sql -no-feature-sqlmodel -no-feature-textbrowser -no-feature-textmarkdownwriter -no-feature-textodfwriter -no-feature-xml'\n     IgnoreWarnIntDirInTempDetected: 'true'\n   merge_script:\n-    - PowerShell -NoLogo -Command if ($env:CIRRUS_PR -ne $null) { git fetch $env:CIRRUS_REPO_CLONE_URL pull/$env:CIRRUS_PR/merge; git checkout FETCH_HEAD; }\n+    - PowerShell -NoLogo -Command if ($env:CIRRUS_PR -ne $null) { git fetch $env:CIRRUS_REPO_CLONE_URL pull/$env:CIRRUS_PR/merge; git reset --hard FETCH_HEAD; }\n   msvc_qt_built_cache:\n     folder: \"%QTBASEDIR%\"\n     reupload_on_changes: false\n\n\n###\n\n", "completion": "ci: Workaround Windows filesystem executable bit loss"}
{"prompt": " file path A: src/test/miner_tests.cpp | file path B: src/test/miner_tests.cpp\n\n@@ -558,8 +558,6 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     std::unique_ptr<CBlockTemplate> pblocktemplate;\n \n-    fCheckpointsEnabled = false;\n-\n     // Simple block creation, nothing special yet:\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n@@ -608,8 +606,6 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     m_node.mempool->clear();\n \n     TestPrioritisedMining(chainparams, scriptPubKey, txFirst);\n-\n-    fCheckpointsEnabled = true;\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: Remove unused fCheckpointsEnabled from miner_tests"}
{"prompt": " file path A: ci/test/00_setup_env_i686_centos.sh | file path B: ci/test/00_setup_env_i686_centos.sh\n\n@@ -9,7 +9,8 @@ export LC_ALL=C.UTF-8\n export HOST=i686-pc-linux-gnu\n export CONTAINER_NAME=ci_i686_centos\n export DOCKER_NAME_TAG=quay.io/centos/centos:stream8\n-export DOCKER_PACKAGES=\"gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-zmq which patch lbzip2 xz procps-ng dash rsync coreutils bison\"\n+export DOCKER_PACKAGES=\"gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-pip which patch lbzip2 xz procps-ng dash rsync coreutils bison\"\n+export PIP_PACKAGES=\"pyzmq\"\n export GOAL=\"install\"\n export BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-reduce-exports\"\n export CONFIG_SHELL=\"/bin/dash\"\n\n---\n file path A: ci/test/04_install.sh | file path B: ci/test/04_install.sh\n\n@@ -10,12 +10,6 @@ if [[ $QEMU_USER_CMD == qemu-s390* ]]; then\n   export LC_ALL=C\n fi\n \n-if [ \"$CI_OS_NAME\" == \"macos\" ]; then\n-  sudo -H pip3 install --upgrade pip\n-  # shellcheck disable=SC2086\n-  IN_GETOPT_BIN=\"/usr/local/opt/gnu-getopt/bin/getopt\" ${CI_RETRY_EXE} pip3 install --user $PIP_PACKAGES\n-fi\n-\n # Create folders that are mounted into the docker\n mkdir -p \"${CCACHE_DIR}\"\n mkdir -p \"${PREVIOUS_RELEASES_DIR}\"\n@@ -78,9 +72,16 @@ elif [ \"$CI_USE_APT_INSTALL\" != \"no\" ]; then\n   fi\n   ${CI_RETRY_EXE} CI_EXEC apt-get update\n   ${CI_RETRY_EXE} CI_EXEC apt-get install --no-install-recommends --no-upgrade -y \"$PACKAGES\" \"$DOCKER_PACKAGES\"\n-  if [ -n \"$PIP_PACKAGES\" ]; then\n+fi\n+\n+if [ -n \"$PIP_PACKAGES\" ]; then\n+  if [ \"$CI_OS_NAME\" == \"macos\" ]; then\n+    sudo -H pip3 install --upgrade pip\n+    # shellcheck disable=SC2086\n+    IN_GETOPT_BIN=\"/usr/local/opt/gnu-getopt/bin/getopt\" ${CI_RETRY_EXE} pip3 install --user $PIP_PACKAGES\n+  else\n     # shellcheck disable=SC2086\n-    ${CI_RETRY_EXE} pip3 install --user $PIP_PACKAGES\n+    ${CI_RETRY_EXE} CI_EXEC pip3 install --user $PIP_PACKAGES\n   fi\n fi\n \n\n\n###\n\n", "completion": "ci: Allow PIP_PACKAGES on centos"}
{"prompt": " file path A: ci/test/00_setup_env_i686_multiprocess.sh | file path B: ci/test/00_setup_env_i686_multiprocess.sh\n\n@@ -9,7 +9,7 @@ export LC_ALL=C.UTF-8\n export HOST=i686-pc-linux-gnu\n export CONTAINER_NAME=ci_i686_multiprocess\n export DOCKER_NAME_TAG=ubuntu:20.04\n-export PACKAGES=\"cmake python3 python3-pip llvm clang g++-multilib\"\n+export PACKAGES=\"cmake python3 llvm clang g++-multilib\"\n export DEP_OPTS=\"DEBUG=1 MULTIPROCESS=1\"\n export GOAL=\"install\"\n export BITCOIN_CONFIG=\"--enable-debug CC='clang -m32' CXX='clang++ -m32' LDFLAGS='--rtlib=compiler-rt -lgcc_s'\"\n\n\n###\n\n", "completion": "ci: Remove unused package"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -114,14 +114,7 @@ task:\n     QT_CONFIGURE_COMMAND: '..\\configure -release -silent -opensource -confirm-license -opengl desktop -static -static-runtime -mp -qt-zlib -qt-pcre -qt-libpng -nomake examples -nomake tests -nomake tools -no-angle -no-dbus -no-gif -no-gtk -no-ico -no-icu -no-libjpeg -no-libudev -no-sql-sqlite -no-sql-odbc -no-sqlite -no-vulkan -skip qt3d -skip qtactiveqt -skip qtandroidextras -skip qtcharts -skip qtconnectivity -skip qtdatavis3d -skip qtdeclarative -skip doc -skip qtdoc -skip qtgamepad -skip qtgraphicaleffects -skip qtimageformats -skip qtlocation -skip qtlottie -skip qtmacextras -skip qtmultimedia -skip qtnetworkauth -skip qtpurchasing -skip qtquick3d -skip qtquickcontrols -skip qtquickcontrols2 -skip qtquicktimeline -skip qtremoteobjects -skip qtscript -skip qtscxml -skip qtsensors -skip qtserialbus -skip qtserialport -skip qtspeech -skip qtsvg -skip qtvirtualkeyboard -skip qtwayland -skip qtwebchannel -skip qtwebengine -skip qtwebglplugin -skip qtwebsockets -skip qtwebview -skip qtx11extras -skip qtxmlpatterns -no-openssl -no-feature-bearermanagement -no-feature-printdialog -no-feature-printer -no-feature-printpreviewdialog -no-feature-printpreviewwidget -no-feature-sql -no-feature-sqlmodel -no-feature-textbrowser -no-feature-textmarkdownwriter -no-feature-textodfwriter -no-feature-xml'\n     IgnoreWarnIntDirInTempDetected: 'true'\n   merge_script:\n-    - git config --global user.email \"ci@ci.ci\"\n-    - git config --global user.name \"ci\"\n-    # Windows filesystem loses the executable bit, and all of the executable\n-    # files are considered \"modified\" now. It will break the following `git merge`\n-    # command. The next two commands make git ignore this issue.\n-    - git config core.filemode false\n-    - git reset --hard\n-    - PowerShell -NoLogo -Command if ($env:CIRRUS_PR -ne $null) { git fetch $env:CIRRUS_REPO_CLONE_URL $env:CIRRUS_BASE_BRANCH; git merge FETCH_HEAD; }\n+    - PowerShell -NoLogo -Command if ($env:CIRRUS_PR -ne $null) { git fetch $env:CIRRUS_REPO_CLONE_URL pull/$env:CIRRUS_PR/merge; git checkout FETCH_HEAD; }\n   msvc_qt_built_cache:\n     folder: \"%QTBASEDIR%\"\n     reupload_on_changes: false\n\n\n###\n\n", "completion": "ci: Use same `merge_script` implementation for Windows as for all"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -24,11 +24,8 @@ filter_template: &FILTER_TEMPLATE\n base_template: &BASE_TEMPLATE\n   << : *FILTER_TEMPLATE\n   merge_base_script:\n-    # Unconditionally install git (used in fingerprint_script) and set the\n-    # default git author name (used in verify-commits.py)\n+    # Unconditionally install git (used in fingerprint_script).\n     - bash -c \"$PACKAGE_MANAGER_INSTALL git\"\n-    - git config --global user.email \"ci@ci.ci\"\n-    - git config --global user.name \"ci\"\n     - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n     - git fetch $CIRRUS_REPO_CLONE_URL \"pull/${CIRRUS_PR}/merge\"\n     - git checkout FETCH_HEAD  # Use merged changes to detect silent merge conflicts\n\n---\n file path A: ci/lint/06_script.sh | file path B: ci/lint/06_script.sh\n\n@@ -31,6 +31,8 @@ if [ \"$CIRRUS_REPO_FULL_NAME\" = \"bitcoin/bitcoin\" ] && [ \"$CIRRUS_PR\" = \"\" ] ; t\n     git log HEAD~10 -1 --format='%H' > ./contrib/verify-commits/trusted-sha512-root-commit\n     git log HEAD~10 -1 --format='%H' > ./contrib/verify-commits/trusted-git-root\n     mapfile -t KEYS < contrib/verify-commits/trusted-keys\n+    git config user.email \"ci@ci.ci\"\n+    git config user.name \"ci\"\n     ${CI_RETRY_EXE} gpg --keyserver hkps://keys.openpgp.org --recv-keys \"${KEYS[@]}\" &&\n     ./contrib/verify-commits/verify-commits.py;\n fi\n\n\n###\n\n", "completion": "ci: Move `git config` commands into script where they are used"}
{"prompt": " file path A: src/index/blockfilterindex.h | file path B: src/index/blockfilterindex.h\n\n@@ -12,6 +12,8 @@\n #include <index/base.h>\n #include <util/hasher.h>\n \n+static const char* const DEFAULT_BLOCKFILTERINDEX = \"0\";\n+\n /** Interval between compact filter checkpoints. See BIP 157. */\n static constexpr int CFCHECKPT_INTERVAL = 1000;\n \n\n---\n file path A: src/validation.h | file path B: src/validation.h\n\n@@ -65,7 +65,6 @@ static const int MAX_SCRIPTCHECK_THREADS = 15;\n static const int DEFAULT_SCRIPTCHECK_THREADS = 0;\n static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n-static const char* const DEFAULT_BLOCKFILTERINDEX = \"0\";\n /** Default for -stopatheight */\n static const int DEFAULT_STOPATHEIGHT = 0;\n /** Block files containing a block-height within MIN_BLOCKS_TO_KEEP of ActiveChain().Tip() will not be pruned. */\n\n\n###\n\n", "completion": "refactor: move DEFAULT_BLOCKFILTERINDEX from val to blockfilterindex"}
{"prompt": " file path A: src/index/coinstatsindex.h | file path B: src/index/coinstatsindex.h\n\n@@ -14,6 +14,8 @@ namespace kernel {\n struct CCoinsStats;\n }\n \n+static constexpr bool DEFAULT_COINSTATSINDEX{false};\n+\n /**\n  * CoinStatsIndex maintains statistics on the UTXO set.\n  */\n\n---\n file path A: src/validation.h | file path B: src/validation.h\n\n@@ -65,7 +65,6 @@ static const int MAX_SCRIPTCHECK_THREADS = 15;\n static const int DEFAULT_SCRIPTCHECK_THREADS = 0;\n static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n-static constexpr bool DEFAULT_COINSTATSINDEX{false};\n static const char* const DEFAULT_BLOCKFILTERINDEX = \"0\";\n /** Default for -stopatheight */\n static const int DEFAULT_STOPATHEIGHT = 0;\n\n\n###\n\n", "completion": "refactor: move DEFAULT_COINSTATSINDEX from validation to coinstatsindex"}
{"prompt": " file path A: src/index/txindex.h | file path B: src/index/txindex.h\n\n@@ -7,6 +7,8 @@\n \n #include <index/base.h>\n \n+static constexpr bool DEFAULT_TXINDEX{false};\n+\n /**\n  * TxIndex is used to look up transactions included in the blockchain by hash.\n  * The index is written to a LevelDB database and records the filesystem\n\n---\n file path A: src/node/caches.cpp | file path B: src/node/caches.cpp\n\n@@ -4,9 +4,9 @@\n \n #include <node/caches.h>\n \n+#include <index/txindex.h>\n #include <txdb.h>\n #include <util/system.h>\n-#include <validation.h>\n \n namespace node {\n CacheSizes CalculateCacheSizes(const ArgsManager& args, size_t n_indexes)\n\n---\n file path A: src/validation.h | file path B: src/validation.h\n\n@@ -65,7 +65,6 @@ static const int MAX_SCRIPTCHECK_THREADS = 15;\n static const int DEFAULT_SCRIPTCHECK_THREADS = 0;\n static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n-static const bool DEFAULT_TXINDEX = false;\n static constexpr bool DEFAULT_COINSTATSINDEX{false};\n static const char* const DEFAULT_BLOCKFILTERINDEX = \"0\";\n /** Default for -stopatheight */\n\n\n###\n\n", "completion": "refactor: move DEFAULT_TXINDEX from validation to txindex"}
{"prompt": " file path A: src/sync.h | file path B: src/sync.h\n\n@@ -165,10 +165,11 @@ private:\n     bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n     {\n         EnterCritical(pszName, pszFile, nLine, Base::mutex(), true);\n-        if (!Base::try_lock()) {\n-            LeaveCritical();\n+        if (Base::try_lock()) {\n+            return true;\n         }\n-        return Base::owns_lock();\n+        LeaveCritical();\n+        return false;\n     }\n \n public:\n\n\n###\n\n", "completion": "refactor: Drop `owns_lock()` call"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -183,9 +183,9 @@ task:\n     - python build_msvc\\msvc-autogen.py\n     - msbuild build_msvc\\bitcoin.sln -property:CLToolExe=%WRAPPED_CL% -property:Configuration=Release -maxCpuCount -verbosity:minimal -noLogo\n     - ccache --show-stats\n-  unit_tests_script:\n+  check_script:\n     - src\\test_bitcoin.exe -l test_suite\n-    - src\\bench_bitcoin.exe > NUL\n+    - src\\bench_bitcoin.exe --sanity-check > NUL\n     - python test\\util\\test_runner.py\n     - python test\\util\\rpcauth-test.py\n   functional_tests_script:\n\n\n###\n\n", "completion": "ci: Run `bench_bitcoin.exe --sanity-check` in \"Win64 native\" task"}
{"prompt": " file path A: src/test/banman_tests.cpp | file path B: src/test/banman_tests.cpp\n\n@@ -27,7 +27,7 @@ BOOST_AUTO_TEST_CASE(file)\n             \"  { \\\"version\\\": 1, \\\"ban_created\\\": 0, \\\"banned_until\\\": 778, \\\"address\\\": \\\"1.0.0.0/8\\\" }\"\n             \"] }\",\n         };\n-        assert(WriteBinaryFile(banlist_path + \".json\", entries_write));\n+        BOOST_REQUIRE(WriteBinaryFile(banlist_path + \".json\", entries_write));\n         {\n             // The invalid entries will be dropped, but the valid one remains\n             ASSERT_DEBUG_LOG(\"Dropping entry with unparseable address or subnet (aaaaaaaaa) from ban list\");\n@@ -35,7 +35,7 @@ BOOST_AUTO_TEST_CASE(file)\n             BanMan banman{banlist_path, /*client_interface=*/nullptr, /*default_ban_time=*/0};\n             banmap_t entries_read;\n             banman.GetBanned(entries_read);\n-            assert(entries_read.size() == 1);\n+            BOOST_CHECK_EQUAL(entries_read.size(), 1);\n         }\n     }\n }\n\n\n###\n\n", "completion": "test: Use proper Boost macros instead of assertions"}
{"prompt": " file path A: src/wallet/test/coinselector_tests.cpp | file path B: src/wallet/test/coinselector_tests.cpp\n\n@@ -922,5 +922,52 @@ BOOST_AUTO_TEST_CASE(effective_value_test)\n     BOOST_CHECK_EQUAL(output5.GetEffectiveValue(), nValue); // The effective value should be equal to the absolute value if input_bytes is -1\n }\n \n+BOOST_AUTO_TEST_CASE(SelectCoins_effective_value_test)\n+{\n+    // Test that the effective value is used to check whether preset inputs provide sufficient funds when subtract_fee_outputs is not used.\n+    // This test creates a coin whose value is higher than the target but whose effective value is lower than the target.\n+    // The coin is selected using coin control, with m_allow_other_inputs = false. SelectCoins should fail due to insufficient funds.\n+\n+    std::unique_ptr<CWallet> wallet = std::make_unique<CWallet>(m_node.chain.get(), \"\", m_args, CreateMockWalletDatabase());\n+    wallet->LoadWallet();\n+    LOCK(wallet->cs_wallet);\n+    wallet->SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n+    wallet->SetupDescriptorScriptPubKeyMans();\n+\n+    CoinsResult available_coins;\n+    {\n+        std::unique_ptr<CWallet> dummyWallet = std::make_unique<CWallet>(m_node.chain.get(), \"dummy\", m_args, CreateMockWalletDatabase());\n+        dummyWallet->LoadWallet();\n+        LOCK(dummyWallet->cs_wallet);\n+        dummyWallet->SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n+        dummyWallet->SetupDescriptorScriptPubKeyMans();\n+\n+        add_coin(available_coins, *dummyWallet, 100000); // 0.001 BTC\n+    }\n+\n+    CAmount target{99900}; // 0.000999 BTC\n+\n+    FastRandomContext rand;\n+    CoinSelectionParams cs_params{\n+        rand,\n+        /*change_output_size=*/34,\n+        /*change_spend_size=*/148,\n+        /*min_change_target=*/1000,\n+        /*effective_feerate=*/CFeeRate(3000),\n+        /*long_term_feerate=*/CFeeRate(1000),\n+        /*discard_feerate=*/CFeeRate(1000),\n+        /*tx_noinputs_size=*/0,\n+        /*avoid_partial=*/false,\n+    };\n+    CCoinControl cc;\n+    cc.m_allow_other_inputs = false;\n+    COutput output = available_coins.All().at(0);\n+    cc.SetInputWeight(output.outpoint, 148);\n+    cc.SelectExternal(output.outpoint, output.txout);\n+\n+    const auto result = SelectCoins(*wallet, available_coins, target, cc, cs_params);\n+    BOOST_CHECK(!result);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()\n } // namespace wallet\n\n\n###\n\n", "completion": "test: Check external coin effective value is used in CoinSelection"}
{"prompt": " file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -174,6 +174,7 @@ BITCOIN_TESTS += \\\n   wallet/test/availablecoins_tests.cpp \\\n   wallet/test/init_tests.cpp \\\n   wallet/test/ismine_tests.cpp \\\n+  wallet/test/rpc_util_tests.cpp \\\n   wallet/test/scriptpubkeyman_tests.cpp \\\n   wallet/test/walletload_tests.cpp\n \n@@ -186,7 +187,8 @@ BITCOIN_TESTS += wallet/test/db_tests.cpp\n endif\n \n FUZZ_WALLET_SRC = \\\n- wallet/test/fuzz/coinselection.cpp\n+ wallet/test/fuzz/coinselection.cpp \\\n+ wallet/test/fuzz/parse_iso8601.cpp\n \n if USE_SQLITE\n FUZZ_WALLET_SRC += \\\n@@ -288,7 +290,6 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/node_eviction.cpp \\\n  test/fuzz/p2p_transport_serialization.cpp \\\n  test/fuzz/parse_hd_keypath.cpp \\\n- test/fuzz/parse_iso8601.cpp \\\n  test/fuzz/parse_numbers.cpp \\\n  test/fuzz/parse_script.cpp \\\n  test/fuzz/parse_univalue.cpp \\\n\n---\n file path A: src/test/fuzz/util.cpp | file path B: src/test/fuzz/util.cpp\n\n@@ -307,8 +307,8 @@ CAmount ConsumeMoney(FuzzedDataProvider& fuzzed_data_provider, const std::option\n int64_t ConsumeTime(FuzzedDataProvider& fuzzed_data_provider, const std::optional<int64_t>& min, const std::optional<int64_t>& max) noexcept\n {\n     // Avoid t=0 (1970-01-01T00:00:00Z) since SetMockTime(0) disables mocktime.\n-    static const int64_t time_min{ParseISO8601DateTime(\"2000-01-01T00:00:01Z\")};\n-    static const int64_t time_max{ParseISO8601DateTime(\"2100-12-31T23:59:59Z\")};\n+    static const int64_t time_min{946684801}; // 2000-01-01T00:00:01Z\n+    static const int64_t time_max{4133980799}; // 2100-12-31T23:59:59Z\n     return fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(min.value_or(time_min), max.value_or(time_max));\n }\n \n\n---\n file path A: src/test/util_tests.cpp | file path B: src/test/util_tests.cpp\n\n@@ -282,14 +282,10 @@ BOOST_AUTO_TEST_CASE(util_TrimString)\n     BOOST_CHECK_EQUAL(TrimStringView(std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6), std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6)), \"\");\n }\n \n-BOOST_AUTO_TEST_CASE(util_FormatParseISO8601DateTime)\n+BOOST_AUTO_TEST_CASE(util_FormatISO8601DateTime)\n {\n     BOOST_CHECK_EQUAL(FormatISO8601DateTime(1317425777), \"2011-09-30T23:36:17Z\");\n     BOOST_CHECK_EQUAL(FormatISO8601DateTime(0), \"1970-01-01T00:00:00Z\");\n-\n-    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"1970-01-01T00:00:00Z\"), 0);\n-    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"1960-01-01T00:00:00Z\"), 0);\n-    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"2011-09-30T23:36:17Z\"), 1317425777);\n }\n \n BOOST_AUTO_TEST_CASE(util_FormatISO8601Date)\n\n---\n file path A: src/util/time.cpp | file path B: src/util/time.cpp\n\n@@ -12,8 +12,6 @@\n #include <util/time.h>\n #include <util/check.h>\n \n-#include <boost/date_time/posix_time/posix_time.hpp>\n-\n #include <atomic>\n #include <chrono>\n #include <ctime>\n@@ -142,20 +140,6 @@ std::string FormatISO8601Date(int64_t nTime) {\n     return strprintf(\"%04i-%02i-%02i\", ts.tm_year + 1900, ts.tm_mon + 1, ts.tm_mday);\n }\n \n-int64_t ParseISO8601DateTime(const std::string& str)\n-{\n-    static const boost::posix_time::ptime epoch = boost::posix_time::from_time_t(0);\n-    static const std::locale loc(std::locale::classic(),\n-        new boost::posix_time::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\"));\n-    std::istringstream iss(str);\n-    iss.imbue(loc);\n-    boost::posix_time::ptime ptime(boost::date_time::not_a_date_time);\n-    iss >> ptime;\n-    if (ptime.is_not_a_date_time() || epoch > ptime)\n-        return 0;\n-    return (ptime - epoch).total_seconds();\n-}\n-\n struct timeval MillisToTimeval(int64_t nTimeout)\n {\n     struct timeval timeout;\n\n---\n file path A: src/util/time.h | file path B: src/util/time.h\n\n@@ -109,7 +109,6 @@ T GetTime()\n  */\n std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n-int64_t ParseISO8601DateTime(const std::string& str);\n \n /**\n  * Convert milliseconds to a struct timeval for e.g. select.\n\n---\n file path A: src/wallet/rpc/util.cpp | file path B: src/wallet/rpc/util.cpp\n\n@@ -12,10 +12,26 @@\n \n #include <univalue.h>\n \n+#include <boost/date_time/posix_time/posix_time.hpp>\n+\n namespace wallet {\n static const std::string WALLET_ENDPOINT_BASE = \"/wallet/\";\n const std::string HELP_REQUIRING_PASSPHRASE{\"\\nRequires wallet passphrase to be set with walletpassphrase call if wallet is encrypted.\\n\"};\n \n+int64_t ParseISO8601DateTime(const std::string& str)\n+{\n+    static const boost::posix_time::ptime epoch = boost::posix_time::from_time_t(0);\n+    static const std::locale loc(std::locale::classic(),\n+        new boost::posix_time::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\"));\n+    std::istringstream iss(str);\n+    iss.imbue(loc);\n+    boost::posix_time::ptime ptime(boost::date_time::not_a_date_time);\n+    iss >> ptime;\n+    if (ptime.is_not_a_date_time() || epoch > ptime)\n+        return 0;\n+    return (ptime - epoch).total_seconds();\n+}\n+\n bool GetAvoidReuseFlag(const CWallet& wallet, const UniValue& param) {\n     bool can_avoid_reuse = wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n     bool avoid_reuse = param.isNull() ? can_avoid_reuse : param.get_bool();\n\n---\n file path A: src/wallet/rpc/util.h | file path B: src/wallet/rpc/util.h\n\n@@ -45,6 +45,8 @@ std::string LabelFromValue(const UniValue& value);\n void PushParentDescriptors(const CWallet& wallet, const CScript& script_pubkey, UniValue& entry);\n \n void HandleWalletError(const std::shared_ptr<CWallet> wallet, DatabaseStatus& status, bilingual_str& error);\n+\n+int64_t ParseISO8601DateTime(const std::string& str);\n } //  namespace wallet\n \n #endif // BITCOIN_WALLET_RPC_UTIL_H\n\n---\n file path A: src/test/fuzz/parse_iso8601.cpp | file path B: src/wallet/test/fuzz/parse_iso8601.cpp\n\n@@ -5,6 +5,7 @@\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n #include <util/time.h>\n+#include <wallet/rpc/util.h>\n \n #include <cassert>\n #include <cstdint>\n@@ -20,7 +21,7 @@ FUZZ_TARGET(parse_iso8601)\n \n     const std::string iso8601_datetime = FormatISO8601DateTime(random_time);\n     (void)FormatISO8601Date(random_time);\n-    const int64_t parsed_time_1 = ParseISO8601DateTime(iso8601_datetime);\n+    const int64_t parsed_time_1 = wallet::ParseISO8601DateTime(iso8601_datetime);\n     if (random_time >= 0) {\n         assert(parsed_time_1 >= 0);\n         if (iso8601_datetime.length() == 20) {\n@@ -28,6 +29,6 @@ FUZZ_TARGET(parse_iso8601)\n         }\n     }\n \n-    const int64_t parsed_time_2 = ParseISO8601DateTime(random_string);\n+    const int64_t parsed_time_2 = wallet::ParseISO8601DateTime(random_string);\n     assert(parsed_time_2 >= 0);\n }\n\n---\n file path A: None | file path B: src/wallet/test/rpc_util_tests.cpp\n\n@@ -0,0 +1,24 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/rpc/util.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+namespace wallet {\n+\n+BOOST_AUTO_TEST_SUITE(wallet_util_tests)\n+\n+BOOST_AUTO_TEST_CASE(util_ParseISO8601DateTime)\n+{\n+    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"1970-01-01T00:00:00Z\"), 0);\n+    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"1960-01-01T00:00:00Z\"), 0);\n+    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"2000-01-01T00:00:01Z\"), 946684801);\n+    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"2011-09-30T23:36:17Z\"), 1317425777);\n+    BOOST_CHECK_EQUAL(ParseISO8601DateTime(\"2100-12-31T23:59:59Z\"), 4133980799);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()\n+\n+} // namespace wallet\n\n\n###\n\n", "completion": "refactor: move Boost datetime usage to wallet"}
{"prompt": " file path A: src/wallet/wallet.h | file path B: src/wallet/wallet.h\n\n@@ -250,7 +250,7 @@ private:\n     int nWalletVersion GUARDED_BY(cs_wallet){FEATURE_BASE};\n \n     /** The next scheduled rebroadcast of wallet transactions. */\n-    std::atomic<int64_t> m_next_resend{GetDefaultNextResend()};\n+    int64_t m_next_resend{GetDefaultNextResend()};\n     /** Whether this wallet will submit newly created transactions to the node's mempool and\n      * prompt rebroadcasts (see ResendWalletTransactions()). */\n     bool fBroadcastTransactions = false;\n\n\n###\n\n", "completion": "refactor: revert m_next_resend to not be std::atomic"}
{"prompt": " file path A: src/wallet/wallet.cpp | file path B: src/wallet/wallet.cpp\n\n@@ -1903,6 +1903,23 @@ std::set<uint256> CWallet::GetTxConflicts(const CWalletTx& wtx) const\n     return result;\n }\n \n+bool CWallet::ShouldResend() const\n+{\n+    // Don't attempt to resubmit if the wallet is configured to not broadcast\n+    if (!fBroadcastTransactions) return false;\n+\n+    // During reindex, importing and IBD, old wallet transactions become\n+    // unconfirmed. Don't resend them as that would spam other nodes.\n+    // We only allow forcing mempool submission when not relaying to avoid this spam.\n+    if (!chain().isReadyToBroadcast()) return false;\n+\n+    // Do this infrequently and randomly to avoid giving away\n+    // that these are our transactions.\n+    if (GetTime() < m_next_resend) return false;\n+\n+    return true;\n+}\n+\n // Resubmit transactions from the wallet to the mempool, optionally asking the\n // mempool to relay them. On startup, we will do this for all unconfirmed\n // transactions but will not ask the mempool to relay them. We do this on startup\n@@ -1934,14 +1951,6 @@ void CWallet::ResubmitWalletTransactions(bool relay, bool force)\n     // even if forcing.\n     if (!fBroadcastTransactions) return;\n \n-    // During reindex, importing and IBD, old wallet transactions become\n-    // unconfirmed. Don't resend them as that would spam other nodes.\n-    // We only allow forcing mempool submission when not relaying to avoid this spam.\n-    if (!force && relay && !chain().isReadyToBroadcast()) return;\n-\n-    // Do this infrequently and randomly to avoid giving away\n-    // that these are our transactions.\n-    if (!force && GetTime() < m_next_resend) return;\n     // resend 12-36 hours from now, ~1 day on average.\n     m_next_resend = GetTime() + (12 * 60 * 60) + GetRand(24 * 60 * 60);\n \n@@ -1979,6 +1988,7 @@ void CWallet::ResubmitWalletTransactions(bool relay, bool force)\n void MaybeResendWalletTxs(WalletContext& context)\n {\n     for (const std::shared_ptr<CWallet>& pwallet : GetWallets(context)) {\n+        if (!pwallet->ShouldResend()) continue;\n         pwallet->ResubmitWalletTransactions(/*relay=*/true, /*force=*/false);\n     }\n }\n\n---\n file path A: src/wallet/wallet.h | file path B: src/wallet/wallet.h\n\n@@ -537,6 +537,8 @@ public:\n     };\n     ScanResult ScanForWalletTransactions(const uint256& start_block, int start_height, std::optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate, const bool save_progress);\n     void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n+    /** Return true if all conditions for periodically resending transactions are met. */\n+    bool ShouldResend() const;\n     void ResubmitWalletTransactions(bool relay, bool force);\n \n     OutputType TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;\n\n\n###\n\n", "completion": "refactor: carve out tx resend timer logic into ShouldResend"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -104,7 +104,7 @@ task:\n   env:\n     PATH: 'C:\\jom;C:\\Python39;C:\\Python39\\Scripts;C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\BuildTools\\MSBuild\\Current\\Bin;%PATH%'\n     PYTHONUTF8: 1\n-    CI_VCPKG_TAG: '2022.06.16.1'\n+    CI_VCPKG_TAG: '2022.09.27'\n     VCPKG_DOWNLOADS: 'C:\\Users\\ContainerAdministrator\\AppData\\Local\\vcpkg\\downloads'\n     VCPKG_DEFAULT_BINARY_CACHE: 'C:\\Users\\ContainerAdministrator\\AppData\\Local\\vcpkg\\archives'\n     CCACHE_DIR: 'C:\\Users\\ContainerAdministrator\\AppData\\Local\\ccache'\n\n\n###\n\n", "completion": "ci: Bump vcpkg to the latest version `2022.09.27`"}
{"prompt": " file path A: None | file path B: test/functional/feature_discover.py\n\n@@ -0,0 +1,75 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test -discover command.\"\"\"\n+\n+import socket\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+\n+def is_valid_ipv4_address(address):\n+    try:\n+        socket.inet_aton(address)\n+    except socket.error:\n+        return False\n+    return True\n+\n+\n+def is_valid_ipv6_address(address):\n+    try:\n+        socket.inet_pton(socket.AF_INET6, address)\n+    except socket.error:\n+        return False\n+    return True\n+\n+\n+class DiscoverTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.bind_to_localhost_only = False\n+        self.num_nodes = 1\n+\n+    def validate_addresses(self, addresses_obj):\n+        for address_obj in addresses_obj:\n+            address = address_obj['address']\n+            self.log.info(f\"Validating {address}\")\n+            valid = (is_valid_ipv4_address(address)\n+                     or is_valid_ipv6_address(address))\n+            assert_equal(valid, True)\n+\n+    def test_local_addresses(self, test_case, *, expect_empty=False):\n+        self.log.info(f\"Restart node with {test_case}\")\n+        self.restart_node(0, test_case)\n+        network_info = self.nodes[0].getnetworkinfo()\n+        network_enabled = [n for n in network_info['networks']\n+                           if n['reachable'] and n['name'] in ['ipv4', 'ipv6']]\n+        local_addrs = list(network_info[\"localaddresses\"])\n+        if expect_empty or not network_enabled:\n+            assert_equal(local_addrs, [])\n+        elif len(local_addrs) > 0:\n+            self.validate_addresses(local_addrs)\n+\n+    def run_test(self):\n+        test_cases = [\n+            [\"-listen\", \"-discover\"],\n+            [\"-discover\"],\n+        ]\n+\n+        test_cases_empty = [\n+            [\"-discover=0\"],\n+            [\"-listen\", \"-discover=0\"],\n+            [],\n+        ]\n+\n+        for test_case in test_cases:\n+            self.test_local_addresses(test_case, expect_empty=False)\n+\n+        for test_case in test_cases_empty:\n+            self.test_local_addresses(test_case, expect_empty=True)\n+\n+\n+if __name__ == '__main__':\n+    DiscoverTest().main()\n\n---\n file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -277,6 +277,7 @@ BASE_SCRIPTS = [\n     'feature_dersig.py',\n     'feature_cltv.py',\n     'rpc_uptime.py',\n+    'feature_discover.py',\n     'wallet_resendwallettransactions.py --legacy-wallet',\n     'wallet_resendwallettransactions.py --descriptors',\n     'wallet_fallbackfee.py --legacy-wallet',\n\n\n###\n\n", "completion": "test: add functional test for -discover"}
{"prompt": " file path A: test/functional/feature_pruning.py | file path B: test/functional/feature_pruning.py\n\n@@ -358,6 +358,8 @@ class PruneTest(BitcoinTestFramework):\n         self.restart_node(2, extra_args=[\"-prune=550\"])\n         self.log.info(\"Success\")\n \n+        assert_raises_rpc_error(-4, \"Importing wallets is disabled when blocks are pruned\", self.nodes[2].importwallet, \"abc\")\n+\n         # check that wallet loads successfully when restarting a pruned node after IBD.\n         # this was reported to fail in #7494.\n         self.log.info(\"Syncing node 5 to test wallet\")\n\n\n###\n\n", "completion": "test: check importing wallets when blocks are pruned throw an error"}
{"prompt": " file path A: src/wallet/rpc/backup.cpp | file path B: src/wallet/rpc/backup.cpp\n\n@@ -293,10 +293,7 @@ RPCHelpMan importaddress()\n     if (fRescan)\n     {\n         RescanWallet(*pwallet, reserver);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n-        }\n+        pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n     }\n \n     return UniValue::VNULL;\n@@ -474,10 +471,7 @@ RPCHelpMan importpubkey()\n     if (fRescan)\n     {\n         RescanWallet(*pwallet, reserver);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n-        }\n+        pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n     }\n \n     return UniValue::VNULL;\n@@ -1406,10 +1400,7 @@ RPCHelpMan importmulti()\n     }\n     if (fRescan && fRunScan && requests.size()) {\n         int64_t scannedTime = pwallet->RescanFromTime(nLowestTimestamp, reserver, true /* update */);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n-        }\n+        pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n \n         if (pwallet->IsAbortingRescan()) {\n             throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted by user.\");\n@@ -1700,10 +1691,7 @@ RPCHelpMan importdescriptors()\n     // Rescan the blockchain using the lowest timestamp\n     if (rescan) {\n         int64_t scanned_time = pwallet->RescanFromTime(lowest_timestamp, reserver, true /* update */);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n-        }\n+        pwallet->ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n \n         if (pwallet->IsAbortingRescan()) {\n             throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted by user.\");\n\n---\n file path A: src/wallet/wallet.cpp | file path B: src/wallet/wallet.cpp\n\n@@ -3196,14 +3196,12 @@ bool CWallet::UpgradeWallet(int version, bilingual_str& error)\n \n void CWallet::postInitProcess()\n {\n-    LOCK(cs_wallet);\n-\n     // Add wallet transactions that aren't already in a block to mempool\n     // Do this here as mempool requires genesis block to be loaded\n     ResubmitWalletTransactions(/*relay=*/false, /*force=*/true);\n \n     // Update wallet transactions with current mempool transactions.\n-    chain().requestMempoolTransactions(*this);\n+    WITH_LOCK(cs_wallet, chain().requestMempoolTransactions(*this));\n }\n \n bool CWallet::BackupWallet(const std::string& strDest) const\n\n\n###\n\n", "completion": "refactor: remove unused locks for ResubmitWalletTransactions"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -30,8 +30,8 @@ base_template: &BASE_TEMPLATE\n     - git config --global user.email \"ci@ci.ci\"\n     - git config --global user.name \"ci\"\n     - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n-    - git fetch $CIRRUS_REPO_CLONE_URL $CIRRUS_BASE_BRANCH\n-    - git merge FETCH_HEAD  # Merge base to detect silent merge conflicts\n+    - git fetch $CIRRUS_REPO_CLONE_URL \"pull/${CIRRUS_PR}/merge\"\n+    - git checkout FETCH_HEAD  # Use merged changes to detect silent merge conflicts\n \n main_template: &MAIN_TEMPLATE\n   timeout_in: 120m  # https://cirrus-ci.org/faq/#instance-timed-out\n\n\n###\n\n", "completion": "ci: Use remote pull/merge ref instead of local git merge"}
{"prompt": " file path A: ci/lint/04_install.sh | file path B: ci/lint/04_install.sh\n\n@@ -8,6 +8,13 @@ export LC_ALL=C\n \n ${CI_RETRY_EXE} apt-get update\n ${CI_RETRY_EXE} apt-get install -y clang-format-9 python3-pip curl git gawk jq\n+(\n+  # Temporary workaround for https://github.com/bitcoin/bitcoin/pull/26130#issuecomment-1260499544\n+  # Can be removed once the underlying image is bumped to something that includes git2.34 or later\n+  sed -i -e 's/bionic/jammy/g' /etc/apt/sources.list\n+  ${CI_RETRY_EXE} apt-get update\n+  ${CI_RETRY_EXE} apt-get install -y --reinstall git\n+)\n update-alternatives --install /usr/bin/clang-format      clang-format      \"$(which clang-format-9     )\" 100\n update-alternatives --install /usr/bin/clang-format-diff clang-format-diff \"$(which clang-format-diff-9)\" 100\n \n\n\n###\n\n", "completion": "ci: Use git2.34 for lint task"}
{"prompt": " file path A: src/sync.h | file path B: src/sync.h\n\n@@ -165,8 +165,7 @@ private:\n     bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n     {\n         EnterCritical(pszName, pszFile, nLine, Base::mutex(), true);\n-        Base::try_lock();\n-        if (!Base::owns_lock()) {\n+        if (!Base::try_lock()) {\n             LeaveCritical();\n         }\n         return Base::owns_lock();\n\n\n###\n\n", "completion": "refactor: Do not discard `try_lock()` return value"}
{"prompt": " file path A: configure.ac | file path B: configure.ac\n\n@@ -588,8 +588,8 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n CXXFLAGS=\"$TEMP_CXXFLAGS\"\n \n # ARM\n-AX_CHECK_COMPILE_FLAG([-march=armv8-a+crc+crypto], [ARM_CRC_CXXFLAGS=\"-march=armv8-a+crc+crypto\"], [], [$CXXFLAG_WERROR])\n-AX_CHECK_COMPILE_FLAG([-march=armv8-a+crc+crypto], [ARM_SHANI_CXXFLAGS=\"-march=armv8-a+crc+crypto\"], [], [$CXXFLAG_WERROR])\n+AX_CHECK_COMPILE_FLAG([-march=armv8-a+crc], [ARM_CRC_CXXFLAGS=\"-march=armv8-a+crc\"], [], [$CXXFLAG_WERROR])\n+AX_CHECK_COMPILE_FLAG([-march=armv8-a+crypto], [ARM_SHANI_CXXFLAGS=\"-march=armv8-a+crypto\"], [], [$CXXFLAG_WERROR])\n \n TEMP_CXXFLAGS=\"$CXXFLAGS\"\n CXXFLAGS=\"$ARM_CRC_CXXFLAGS $CXXFLAGS\"\n\n\n###\n\n", "completion": "build: split ARM crc & crypto extension checks"}
{"prompt": " file path A: build_msvc/bitcoin_config.h.in | file path B: build_msvc/bitcoin_config.h.in\n\n@@ -41,18 +41,12 @@\n /* Define to 1 to enable ZMQ functions */\n #define ENABLE_ZMQ 1\n \n-/* define if the Boost library is available */\n-#define HAVE_BOOST /**/\n-\n /* define if external signer support is enabled (requires Boost::Process) */\n #define ENABLE_EXTERNAL_SIGNER /**/\n \n /* Define this symbol if the consensus lib has been built */\n #define HAVE_CONSENSUS_LIB 1\n \n-/* define if the compiler supports basic C++20 syntax */\n-#define HAVE_CXX20 1\n-\n /* Define to 1 if you have the declaration of `be16toh', and to 0 if you\n    don't. */\n #define HAVE_DECL_BE16TOH 0\n@@ -121,43 +115,9 @@\n    */\n #define HAVE_DECL_SETSID 0\n \n-/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you\n-   don't. */\n-#define HAVE_DECL_STRERROR_R 0\n-\n /* Define if the dllexport attribute is supported. */\n #define HAVE_DLLEXPORT_ATTRIBUTE 1\n \n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#define HAVE_INTTYPES_H 1\n-\n-/* Define to 1 if you have the <memory.h> header file. */\n-#define HAVE_MEMORY_H 1\n-\n-/* Define to 1 if you have the <miniupnpc/miniupnpc.h> header file. */\n-#define HAVE_MINIUPNPC_MINIUPNPC_H 1\n-\n-/* Define to 1 if you have the <miniupnpc/upnpcommands.h> header file. */\n-#define HAVE_MINIUPNPC_UPNPCOMMANDS_H 1\n-\n-/* Define to 1 if you have the <miniupnpc/upnperrors.h> header file. */\n-#define HAVE_MINIUPNPC_UPNPERRORS_H 1\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#define HAVE_STDINT_H 1\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#define HAVE_STDLIB_H 1\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#define HAVE_STRING_H 1\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#define HAVE_SYS_STAT_H 1\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#define HAVE_SYS_TYPES_H 1\n-\n /* Define to the address where bug reports for this package should be sent. */\n #define PACKAGE_BUGREPORT \"https://github.com/bitcoin/bitcoin/issues\"\n \n\n\n###\n\n", "completion": "build: remove unused MSVC defines"}
{"prompt": " file path A: configure.ac | file path B: configure.ac\n\n@@ -1010,7 +1010,7 @@ if test \"$TARGET_OS\" = \"darwin\"; then\n   AX_CHECK_LINK_FLAG([-Wl,-bind_at_load], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -Wl,-bind_at_load\"], [], [$LDFLAG_WERROR])\n fi\n \n-AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h stdlib.h unistd.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n+AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h unistd.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n \n AC_CHECK_DECLS([getifaddrs, freeifaddrs],[CHECK_SOCKET],,\n     [#include <sys/types.h>\n\n\n###\n\n", "completion": "build: remove stdlib.h from header checks"}
{"prompt": " file path A: src/consensus/consensus.h | file path B: src/consensus/consensus.h\n\n@@ -6,7 +6,7 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-#include <stdlib.h>\n+#include <cstdlib>\n #include <stdint.h>\n \n /** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n\n---\n file path A: src/crypto/chacha20.h | file path B: src/crypto/chacha20.h\n\n@@ -5,8 +5,8 @@\n #ifndef BITCOIN_CRYPTO_CHACHA20_H\n #define BITCOIN_CRYPTO_CHACHA20_H\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A class for ChaCha20 256-bit stream cipher developed by Daniel J. Bernstein\n     https://cr.yp.to/chacha/chacha-20080128.pdf */\n\n---\n file path A: src/crypto/hkdf_sha256_32.h | file path B: src/crypto/hkdf_sha256_32.h\n\n@@ -7,8 +7,8 @@\n \n #include <crypto/hmac_sha256.h>\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A rfc5869 HKDF implementation with HMAC_SHA256 and fixed key output length of 32 bytes (L=32) */\n class CHKDF_HMAC_SHA256_L32\n\n---\n file path A: src/crypto/hmac_sha256.h | file path B: src/crypto/hmac_sha256.h\n\n@@ -7,8 +7,8 @@\n \n #include <crypto/sha256.h>\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A hasher class for HMAC-SHA-256. */\n class CHMAC_SHA256\n\n---\n file path A: src/crypto/hmac_sha512.h | file path B: src/crypto/hmac_sha512.h\n\n@@ -7,8 +7,8 @@\n \n #include <crypto/sha512.h>\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A hasher class for HMAC-SHA-512. */\n class CHMAC_SHA512\n\n---\n file path A: src/crypto/poly1305.h | file path B: src/crypto/poly1305.h\n\n@@ -5,8 +5,8 @@\n #ifndef BITCOIN_CRYPTO_POLY1305_H\n #define BITCOIN_CRYPTO_POLY1305_H\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n #define POLY1305_KEYLEN 32\n #define POLY1305_TAGLEN 16\n\n---\n file path A: src/crypto/ripemd160.h | file path B: src/crypto/ripemd160.h\n\n@@ -5,8 +5,8 @@\n #ifndef BITCOIN_CRYPTO_RIPEMD160_H\n #define BITCOIN_CRYPTO_RIPEMD160_H\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A hasher class for RIPEMD-160. */\n class CRIPEMD160\n\n---\n file path A: src/crypto/sha1.h | file path B: src/crypto/sha1.h\n\n@@ -5,8 +5,8 @@\n #ifndef BITCOIN_CRYPTO_SHA1_H\n #define BITCOIN_CRYPTO_SHA1_H\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A hasher class for SHA1. */\n class CSHA1\n\n---\n file path A: src/crypto/sha256.h | file path B: src/crypto/sha256.h\n\n@@ -5,8 +5,8 @@\n #ifndef BITCOIN_CRYPTO_SHA256_H\n #define BITCOIN_CRYPTO_SHA256_H\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n #include <string>\n \n /** A hasher class for SHA-256. */\n\n---\n file path A: src/crypto/sha256_sse4.cpp | file path B: src/crypto/sha256_sse4.cpp\n\n@@ -5,8 +5,8 @@\n // This is a translation to GCC extended asm syntax from YASM code by Intel\n // (available at the bottom of this file).\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n #if defined(__x86_64__) || defined(__amd64__)\n \n\n---\n file path A: src/crypto/sha3.h | file path B: src/crypto/sha3.h\n\n@@ -7,8 +7,8 @@\n \n #include <span.h>\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n //! The Keccak-f[1600] transform.\n void KeccakF(uint64_t (&st)[25]);\n\n---\n file path A: src/crypto/sha512.h | file path B: src/crypto/sha512.h\n\n@@ -5,8 +5,8 @@\n #ifndef BITCOIN_CRYPTO_SHA512_H\n #define BITCOIN_CRYPTO_SHA512_H\n \n+#include <cstdlib>\n #include <stdint.h>\n-#include <stdlib.h>\n \n /** A hasher class for SHA-512. */\n class CSHA512\n\n---\n file path A: src/httpserver.cpp | file path B: src/httpserver.cpp\n\n@@ -22,10 +22,10 @@\n #include <util/translation.h>\n \n #include <cstdio>\n+#include <cstdlib>\n #include <deque>\n #include <memory>\n #include <optional>\n-#include <stdlib.h>\n #include <string>\n \n #include <sys/types.h>\n\n---\n file path A: src/ipc/interfaces.cpp | file path B: src/ipc/interfaces.cpp\n\n@@ -13,10 +13,10 @@\n #include <util/system.h>\n \n #include <cstdio>\n+#include <cstdlib>\n #include <functional>\n #include <memory>\n #include <stdexcept>\n-#include <stdlib.h>\n #include <string.h>\n #include <string>\n #include <unistd.h>\n\n---\n file path A: src/ipc/process.cpp | file path B: src/ipc/process.cpp\n\n@@ -10,10 +10,10 @@\n #include <util/strencodings.h>\n \n #include <cstdint>\n+#include <cstdlib>\n #include <exception>\n #include <iostream>\n #include <stdexcept>\n-#include <stdlib.h>\n #include <string.h>\n #include <system_error>\n #include <unistd.h>\n\n---\n file path A: src/memusage.h | file path B: src/memusage.h\n\n@@ -8,9 +8,8 @@\n #include <indirectmap.h>\n #include <prevector.h>\n \n-#include <stdlib.h>\n-\n #include <cassert>\n+#include <cstdlib>\n #include <map>\n #include <memory>\n #include <set>\n\n---\n file path A: src/prevector.h | file path B: src/prevector.h\n\n@@ -6,7 +6,7 @@\n #define BITCOIN_PREVECTOR_H\n \n #include <assert.h>\n-#include <stdlib.h>\n+#include <cstdlib>\n #include <stdint.h>\n #include <string.h>\n \n\n---\n file path A: src/random.cpp | file path B: src/random.cpp\n\n@@ -21,7 +21,7 @@\n #include <util/time.h> // for GetTimeMicros()\n \n #include <cmath>\n-#include <stdlib.h>\n+#include <cstdlib>\n #include <thread>\n \n #ifndef WIN32\n\n---\n file path A: src/script/miniscript.h | file path B: src/script/miniscript.h\n\n@@ -13,8 +13,8 @@\n #include <string>\n #include <vector>\n \n-#include <stdlib.h>\n #include <assert.h>\n+#include <cstdlib>\n \n #include <policy/policy.h>\n #include <primitives/transaction.h>\n\n---\n file path A: src/support/cleanse.h | file path B: src/support/cleanse.h\n\n@@ -6,7 +6,7 @@\n #ifndef BITCOIN_SUPPORT_CLEANSE_H\n #define BITCOIN_SUPPORT_CLEANSE_H\n \n-#include <stdlib.h>\n+#include <cstdlib>\n \n /** Secure overwrite a buffer (possibly containing secret data) with zero-bytes. The write\n  * operation will not be optimized out by the compiler. */\n\n---\n file path A: src/test/blockchain_tests.cpp | file path B: src/test/blockchain_tests.cpp\n\n@@ -4,13 +4,13 @@\n \n #include <boost/test/unit_test.hpp>\n \n-#include <stdlib.h>\n-\n #include <chain.h>\n #include <rpc/blockchain.h>\n #include <test/util/setup_common.h>\n #include <util/string.h>\n \n+#include <cstdlib>\n+\n /* Equality between doubles is imprecise. Comparison should be done\n  * with a small threshold of tolerance, rather than exact equality.\n  */\n\n---\n file path A: src/test/raii_event_tests.cpp | file path B: src/test/raii_event_tests.cpp\n\n@@ -4,8 +4,8 @@\n \n #include <event2/event.h>\n \n+#include <cstdlib>\n #include <map>\n-#include <stdlib.h>\n \n #include <support/events.h>\n \n\n\n###\n\n", "completion": "refactor: use <cstdlib> over stdlib.h"}
{"prompt": " file path A: test/functional/wallet_listdescriptors.py | file path B: test/functional/wallet_listdescriptors.py\n\n@@ -52,6 +52,10 @@ class ListDescriptorsTest(BitcoinTestFramework):\n             assert item['range'] == [0, 0]\n             assert item['timestamp'] is not None\n \n+        self.log.info('Test that descriptor strings are returned in lexicographically sorted order.')\n+        descriptor_strings = [descriptor['desc'] for descriptor in result['descriptors']]\n+        assert_equal(descriptor_strings, sorted(descriptor_strings))\n+\n         self.log.info('Test descriptors with hardened derivations are listed in importable form.')\n         xprv = 'tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg'\n         xpub_acc = 'tpubDCMVLhErorrAGfApiJSJzEKwqeaf2z3NrkVMxgYQjZLzMjXMBeRw2muGNYbvaekAE8rUFLftyEar4LdrG2wXyyTJQZ26zptmeTEjPTaATts'\n\n\n###\n\n", "completion": "test: check that `listdescriptors` descriptor strings are sorted"}
{"prompt": " file path A: depends/packages/miniupnpc.mk | file path B: depends/packages/miniupnpc.mk\n\n@@ -5,10 +5,12 @@ $(package)_file_name=$(package)-$($(package)_version).tar.gz\n $(package)_sha256_hash=888fb0976ba61518276fe1eda988589c700a3f2a69d71089260d75562afd3687\n $(package)_patches=dont_leak_info.patch respect_mingw_cflags.patch\n \n+# Next time this package is updated, ensure that _WIN32_WINNT is still properly set.\n+# See discussion in https://github.com/bitcoin/bitcoin/pull/25964.\n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\"\n $(package)_build_opts_darwin=LIBTOOL=\"$($(package)_libtool)\"\n-$(package)_build_opts_mingw32=-f Makefile.mingw\n+$(package)_build_opts_mingw32=-f Makefile.mingw CFLAGS=\"$($(package)_cflags) -D_WIN32_WINNT=0x0601\"\n $(package)_build_env+=CFLAGS=\"$($(package)_cflags) $($(package)_cppflags)\" AR=\"$($(package)_ar)\"\n endef\n \n\n\n###\n\n", "completion": "build: set D_WIN32_WINNT=0x0601 for mingw miniupnpc"}
{"prompt": " file path A: depends/packages/miniupnpc.mk | file path B: depends/packages/miniupnpc.mk\n\n@@ -3,7 +3,7 @@ $(package)_version=2.2.2\n $(package)_download_path=https://miniupnp.tuxfamily.org/files/\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n $(package)_sha256_hash=888fb0976ba61518276fe1eda988589c700a3f2a69d71089260d75562afd3687\n-$(package)_patches=dont_leak_info.patch\n+$(package)_patches=dont_leak_info.patch respect_mingw_cflags.patch\n \n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\"\n@@ -13,7 +13,8 @@ $(package)_build_env+=CFLAGS=\"$($(package)_cflags) $($(package)_cppflags)\" AR=\"$\n endef\n \n define $(package)_preprocess_cmds\n-  patch -p1 < $($(package)_patch_dir)/dont_leak_info.patch\n+  patch -p1 < $($(package)_patch_dir)/dont_leak_info.patch && \\\n+  patch -p1 < $($(package)_patch_dir)/respect_mingw_cflags.patch\n endef\n \n define $(package)_build_cmds\n\n---\n file path A: None | file path B: depends/patches/miniupnpc/respect_mingw_cflags.patch\n\n@@ -0,0 +1,23 @@\n+commit fec515a7ac9991a0ee91068fda046b54b191155e\n+Author: fanquake <fanquake@gmail.com>\n+Date:   Wed Jul 27 15:52:37 2022 +0100\n+\n+    build: respect CFLAGS in makefile.mingw\n+    \n+    Similar to the other Makefile.\n+\n+    Cherry-pick of https://github.com/miniupnp/miniupnp/pull/619.\n+\n+diff --git a/Makefile.mingw b/Makefile.mingw\n+index 2bff7bd..88430d2 100644\n+--- a/Makefile.mingw\n++++ b/Makefile.mingw\n+@@ -19,7 +19,7 @@ else\n+ RM = rm -f\n+ endif\n+ #CFLAGS = -Wall -g -DDEBUG -D_WIN32_WINNT=0X501\n+-CFLAGS = -Wall -W -Wstrict-prototypes -Os -DNDEBUG -D_WIN32_WINNT=0X501\n++CFLAGS ?= -Wall -W -Wstrict-prototypes -Os -DNDEBUG -D_WIN32_WINNT=0X501\n+ LDLIBS = -lws2_32 -liphlpapi\n+ # -lwsock32\n+ # -liphlpapi is needed for GetBestRoute() and GetIpAddrTable()\n\n\n###\n\n", "completion": "build: fix cflags passing for mingw miniupnpc"}
{"prompt": " file path A: build_msvc/bitcoin_config.h.in | file path B: build_msvc/bitcoin_config.h.in\n\n@@ -146,9 +146,6 @@\n /* Define to 1 if you have the <stdint.h> header file. */\n #define HAVE_STDINT_H 1\n \n-/* Define to 1 if you have the <stdio.h> header file. */\n-#define HAVE_STDIO_H 1\n-\n /* Define to 1 if you have the <stdlib.h> header file. */\n #define HAVE_STDLIB_H 1\n \n\n---\n file path A: configure.ac | file path B: configure.ac\n\n@@ -1010,7 +1010,7 @@ if test \"$TARGET_OS\" = \"darwin\"; then\n   AX_CHECK_LINK_FLAG([-Wl,-bind_at_load], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -Wl,-bind_at_load\"], [], [$LDFLAG_WERROR])\n fi\n \n-AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h stdio.h stdlib.h unistd.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n+AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h stdlib.h unistd.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n \n AC_CHECK_DECLS([getifaddrs, freeifaddrs],[CHECK_SOCKET],,\n     [#include <sys/types.h>\n\n\n###\n\n", "completion": "build: remove stdio.h from header checks"}
{"prompt": " file path A: src/bitcoin-tx.cpp | file path B: src/bitcoin-tx.cpp\n\n@@ -27,9 +27,9 @@\n #include <util/system.h>\n #include <util/translation.h>\n \n+#include <cstdio>\n #include <functional>\n #include <memory>\n-#include <stdio.h>\n \n static bool fCreateBlank;\n static std::map<std::string,UniValue> registers;\n\n---\n file path A: src/httpserver.cpp | file path B: src/httpserver.cpp\n\n@@ -21,10 +21,10 @@\n #include <util/threadnames.h>\n #include <util/translation.h>\n \n+#include <cstdio>\n #include <deque>\n #include <memory>\n #include <optional>\n-#include <stdio.h>\n #include <stdlib.h>\n #include <string>\n \n\n---\n file path A: src/ipc/interfaces.cpp | file path B: src/ipc/interfaces.cpp\n\n@@ -12,10 +12,10 @@\n #include <tinyformat.h>\n #include <util/system.h>\n \n+#include <cstdio>\n #include <functional>\n #include <memory>\n #include <stdexcept>\n-#include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <string>\n\n---\n file path A: src/qt/utilitydialog.cpp | file path B: src/qt/utilitydialog.cpp\n\n@@ -17,7 +17,7 @@\n #include <util/system.h>\n #include <util/strencodings.h>\n \n-#include <stdio.h>\n+#include <cstdio>\n \n #include <QCloseEvent>\n #include <QLabel>\n\n---\n file path A: src/streams.h | file path B: src/streams.h\n\n@@ -13,11 +13,11 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <cstdio>\n #include <ios>\n #include <limits>\n #include <optional>\n #include <stdint.h>\n-#include <stdio.h>\n #include <string.h>\n #include <string>\n #include <utility>\n\n\n###\n\n", "completion": "refactor: use <cstdio> over stdio.h"}
{"prompt": " file path A: test/functional/interface_rest.py | file path B: test/functional/interface_rest.py\n\n@@ -288,6 +288,10 @@ class RESTTest (BitcoinTestFramework):\n \n         # See if we can get 5 headers in one response\n         self.generate(self.nodes[1], 5)\n+        expected_filter = {\n+            'basic block filter index': {'synced': True, 'best_block_height': 208},\n+        }\n+        self.wait_until(lambda: self.nodes[0].getindexinfo() == expected_filter)\n         json_obj = self.test_rest_request(f\"/headers/{bb_hash}\", query_params={\"count\": 5})\n         assert_equal(len(json_obj), 5)  # now we should have 5 header objects\n         json_obj = self.test_rest_request(f\"/blockfilterheaders/basic/{bb_hash}\", query_params={\"count\": 5})\n\n\n###\n\n", "completion": "test: wait for the expected basic block filter index in `interface_rest`"}
{"prompt": " file path A: test/functional/test_framework/test_framework.py | file path B: test/functional/test_framework/test_framework.py\n\n@@ -596,24 +596,24 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n         self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n \n     def disconnect_nodes(self, a, b):\n-        def disconnect_nodes_helper(from_connection, node_num):\n-            def get_peer_ids():\n+        def disconnect_nodes_helper(node_a, node_b):\n+            def get_peer_ids(from_connection, node_num):\n                 result = []\n                 for peer in from_connection.getpeerinfo():\n                     if \"testnode{}\".format(node_num) in peer['subver']:\n                         result.append(peer['id'])\n                 return result\n \n-            peer_ids = get_peer_ids()\n+            peer_ids = get_peer_ids(node_a, node_b.index)\n             if not peer_ids:\n                 self.log.warning(\"disconnect_nodes: {} and {} were not connected\".format(\n-                    from_connection.index,\n-                    node_num,\n+                    node_a.index,\n+                    node_b.index,\n                 ))\n                 return\n             for peer_id in peer_ids:\n                 try:\n-                    from_connection.disconnectnode(nodeid=peer_id)\n+                    node_a.disconnectnode(nodeid=peer_id)\n                 except JSONRPCException as e:\n                     # If this node is disconnected between calculating the peer id\n                     # and issuing the disconnect, don't worry about it.\n@@ -622,9 +622,10 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):\n                         raise\n \n             # wait to disconnect\n-            self.wait_until(lambda: not get_peer_ids(), timeout=5)\n+            self.wait_until(lambda: not get_peer_ids(node_a, node_b.index), timeout=5)\n+            self.wait_until(lambda: not get_peer_ids(node_b, node_a.index), timeout=5)\n \n-        disconnect_nodes_helper(self.nodes[a], b)\n+        disconnect_nodes_helper(self.nodes[a], self.nodes[b])\n \n     def split_network(self):\n         \"\"\"\n\n\n###\n\n", "completion": "test: Avoid race in disconnect_nodes helper"}
{"prompt": " file path A: build_msvc/bitcoin_config.h.in | file path B: build_msvc/bitcoin_config.h.in\n\n@@ -152,9 +152,6 @@\n /* Define to 1 if you have the <stdlib.h> header file. */\n #define HAVE_STDLIB_H 1\n \n-/* Define to 1 if you have the <strings.h> header file. */\n-#define HAVE_STRINGS_H 1\n-\n /* Define to 1 if you have the <string.h> header file. */\n #define HAVE_STRING_H 1\n \n\n---\n file path A: configure.ac | file path B: configure.ac\n\n@@ -1010,7 +1010,7 @@ if test \"$TARGET_OS\" = \"darwin\"; then\n   AX_CHECK_LINK_FLAG([-Wl,-bind_at_load], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -Wl,-bind_at_load\"], [], [$LDFLAG_WERROR])\n fi\n \n-AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n+AC_CHECK_HEADERS([endian.h sys/endian.h byteswap.h stdio.h stdlib.h unistd.h sys/types.h sys/stat.h sys/select.h sys/prctl.h sys/sysctl.h vm/vm_param.h sys/vmmeter.h sys/resources.h])\n \n AC_CHECK_DECLS([getifaddrs, freeifaddrs],[CHECK_SOCKET],,\n     [#include <sys/types.h>\n\n\n###\n\n", "completion": "build: remove strings.h from header checks"}
{"prompt": " file path A: test/functional/wallet_bumpfee.py | file path B: test/functional/wallet_bumpfee.py\n\n@@ -93,6 +93,7 @@ class BumpFeeTest(BitcoinTestFramework):\n         test_watchonly_psbt(self, peer_node, rbf_node, dest_address)\n         test_rebumping(self, rbf_node, dest_address)\n         test_rebumping_not_replaceable(self, rbf_node, dest_address)\n+        test_bumpfee_already_spent(self, rbf_node, dest_address)\n         test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address)\n         test_bumpfee_metadata(self, rbf_node, dest_address)\n         test_locked_wallet_fails(self, rbf_node, dest_address)\n@@ -229,7 +230,7 @@ def test_segwit_bumpfee_succeeds(self, rbf_node, dest_address):\n def test_nonrbf_bumpfee_fails(self, peer_node, dest_address):\n     self.log.info('Test that we cannot replace a non RBF transaction')\n     not_rbfid = peer_node.sendtoaddress(dest_address, Decimal(\"0.00090000\"))\n-    assert_raises_rpc_error(-4, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n+    assert_raises_rpc_error(-4, \"Transaction is not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n     self.clear_mempool()\n \n \n@@ -499,7 +500,8 @@ def test_rebumping(self, rbf_node, dest_address):\n     self.log.info('Test that re-bumping the original tx fails, but bumping successor works')\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"fee_rate\": ECONOMICAL})\n-    assert_raises_rpc_error(-4, \"already bumped\", rbf_node.bumpfee, rbfid, {\"fee_rate\": NORMAL})\n+    assert_raises_rpc_error(-4, f\"Cannot bump transaction {rbfid} which was already bumped by transaction {bumped['txid']}\",\n+                            rbf_node.bumpfee, rbfid, {\"fee_rate\": NORMAL})\n     rbf_node.bumpfee(bumped[\"txid\"], {\"fee_rate\": NORMAL})\n     self.clear_mempool()\n \n@@ -513,6 +515,15 @@ def test_rebumping_not_replaceable(self, rbf_node, dest_address):\n     self.clear_mempool()\n \n \n+def test_bumpfee_already_spent(self, rbf_node, dest_address):\n+    self.log.info('Test that bumping tx with already spent coin fails')\n+    txid = spend_one_input(rbf_node, dest_address)\n+    self.generate(rbf_node, 1)  # spend coin simply by mining block with tx\n+    spent_input = rbf_node.gettransaction(txid=txid, verbose=True)['decoded']['vin'][0]\n+    assert_raises_rpc_error(-1, f\"{spent_input['txid']}:{spent_input['vout']} is already spent\",\n+                            rbf_node.bumpfee, txid, {\"fee_rate\": NORMAL})\n+\n+\n def test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):\n     self.log.info('Test that unconfirmed outputs from bumped txns are not spendable')\n     rbfid = spend_one_input(rbf_node, rbf_node_address)\n\n\n###\n\n", "completion": "test: check that bumping tx with already spent coin fails"}
{"prompt": " file path A: doc/bips.md | file path B: doc/bips.md\n\n@@ -58,6 +58,7 @@ BIPs that are implemented by Bitcoin Core (up-to-date up to **v23.0**):\n   with mainnet activation as of **v0.21.1** ([PR 21377](https://github.com/bitcoin/bitcoin/pull/21377),\n   [PR 21686](https://github.com/bitcoin/bitcoin/pull/21686)).\n * [`BIP 350`](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki): Addresses for native v1+ segregated Witness outputs use Bech32m instead of Bech32 as of **v22.0** ([PR 20861](https://github.com/bitcoin/bitcoin/pull/20861)).\n+* [`BIP 371`](https://github.com/bitcoin/bips/blob/master/bip-0371.mediawiki): Taproot fields for PSBT as of **v24.0** ([PR 22558](https://github.com/bitcoin/bitcoin/pull/22558)).\n * [`BIP 380`](https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki)\n   [`381`](https://github.com/bitcoin/bips/blob/master/bip-0381.mediawiki)\n   [`382`](https://github.com/bitcoin/bips/blob/master/bip-0382.mediawiki)\n\n\n###\n\n", "completion": "docs: Add 371 to bips.md"}
{"prompt": " file path A: configure.ac | file path B: configure.ac\n\n@@ -1,5 +1,5 @@\n AC_PREREQ([2.69])\n-define(_CLIENT_VERSION_MAJOR, 23)\n+define(_CLIENT_VERSION_MAJOR, 24)\n define(_CLIENT_VERSION_MINOR, 99)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_RC, 0)\n\n\n###\n\n", "completion": "build: Bump version to 24.99"}
{"prompt": " file path A: test/functional/wallet_importmulti.py | file path B: test/functional/wallet_importmulti.py\n\n@@ -874,6 +874,25 @@ class ImportMultiTest(BitcoinTestFramework):\n             addr = wrpc.getnewaddress('', 'bech32')\n             assert_equal(addr, addresses[i])\n \n+        # Create wallet with passphrase\n+        self.log.info('Test watchonly imports on a wallet with a passphrase, without unlocking')\n+        self.nodes[1].createwallet(wallet_name='w1', blank=True, passphrase='pass')\n+        wrpc = self.nodes[1].get_wallet_rpc('w1')\n+        assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first.\",\n+                                wrpc.importmulti, [{\n+                                    'desc': descsum_create('wpkh(' + pub1 + ')'),\n+                                    \"timestamp\": \"now\",\n+                                }])\n+\n+        result = wrpc.importmulti(\n+            [{\n+                'desc': descsum_create('wpkh(' + pub1 + ')'),\n+                \"timestamp\": \"now\",\n+                \"watchonly\": True,\n+            }]\n+        )\n+        assert result[0]['success']\n+\n \n if __name__ == '__main__':\n     ImportMultiTest().main()\n\n\n###\n\n", "completion": "test: Test watchonly imports with passphrase-locked wallet"}
{"prompt": " file path A: src/wallet/coinselection.cpp | file path B: src/wallet/coinselection.cpp\n\n@@ -87,13 +87,15 @@ std::optional<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_poo\n     std::vector<size_t> best_selection;\n     CAmount best_waste = MAX_MONEY;\n \n+    bool is_feerate_high = utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee;\n+\n     // Depth First search loop for choosing the UTXOs\n     for (size_t curr_try = 0, utxo_pool_index = 0; curr_try < TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n         // Conditions for starting a backtrack\n         bool backtrack = false;\n         if (curr_value + curr_available_value < selection_target || // Cannot possibly reach target with the amount remaining in the curr_available_value.\n             curr_value > selection_target + cost_of_change || // Selected value is out of range, go back and try other branch\n-            (curr_waste > best_waste && (utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee))) { // Don't select things which we know will be more wasteful if the waste is increasing\n+            (curr_waste > best_waste && is_feerate_high)) { // Don't select things which we know will be more wasteful if the waste is increasing\n             backtrack = true;\n         } else if (curr_value >= selection_target) {       // Selected value is within range\n             curr_waste += (curr_value - selection_target); // This is the excess value which is added to the waste for the below comparison\n\n\n###\n\n", "completion": "refactor: Move feerate comparison invariant outside of the loop"}
{"prompt": " file path A: src/wallet/coinselection.cpp | file path B: src/wallet/coinselection.cpp\n\n@@ -93,7 +93,7 @@ std::optional<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_poo\n         bool backtrack = false;\n         if (curr_value + curr_available_value < selection_target || // Cannot possibly reach target with the amount remaining in the curr_available_value.\n             curr_value > selection_target + cost_of_change || // Selected value is out of range, go back and try other branch\n-            (curr_waste > best_waste && (utxo_pool.at(0).fee - utxo_pool.at(0).long_term_fee) > 0)) { // Don't select things which we know will be more wasteful if the waste is increasing\n+            (curr_waste > best_waste && (utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee))) { // Don't select things which we know will be more wasteful if the waste is increasing\n             backtrack = true;\n         } else if (curr_value >= selection_target) {       // Selected value is within range\n             curr_waste += (curr_value - selection_target); // This is the excess value which is added to the waste for the below comparison\n\n\n###\n\n", "completion": "refactor: Simplify feerate comparison statement"}
{"prompt": " file path A: src/Makefile.bench.include | file path B: src/Makefile.bench.include\n\n@@ -53,6 +53,7 @@ nodist_bench_bench_bitcoin_SOURCES = $(GENERATED_BENCH_FILES)\n \n bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n bench_bench_bitcoin_LDADD = \\\n   $(LIBTEST_UTIL) \\\n   $(LIBBITCOIN_NODE) \\\n@@ -66,7 +67,9 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBSECP256K1) \\\n   $(LIBUNIVALUE) \\\n   $(EVENT_PTHREADS_LIBS) \\\n-  $(EVENT_LIBS)\n+  $(EVENT_LIBS) \\\n+  $(MINIUPNPC_LIBS) \\\n+  $(NATPMP_LIBS)\n \n if ENABLE_ZMQ\n bench_bench_bitcoin_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n@@ -76,11 +79,9 @@ if ENABLE_WALLET\n bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n bench_bench_bitcoin_SOURCES += bench/wallet_balance.cpp\n bench_bench_bitcoin_SOURCES += bench/wallet_loading.cpp\n+bench_bench_bitcoin_LDADD += $(BDB_LIBS) $(SQLITE_LIBS)\n endif\n \n-bench_bench_bitcoin_LDADD += $(BDB_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(SQLITE_LIBS)\n-bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n-\n CLEAN_BITCOIN_BENCH = bench/*.gcda bench/*.gcno $(GENERATED_BENCH_FILES)\n \n CLEANFILES += $(CLEAN_BITCOIN_BENCH)\n\n\n###\n\n", "completion": "build: remove duplicate / unneeded libs from bench_bitcoin"}
{"prompt": " file path A: src/Makefile.test_fuzz.include | file path B: src/Makefile.test_fuzz.include\n\n@@ -13,7 +13,7 @@ TEST_FUZZ_H = \\\n     test/fuzz/mempool_utils.h \\\n     test/fuzz/util.h\n \n-libtest_fuzz_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libtest_fuzz_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libtest_fuzz_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libtest_fuzz_a_SOURCES = \\\n   test/fuzz/fuzz.cpp \\\n\n---\n file path A: src/Makefile.test_util.include | file path B: src/Makefile.test_util.include\n\n@@ -20,7 +20,7 @@ TEST_UTIL_H = \\\n     test/util/validation.h \\\n     test/util/wallet.h\n \n-libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libtest_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libtest_util_a_SOURCES = \\\n   test/util/blockfilter.cpp \\\n\n\n###\n\n", "completion": "build: remove unused libevent cppflags"}
{"prompt": " file path A: src/Makefile.test_fuzz.include | file path B: src/Makefile.test_fuzz.include\n\n@@ -13,7 +13,7 @@ TEST_FUZZ_H = \\\n     test/fuzz/mempool_utils.h \\\n     test/fuzz/util.h\n \n-libtest_fuzz_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libtest_fuzz_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libtest_fuzz_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libtest_fuzz_a_SOURCES = \\\n   test/fuzz/fuzz.cpp \\\n\n---\n file path A: src/Makefile.test_util.include | file path B: src/Makefile.test_util.include\n\n@@ -20,7 +20,7 @@ TEST_UTIL_H = \\\n     test/util/validation.h \\\n     test/util/wallet.h\n \n-libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libtest_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libtest_util_a_SOURCES = \\\n   test/util/blockfilter.cpp \\\n\n\n###\n\n", "completion": "build: remove unused natpmp / upnp cppflags"}
{"prompt": " file path A: src/wallet/wallet.cpp | file path B: src/wallet/wallet.cpp\n\n@@ -882,7 +882,7 @@ bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n \n     wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n \n-    // Refresh mempool status without waiting for transactionRemovedFromMempool\n+    // Refresh mempool status without waiting for transactionRemovedFromMempool or transactionAddedToMempool\n     RefreshMempoolStatus(wtx, chain());\n \n     WalletBatch batch(GetDatabase());\n\n---\n file path A: test/functional/wallet_resendwallettransactions.py | file path B: test/functional/wallet_resendwallettransactions.py\n\n@@ -89,6 +89,10 @@ class ResendWalletTransactionsTest(BitcoinTestFramework):\n             if txids == [child_txid, txid]:\n                 break\n             bumped = node.bumpfee(child_txid)\n+            # The scheduler queue creates a copy of the added tx after\n+            # send/bumpfee and re-adds it to the wallet (undoing the next\n+            # removeprunedfunds). So empty the scheduler queue:\n+            node.syncwithvalidationinterfacequeue()\n             node.removeprunedfunds(child_txid)\n             child_txid = bumped[\"txid\"]\n         entry_time = node.getmempoolentry(child_txid)[\"time\"]\n\n\n###\n\n", "completion": "test: Add missing syncwithvalidationinterfacequeue"}
{"prompt": " file path A: test/functional/rpc_fundrawtransaction.py | file path B: test/functional/rpc_fundrawtransaction.py\n\n@@ -106,6 +106,7 @@ class RawTransactionsTest(BitcoinTestFramework):\n         self.generate(self.nodes[2], 1)\n         self.generate(self.nodes[0], 121)\n \n+        self.test_add_inputs_default_value()\n         self.test_weight_calculation()\n         self.test_change_position()\n         self.test_simple()\n@@ -1073,6 +1074,121 @@ class RawTransactionsTest(BitcoinTestFramework):\n \n         self.nodes[2].unloadwallet(\"extfund\")\n \n+    def test_add_inputs_default_value(self):\n+        self.log.info(\"Test 'add_inputs' default value\")\n+\n+        # Create and fund the wallet with 5 BTC\n+        self.nodes[2].createwallet(\"test_preset_inputs\")\n+        wallet = self.nodes[2].get_wallet_rpc(\"test_preset_inputs\")\n+        addr1 = wallet.getnewaddress(address_type=\"bech32\")\n+        self.nodes[0].sendtoaddress(addr1, 5)\n+        self.generate(self.nodes[0], 1)\n+\n+        # Covered cases:\n+        # 1. Default add_inputs value with no preset inputs (add_inputs=true):\n+        #       Expect: automatically add coins from the wallet to the tx.\n+        # 2. Default add_inputs value with preset inputs (add_inputs=false):\n+        #       Expect: disallow automatic coin selection.\n+        # 3. Explicit add_inputs=true and preset inputs (with preset inputs not-covering the target amount).\n+        #       Expect: include inputs from the wallet.\n+        # 4. Explicit add_inputs=true and preset inputs (with preset inputs covering the target amount).\n+        #       Expect: only preset inputs are used.\n+        # 5. Explicit add_inputs=true, no preset inputs (same as (1) but with an explicit set):\n+        #       Expect: include inputs from the wallet.\n+\n+        # Case (1), 'send' command\n+        # 'add_inputs' value is true unless \"inputs\" are specified, in such case, add_inputs=false.\n+        # So, the wallet will automatically select coins and create the transaction if only the outputs are provided.\n+        tx = wallet.send(outputs=[{addr1: 3}])\n+        assert tx[\"complete\"]\n+\n+        # Case (2), 'send' command\n+        # Select an input manually, which doesn't cover the entire output amount and\n+        # verify that the dynamically set 'add_inputs=false' value works.\n+\n+        # Fund wallet with 2 outputs, 5 BTC each.\n+        addr2 = wallet.getnewaddress(address_type=\"bech32\")\n+        source_tx = self.nodes[0].send(outputs=[{addr1: 5}, {addr2: 5}], options={\"change_position\": 0})\n+        self.generate(self.nodes[0], 1)\n+\n+        # Select only one input.\n+        options = {\n+            \"inputs\": [\n+                {\n+                    \"txid\": source_tx[\"txid\"],\n+                    \"vout\": 1  # change position was hardcoded to index 0\n+                }\n+            ]\n+        }\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", wallet.send, outputs=[{addr1: 8}], options=options)\n+\n+        # Case (3), Explicit add_inputs=true and preset inputs (with preset inputs not-covering the target amount)\n+        options[\"add_inputs\"] = True\n+        options[\"add_to_wallet\"] = False\n+        tx = wallet.send(outputs=[{addr1: 8}], options=options)\n+        assert tx[\"complete\"]\n+\n+        # Case (4), Explicit add_inputs=true and preset inputs (with preset inputs covering the target amount)\n+        options[\"inputs\"].append({\n+            \"txid\": source_tx[\"txid\"],\n+            \"vout\": 2  # change position was hardcoded to index 0\n+        })\n+        tx = wallet.send(outputs=[{addr1: 8}], options=options)\n+        assert tx[\"complete\"]\n+        # Check that only the preset inputs were added to the tx\n+        decoded_psbt_inputs = self.nodes[0].decodepsbt(tx[\"psbt\"])['tx']['vin']\n+        assert_equal(len(decoded_psbt_inputs), 2)\n+        for input in decoded_psbt_inputs:\n+            assert_equal(input[\"txid\"], source_tx[\"txid\"])\n+\n+        # Case (5), assert that inputs are added to the tx by explicitly setting add_inputs=true\n+        options = {\"add_inputs\": True, \"add_to_wallet\": True}\n+        tx = wallet.send(outputs=[{addr1: 8}], options=options)\n+        assert tx[\"complete\"]\n+\n+        ################################################\n+\n+        # Case (1), 'walletcreatefundedpsbt' command\n+        # Default add_inputs value with no preset inputs (add_inputs=true)\n+        inputs = []\n+        outputs = {self.nodes[1].getnewaddress(): 8}\n+        assert \"psbt\" in wallet.walletcreatefundedpsbt(inputs=inputs, outputs=outputs)\n+\n+        # Case (2), 'walletcreatefundedpsbt' command\n+        # Default add_inputs value with preset inputs (add_inputs=false).\n+        inputs = [{\n+            \"txid\": source_tx[\"txid\"],\n+            \"vout\": 1  # change position was hardcoded to index 0\n+        }]\n+        outputs = {self.nodes[1].getnewaddress(): 8}\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", wallet.walletcreatefundedpsbt, inputs=inputs, outputs=outputs)\n+\n+        # Case (3), Explicit add_inputs=true and preset inputs (with preset inputs not-covering the target amount)\n+        options[\"add_inputs\"] = True\n+        options[\"add_to_wallet\"] = False\n+        assert \"psbt\" in wallet.walletcreatefundedpsbt(outputs=[{addr1: 8}], inputs=inputs, options=options)\n+\n+        # Case (4), Explicit add_inputs=true and preset inputs (with preset inputs covering the target amount)\n+        inputs.append({\n+            \"txid\": source_tx[\"txid\"],\n+            \"vout\": 2  # change position was hardcoded to index 0\n+        })\n+        psbt_tx = wallet.walletcreatefundedpsbt(outputs=[{addr1: 8}], inputs=inputs, options=options)\n+        # Check that only the preset inputs were added to the tx\n+        decoded_psbt_inputs = self.nodes[0].decodepsbt(psbt_tx[\"psbt\"])['tx']['vin']\n+        assert_equal(len(decoded_psbt_inputs), 2)\n+        for input in decoded_psbt_inputs:\n+            assert_equal(input[\"txid\"], source_tx[\"txid\"])\n+\n+        # Case (5), 'walletcreatefundedpsbt' command\n+        # Explicit add_inputs=true, no preset inputs\n+        options = {\n+            \"add_inputs\": True\n+        }\n+        assert \"psbt\" in wallet.walletcreatefundedpsbt(inputs=[], outputs=outputs, options=options)\n+\n+        self.nodes[2].unloadwallet(\"test_preset_inputs\")\n+\n     def test_weight_calculation(self):\n         self.log.info(\"Test weight calculation with external inputs\")\n \n\n\n###\n\n", "completion": "test: add coverage for 'add_inputs' dynamic default value"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -439,7 +439,7 @@ libbitcoin_node_a_SOURCES += dummywallet.cpp\n endif\n \n if ENABLE_ZMQ\n-libbitcoin_zmq_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(ZMQ_CFLAGS)\n+libbitcoin_zmq_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(ZMQ_CFLAGS)\n libbitcoin_zmq_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_zmq_a_SOURCES = \\\n   zmq/zmqabstractnotifier.cpp \\\n\n---\n file path A: src/zmq/zmqnotificationinterface.cpp | file path B: src/zmq/zmqnotificationinterface.cpp\n\n@@ -8,7 +8,7 @@\n \n #include <zmq.h>\n \n-#include <validation.h>\n+#include <primitives/block.h>\n #include <util/system.h>\n \n CZMQNotificationInterface::CZMQNotificationInterface() : pcontext(nullptr)\n\n---\n file path A: src/zmq/zmqpublishnotifier.cpp | file path B: src/zmq/zmqpublishnotifier.cpp\n\n@@ -11,7 +11,6 @@\n #include <rpc/server.h>\n #include <streams.h>\n #include <util/system.h>\n-#include <validation.h> // For cs_main\n #include <zmq/zmqutil.h>\n \n #include <zmq.h>\n\n\n###\n\n", "completion": "build: prune BOOST_CPPFLAGS from libbitcoin_zmq"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -772,7 +772,7 @@ bitcoin_cli_LDADD += $(EVENT_LIBS)\n \n # bitcoin-tx binary #\n bitcoin_tx_SOURCES = bitcoin-tx.cpp\n-bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n+bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n \n\n---\n file path A: src/bitcoin-tx.cpp | file path B: src/bitcoin-tx.cpp\n\n@@ -15,7 +15,6 @@\n #include <key_io.h>\n #include <fs.h>\n #include <policy/policy.h>\n-#include <policy/rbf.h>\n #include <primitives/transaction.h>\n #include <script/script.h>\n #include <script/sign.h>\n\n\n###\n\n", "completion": "build: remove BOOST_CPPFLAGS usage from bitcoin-tx"}
{"prompt": " file path A: src/index/base.cpp | file path B: src/index/base.cpp\n\n@@ -18,6 +18,9 @@\n #include <validation.h> // For g_chainman\n #include <warnings.h>\n \n+#include <string>\n+#include <utility>\n+\n using node::ReadBlockFromDisk;\n \n constexpr uint8_t DB_BEST_BLOCK{'B'};\n@@ -62,8 +65,8 @@ void BaseIndex::DB::WriteBestBlock(CDBBatch& batch, const CBlockLocator& locator\n     batch.Write(DB_BEST_BLOCK, locator);\n }\n \n-BaseIndex::BaseIndex(std::unique_ptr<interfaces::Chain> chain)\n-    : m_chain{std::move(chain)} {}\n+BaseIndex::BaseIndex(std::unique_ptr<interfaces::Chain> chain, std::string name)\n+    : m_chain{std::move(chain)}, m_name{std::move(name)} {}\n \n BaseIndex::~BaseIndex()\n {\n\n---\n file path A: src/index/base.h | file path B: src/index/base.h\n\n@@ -10,6 +10,8 @@\n #include <threadinterrupt.h>\n #include <validationinterface.h>\n \n+#include <string>\n+\n class CBlock;\n class CBlockIndex;\n class Chainstate;\n@@ -95,6 +97,7 @@ private:\n protected:\n     std::unique_ptr<interfaces::Chain> m_chain;\n     Chainstate* m_chainstate{nullptr};\n+    const std::string m_name;\n \n     void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex) override;\n \n@@ -117,13 +120,13 @@ protected:\n     virtual DB& GetDB() const = 0;\n \n     /// Get the name of the index for display in logs.\n-    virtual const char* GetName() const = 0;\n+    const std::string& GetName() const LIFETIMEBOUND { return m_name; }\n \n     /// Update the internal best block index as well as the prune lock.\n     void SetBestBlockIndex(const CBlockIndex* block);\n \n public:\n-    BaseIndex(std::unique_ptr<interfaces::Chain> chain);\n+    BaseIndex(std::unique_ptr<interfaces::Chain> chain, std::string name);\n     /// Destructor interrupts sync thread if running and blocks until it exits.\n     virtual ~BaseIndex();\n \n\n---\n file path A: src/index/blockfilterindex.cpp | file path B: src/index/blockfilterindex.cpp\n\n@@ -97,7 +97,8 @@ static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n \n BlockFilterIndex::BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, BlockFilterType filter_type,\n                                    size_t n_cache_size, bool f_memory, bool f_wipe)\n-    : BaseIndex(std::move(chain)), m_filter_type(filter_type)\n+    : BaseIndex(std::move(chain), BlockFilterTypeName(filter_type) + \" block filter index\")\n+    , m_filter_type(filter_type)\n {\n     const std::string& filter_name = BlockFilterTypeName(filter_type);\n     if (filter_name.empty()) throw std::invalid_argument(\"unknown filter_type\");\n@@ -105,7 +106,6 @@ BlockFilterIndex::BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, Blo\n     fs::path path = gArgs.GetDataDirNet() / \"indexes\" / \"blockfilter\" / fs::u8path(filter_name);\n     fs::create_directories(path);\n \n-    m_name = filter_name + \" block filter index\";\n     m_db = std::make_unique<BaseIndex::DB>(path / \"db\", n_cache_size, f_memory, f_wipe);\n     m_filter_fileseq = std::make_unique<FlatFileSeq>(std::move(path), \"fltr\", FLTR_FILE_CHUNK_SIZE);\n }\n\n---\n file path A: src/index/blockfilterindex.h | file path B: src/index/blockfilterindex.h\n\n@@ -26,7 +26,6 @@ class BlockFilterIndex final : public BaseIndex\n {\n private:\n     BlockFilterType m_filter_type;\n-    std::string m_name;\n     std::unique_ptr<BaseIndex::DB> m_db;\n \n     FlatFilePos m_next_filter_pos;\n@@ -52,8 +51,6 @@ protected:\n \n     BaseIndex::DB& GetDB() const LIFETIMEBOUND override { return *m_db; }\n \n-    const char* GetName() const LIFETIMEBOUND override { return m_name.c_str(); }\n-\n public:\n     /** Constructs the index, which becomes available to be queried. */\n     explicit BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, BlockFilterType filter_type,\n\n---\n file path A: src/index/coinstatsindex.cpp | file path B: src/index/coinstatsindex.cpp\n\n@@ -105,7 +105,7 @@ struct DBHashKey {\n std::unique_ptr<CoinStatsIndex> g_coin_stats_index;\n \n CoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe)\n-    : BaseIndex(std::move(chain))\n+    : BaseIndex(std::move(chain), \"coinstatsindex\")\n {\n     fs::path path{gArgs.GetDataDirNet() / \"indexes\" / \"coinstats\"};\n     fs::create_directories(path);\n\n---\n file path A: src/index/coinstatsindex.h | file path B: src/index/coinstatsindex.h\n\n@@ -20,7 +20,6 @@ struct CCoinsStats;\n class CoinStatsIndex final : public BaseIndex\n {\n private:\n-    std::string m_name;\n     std::unique_ptr<BaseIndex::DB> m_db;\n \n     MuHash3072 m_muhash;\n@@ -52,8 +51,6 @@ protected:\n \n     BaseIndex::DB& GetDB() const override { return *m_db; }\n \n-    const char* GetName() const override { return \"coinstatsindex\"; }\n-\n public:\n     // Constructs the index, which becomes available to be queried.\n     explicit CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n\n---\n file path A: src/index/txindex.cpp | file path B: src/index/txindex.cpp\n\n@@ -49,7 +49,7 @@ bool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_\n }\n \n TxIndex::TxIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe)\n-    : BaseIndex(std::move(chain)), m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n+    : BaseIndex(std::move(chain), \"txindex\"), m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n {}\n \n TxIndex::~TxIndex() = default;\n\n---\n file path A: src/index/txindex.h | file path B: src/index/txindex.h\n\n@@ -27,8 +27,6 @@ protected:\n \n     BaseIndex::DB& GetDB() const override;\n \n-    const char* GetName() const override { return \"txindex\"; }\n-\n public:\n     /// Constructs the index, which becomes available to be queried.\n     explicit TxIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n\n\n###\n\n", "completion": "refactor: use std::string for index names"}
{"prompt": " file path A: src/qt/guiutil.cpp | file path B: src/qt/guiutil.cpp\n\n@@ -982,7 +982,7 @@ void PrintSlotException(\n     std::string description = sender->metaObject()->className();\n     description += \"->\";\n     description += receiver->metaObject()->className();\n-    PrintExceptionContinue(exception, description.c_str());\n+    PrintExceptionContinue(exception, description);\n }\n \n void ShowModalDialogAsynchronously(QDialog* dialog)\n\n---\n file path A: src/util/system.cpp | file path B: src/util/system.cpp\n\n@@ -831,7 +831,7 @@ std::string HelpMessageOpt(const std::string &option, const std::string &message\n            std::string(\"\\n\\n\");\n }\n \n-static std::string FormatException(const std::exception* pex, const char* pszThread)\n+static std::string FormatException(const std::exception* pex, std::string_view pszThread)\n {\n #ifdef WIN32\n     char pszModule[MAX_PATH] = \"\";\n@@ -847,7 +847,7 @@ static std::string FormatException(const std::exception* pex, const char* pszThr\n             \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n }\n \n-void PrintExceptionContinue(const std::exception* pex, const char* pszThread)\n+void PrintExceptionContinue(const std::exception* pex, std::string_view pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n     LogPrintf(\"\\n\\n************************\\n%s\\n\", message);\n\n---\n file path A: src/util/system.h | file path B: src/util/system.h\n\n@@ -51,7 +51,7 @@ bool error(const char* fmt, const Args&... args)\n     return false;\n }\n \n-void PrintExceptionContinue(const std::exception *pex, const char* pszThread);\n+void PrintExceptionContinue(const std::exception* pex, std::string_view pszThread);\n \n /**\n  * Ensure file contents are fully committed to disk, using a platform-specific\n\n---\n file path A: src/util/thread.cpp | file path B: src/util/thread.cpp\n\n@@ -10,10 +10,12 @@\n \n #include <exception>\n #include <functional>\n+#include <string>\n+#include <utility>\n \n-void util::TraceThread(const char* thread_name, std::function<void()> thread_func)\n+void util::TraceThread(std::string_view thread_name, std::function<void()> thread_func)\n {\n-    util::ThreadRename(thread_name);\n+    util::ThreadRename(std::string{thread_name});\n     try {\n         LogPrintf(\"%s thread start\\n\", thread_name);\n         thread_func();\n\n---\n file path A: src/util/thread.h | file path B: src/util/thread.h\n\n@@ -6,12 +6,13 @@\n #define BITCOIN_UTIL_THREAD_H\n \n #include <functional>\n+#include <string>\n \n namespace util {\n /**\n  * A wrapper for do-something-once thread functions.\n  */\n-void TraceThread(const char* thread_name, std::function<void()> thread_func);\n+void TraceThread(std::string_view thread_name, std::function<void()> thread_func);\n \n } // namespace util\n \n\n\n###\n\n", "completion": "refactor: use std::string for thread names"}
{"prompt": " file path A: src/test/validation_chainstatemanager_tests.cpp | file path B: src/test/validation_chainstatemanager_tests.cpp\n\n@@ -10,6 +10,7 @@\n #include <sync.h>\n #include <test/util/chainstate.h>\n #include <test/util/setup_common.h>\n+#include <timedata.h>\n #include <uint256.h>\n #include <validation.h>\n #include <validationinterface.h>\n@@ -155,12 +156,32 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n }\n \n struct SnapshotTestSetup : TestChain100Setup {\n+    // Run with coinsdb on the filesystem to support, e.g., moving invalidated\n+    // chainstate dirs to \"*_invalid\".\n+    //\n+    // Note that this means the tests run considerably slower than in-memory DB\n+    // tests, but we can't otherwise test this functionality since it relies on\n+    // destructive filesystem operations.\n+    SnapshotTestSetup() : TestChain100Setup{\n+                              {},\n+                              {},\n+                              /*coins_db_in_memory=*/false,\n+                              /*block_tree_db_in_memory=*/false,\n+                          }\n+    {\n+    }\n+\n     std::tuple<Chainstate*, Chainstate*> SetupSnapshot()\n     {\n         ChainstateManager& chainman = *Assert(m_node.chainman);\n \n         BOOST_CHECK(!chainman.IsSnapshotActive());\n-        WITH_LOCK(::cs_main, BOOST_CHECK(!chainman.IsSnapshotValidated()));\n+\n+        {\n+            LOCK(::cs_main);\n+            BOOST_CHECK(!chainman.IsSnapshotValidated());\n+            BOOST_CHECK(!node::FindSnapshotChainstateDir());\n+        }\n \n         size_t initial_size;\n         size_t initial_total_coins{100};\n@@ -208,6 +229,9 @@ struct SnapshotTestSetup : TestChain100Setup {\n                 auto_infile >> outpoint;\n                 auto_infile >> coin;\n         }));\n+\n+        BOOST_CHECK(!node::FindSnapshotChainstateDir());\n+\n         BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n             this, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n                 // Coins count is larger than coins in file\n@@ -230,6 +254,7 @@ struct SnapshotTestSetup : TestChain100Setup {\n         }));\n \n         BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(this));\n+        BOOST_CHECK(fs::exists(*node::FindSnapshotChainstateDir()));\n \n         // Ensure our active chain is the snapshot chainstate.\n         BOOST_CHECK(!chainman.ActiveChainstate().m_from_snapshot_blockhash->IsNull());\n@@ -242,9 +267,11 @@ struct SnapshotTestSetup : TestChain100Setup {\n         {\n             LOCK(::cs_main);\n \n+            fs::path found = *node::FindSnapshotChainstateDir();\n+\n             // Note: WriteSnapshotBaseBlockhash() is implicitly tested above.\n             BOOST_CHECK_EQUAL(\n-                *node::ReadSnapshotBaseBlockhash(m_args.GetDataDirNet() / \"chainstate_snapshot\"),\n+                *node::ReadSnapshotBaseBlockhash(found),\n                 *chainman.SnapshotBlockhash());\n \n             // Ensure that the genesis block was not marked assumed-valid.\n@@ -328,6 +355,34 @@ struct SnapshotTestSetup : TestChain100Setup {\n             loaded_snapshot_blockhash);\n         return std::make_tuple(&validation_chainstate, &snapshot_chainstate);\n     }\n+\n+    // Simulate a restart of the node by flushing all state to disk, clearing the\n+    // existing ChainstateManager, and unloading the block index.\n+    //\n+    // @returns a reference to the \"restarted\" ChainstateManager\n+    ChainstateManager& SimulateNodeRestart()\n+    {\n+        ChainstateManager& chainman = *Assert(m_node.chainman);\n+\n+        BOOST_TEST_MESSAGE(\"Simulating node restart\");\n+        {\n+            LOCK(::cs_main);\n+            for (Chainstate* cs : chainman.GetAll()) {\n+                cs->ForceFlushStateToDisk();\n+            }\n+            chainman.ResetChainstates();\n+            BOOST_CHECK_EQUAL(chainman.GetAll().size(), 0);\n+            const ChainstateManager::Options chainman_opts{\n+                .chainparams = ::Params(),\n+                .adjusted_time_callback = GetAdjustedTime,\n+            };\n+            // For robustness, ensure the old manager is destroyed before creating a\n+            // new one.\n+            m_node.chainman.reset();\n+            m_node.chainman.reset(new ChainstateManager(chainman_opts));\n+        }\n+        return *Assert(m_node.chainman);\n+    }\n };\n \n //! Test basic snapshot activation.\n@@ -414,4 +469,59 @@ BOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)\n     BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes);\n }\n \n+//! Ensure that snapshot chainstates initialize properly when found on disk.\n+BOOST_FIXTURE_TEST_CASE(chainstatemanager_snapshot_init, SnapshotTestSetup)\n+{\n+    this->SetupSnapshot();\n+\n+    ChainstateManager& chainman = *Assert(m_node.chainman);\n+\n+    fs::path snapshot_chainstate_dir = *node::FindSnapshotChainstateDir();\n+    BOOST_CHECK(fs::exists(snapshot_chainstate_dir));\n+    BOOST_CHECK_EQUAL(snapshot_chainstate_dir, gArgs.GetDataDirNet() / \"chainstate_snapshot\");\n+\n+    BOOST_CHECK(chainman.IsSnapshotActive());\n+    const uint256 snapshot_tip_hash = WITH_LOCK(chainman.GetMutex(),\n+        return chainman.ActiveTip()->GetBlockHash());\n+\n+    auto all_chainstates = chainman.GetAll();\n+    BOOST_CHECK_EQUAL(all_chainstates.size(), 2);\n+\n+    // Test that simulating a shutdown (resetting ChainstateManager) and then performing\n+    // chainstate reinitializing successfully cleans up the background-validation\n+    // chainstate data, and we end up with a single chainstate that is at tip.\n+    ChainstateManager& chainman_restarted = this->SimulateNodeRestart();\n+\n+    BOOST_TEST_MESSAGE(\"Performing Load/Verify/Activate of chainstate\");\n+\n+    // This call reinitializes the chainstates.\n+    this->LoadVerifyActivateChainstate();\n+\n+    {\n+        LOCK(chainman_restarted.GetMutex());\n+        BOOST_CHECK_EQUAL(chainman_restarted.GetAll().size(), 2);\n+        BOOST_CHECK(chainman_restarted.IsSnapshotActive());\n+        BOOST_CHECK(!chainman_restarted.IsSnapshotValidated());\n+\n+        BOOST_CHECK_EQUAL(chainman_restarted.ActiveTip()->GetBlockHash(), snapshot_tip_hash);\n+        BOOST_CHECK_EQUAL(chainman_restarted.ActiveHeight(), 210);\n+    }\n+\n+    BOOST_TEST_MESSAGE(\n+        \"Ensure we can mine blocks on top of the initialized snapshot chainstate\");\n+    mineBlocks(10);\n+    {\n+        LOCK(chainman_restarted.GetMutex());\n+        BOOST_CHECK_EQUAL(chainman_restarted.ActiveHeight(), 220);\n+\n+        // Background chainstate should be unaware of new blocks on the snapshot\n+        // chainstate.\n+        for (Chainstate* cs : chainman_restarted.GetAll()) {\n+            if (cs != &chainman_restarted.ActiveChainstate()) {\n+                BOOST_CHECK_EQUAL(cs->m_chain.Height(), 110);\n+            }\n+        }\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()\n\n\n###\n\n", "completion": "test: add testcases for snapshot initialization"}
{"prompt": " file path A: src/test/util/setup_common.cpp | file path B: src/test/util/setup_common.cpp\n\n@@ -220,19 +220,8 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.chainman.reset();\n }\n \n-TestingSetup::TestingSetup(\n-    const std::string& chainName,\n-    const std::vector<const char*>& extra_args,\n-    const bool coins_db_in_memory,\n-    const bool block_tree_db_in_memory)\n-    : ChainTestingSetup(chainName, extra_args),\n-      m_coins_db_in_memory(coins_db_in_memory),\n-      m_block_tree_db_in_memory(block_tree_db_in_memory)\n+void TestingSetup::LoadVerifyActivateChainstate()\n {\n-    // Ideally we'd move all the RPC tests to the functional testing framework\n-    // instead of unit tests, but for now we need these here.\n-    RegisterAllCoreRPCCommands(tableRPC);\n-\n     node::ChainstateLoadOptions options;\n     options.mempool = Assert(m_node.mempool.get());\n     options.block_tree_db_in_memory = m_block_tree_db_in_memory;\n@@ -252,6 +241,22 @@ TestingSetup::TestingSetup(\n     if (!m_node.chainman->ActiveChainstate().ActivateBestChain(state)) {\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n+}\n+\n+TestingSetup::TestingSetup(\n+    const std::string& chainName,\n+    const std::vector<const char*>& extra_args,\n+    const bool coins_db_in_memory,\n+    const bool block_tree_db_in_memory)\n+    : ChainTestingSetup(chainName, extra_args),\n+      m_coins_db_in_memory(coins_db_in_memory),\n+      m_block_tree_db_in_memory(block_tree_db_in_memory)\n+{\n+    // Ideally we'd move all the RPC tests to the functional testing framework\n+    // instead of unit tests, but for now we need these here.\n+    RegisterAllCoreRPCCommands(tableRPC);\n+\n+    LoadVerifyActivateChainstate();\n \n     m_node.netgroupman = std::make_unique<NetGroupManager>(/*asmap=*/std::vector<bool>());\n     m_node.addrman = std::make_unique<AddrMan>(*m_node.netgroupman,\n\n---\n file path A: src/test/util/setup_common.h | file path B: src/test/util/setup_common.h\n\n@@ -110,6 +110,8 @@ struct TestingSetup : public ChainTestingSetup {\n     bool m_coins_db_in_memory{true};\n     bool m_block_tree_db_in_memory{true};\n \n+    void LoadVerifyActivateChainstate();\n+\n     explicit TestingSetup(\n         const std::string& chainName = CBaseChainParams::MAIN,\n         const std::vector<const char*>& extra_args = {},\n\n\n###\n\n", "completion": "test: move-only-ish: factor out LoadVerifyActivateChainstate()"}
{"prompt": " file path A: src/test/util/chainstate.h | file path B: src/test/util/chainstate.h\n\n@@ -30,7 +30,11 @@ const auto NoMalleation = [](AutoFile& file, node::SnapshotMetadata& meta){};\n  */\n template<typename F = decltype(NoMalleation)>\n static bool\n-CreateAndActivateUTXOSnapshot(TestingSetup* fixture, F malleation = NoMalleation, bool reset_chainstate = false)\n+CreateAndActivateUTXOSnapshot(\n+    TestingSetup* fixture,\n+    F malleation = NoMalleation,\n+    bool reset_chainstate = false,\n+    bool in_memory_chainstate = false)\n {\n     node::NodeContext& node = fixture->m_node;\n     fs::path root = fixture->m_path_root;\n@@ -88,7 +92,7 @@ CreateAndActivateUTXOSnapshot(TestingSetup* fixture, F malleation = NoMalleation\n             0 == WITH_LOCK(node.chainman->GetMutex(), return node.chainman->ActiveHeight()));\n     }\n \n-    return node.chainman->ActivateSnapshot(auto_infile, metadata, /*in_memory=*/true);\n+    return node.chainman->ActivateSnapshot(auto_infile, metadata, in_memory_chainstate);\n }\n \n \n\n---\n file path A: src/test/util/setup_common.cpp | file path B: src/test/util/setup_common.cpp\n\n@@ -220,8 +220,14 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.chainman.reset();\n }\n \n-TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const char*>& extra_args)\n-    : ChainTestingSetup(chainName, extra_args)\n+TestingSetup::TestingSetup(\n+    const std::string& chainName,\n+    const std::vector<const char*>& extra_args,\n+    const bool coins_db_in_memory,\n+    const bool block_tree_db_in_memory)\n+    : ChainTestingSetup(chainName, extra_args),\n+      m_coins_db_in_memory(coins_db_in_memory),\n+      m_block_tree_db_in_memory(block_tree_db_in_memory)\n {\n     // Ideally we'd move all the RPC tests to the functional testing framework\n     // instead of unit tests, but for now we need these here.\n@@ -229,8 +235,8 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n \n     node::ChainstateLoadOptions options;\n     options.mempool = Assert(m_node.mempool.get());\n-    options.block_tree_db_in_memory = true;\n-    options.coins_db_in_memory = true;\n+    options.block_tree_db_in_memory = m_block_tree_db_in_memory;\n+    options.coins_db_in_memory = m_coins_db_in_memory;\n     options.reindex = node::fReindex;\n     options.reindex_chainstate = m_args.GetBoolArg(\"-reindex-chainstate\", false);\n     options.prune = node::fPruneMode;\n@@ -263,8 +269,12 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     }\n }\n \n-TestChain100Setup::TestChain100Setup(const std::string& chain_name, const std::vector<const char*>& extra_args)\n-    : TestingSetup{chain_name, extra_args}\n+TestChain100Setup::TestChain100Setup(\n+        const std::string& chain_name,\n+        const std::vector<const char*>& extra_args,\n+        const bool coins_db_in_memory,\n+        const bool block_tree_db_in_memory)\n+    : TestingSetup{CBaseChainParams::REGTEST, extra_args, coins_db_in_memory, block_tree_db_in_memory}\n {\n     SetMockTime(1598887952);\n     constexpr std::array<unsigned char, 32> vchKey = {\n\n---\n file path A: src/test/util/setup_common.h | file path B: src/test/util/setup_common.h\n\n@@ -107,7 +107,14 @@ struct ChainTestingSetup : public BasicTestingSetup {\n /** Testing setup that configures a complete environment.\n  */\n struct TestingSetup : public ChainTestingSetup {\n-    explicit TestingSetup(const std::string& chainName = CBaseChainParams::MAIN, const std::vector<const char*>& extra_args = {});\n+    bool m_coins_db_in_memory{true};\n+    bool m_block_tree_db_in_memory{true};\n+\n+    explicit TestingSetup(\n+        const std::string& chainName = CBaseChainParams::MAIN,\n+        const std::vector<const char*>& extra_args = {},\n+        const bool coins_db_in_memory = true,\n+        const bool block_tree_db_in_memory = true);\n };\n \n /** Identical to TestingSetup, but chain set to regtest */\n@@ -124,8 +131,11 @@ class CScript;\n  * Testing fixture that pre-creates a 100-block REGTEST-mode block chain\n  */\n struct TestChain100Setup : public TestingSetup {\n-    TestChain100Setup(const std::string& chain_name = CBaseChainParams::REGTEST,\n-                      const std::vector<const char*>& extra_args = {});\n+    TestChain100Setup(\n+        const std::string& chain_name = CBaseChainParams::REGTEST,\n+        const std::vector<const char*>& extra_args = {},\n+        const bool coins_db_in_memory = true,\n+        const bool block_tree_db_in_memory = true);\n \n     /**\n      * Create a new block with just given transactions, coinbase paying to\n\n\n###\n\n", "completion": "test: allow on-disk coins and block tree dbs in tests"}
{"prompt": " file path A: src/test/util/chainstate.h | file path B: src/test/util/chainstate.h\n\n@@ -11,6 +11,7 @@\n #include <node/context.h>\n #include <node/utxo_snapshot.h>\n #include <rpc/blockchain.h>\n+#include <test/util/setup_common.h>\n #include <validation.h>\n \n #include <univalue.h>\n@@ -20,11 +21,20 @@ const auto NoMalleation = [](AutoFile& file, node::SnapshotMetadata& meta){};\n /**\n  * Create and activate a UTXO snapshot, optionally providing a function to\n  * malleate the snapshot.\n+ *\n+ * If `reset_chainstate` is true, reset the original chainstate back to the genesis\n+ * block. This allows us to simulate more realistic conditions in which a snapshot is\n+ * loaded into an otherwise mostly-uninitialized datadir. It also allows us to test\n+ * conditions that would otherwise cause shutdowns based on the IBD chainstate going\n+ * past the snapshot it generated.\n  */\n template<typename F = decltype(NoMalleation)>\n static bool\n-CreateAndActivateUTXOSnapshot(node::NodeContext& node, const fs::path root, F malleation = NoMalleation)\n+CreateAndActivateUTXOSnapshot(TestingSetup* fixture, F malleation = NoMalleation, bool reset_chainstate = false)\n {\n+    node::NodeContext& node = fixture->m_node;\n+    fs::path root = fixture->m_path_root;\n+\n     // Write out a snapshot to the test's tempdir.\n     //\n     int height;\n@@ -47,6 +57,37 @@ CreateAndActivateUTXOSnapshot(node::NodeContext& node, const fs::path root, F ma\n \n     malleation(auto_infile, metadata);\n \n+    if (reset_chainstate) {\n+        {\n+            // What follows is code to selectively reset chainstate data without\n+            // disturbing the existing BlockManager instance, which is needed to\n+            // recognize the headers chain previously generated by the chainstate we're\n+            // removing. Without those headers, we can't activate the snapshot below.\n+            //\n+            // This is a stripped-down version of node::LoadChainstate which\n+            // preserves the block index.\n+            LOCK(::cs_main);\n+            uint256 gen_hash = node.chainman->ActiveChainstate().m_chain[0]->GetBlockHash();\n+            node.chainman->ResetChainstates();\n+            node.chainman->InitializeChainstate(node.mempool.get());\n+            Chainstate& chain = node.chainman->ActiveChainstate();\n+            Assert(chain.LoadGenesisBlock());\n+            // These cache values will be corrected shortly in `MaybeRebalanceCaches`.\n+            chain.InitCoinsDB(1 << 20, true, false, \"\");\n+            chain.InitCoinsCache(1 << 20);\n+            chain.CoinsTip().SetBestBlock(gen_hash);\n+            chain.setBlockIndexCandidates.insert(node.chainman->m_blockman.LookupBlockIndex(gen_hash));\n+            chain.LoadChainTip();\n+            node.chainman->MaybeRebalanceCaches();\n+        }\n+        BlockValidationState state;\n+        if (!node.chainman->ActiveChainstate().ActivateBestChain(state)) {\n+            throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n+        }\n+        Assert(\n+            0 == WITH_LOCK(node.chainman->GetMutex(), return node.chainman->ActiveHeight()));\n+    }\n+\n     return node.chainman->ActivateSnapshot(auto_infile, metadata, /*in_memory=*/true);\n }\n \n\n---\n file path A: src/test/validation_chainstate_tests.cpp | file path B: src/test/validation_chainstate_tests.cpp\n\n@@ -89,7 +89,8 @@ BOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)\n     // After adding some blocks to the tip, best block should have changed.\n     BOOST_CHECK(::g_best_block != curr_tip);\n \n-    BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(m_node, m_path_root));\n+    BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(\n+        this, NoMalleation, /*reset_chainstate=*/ true));\n \n     // Ensure our active chain is the snapshot chainstate.\n     BOOST_CHECK(WITH_LOCK(::cs_main, return chainman.IsSnapshotActive()));\n\n---\n file path A: src/test/validation_chainstatemanager_tests.cpp | file path B: src/test/validation_chainstatemanager_tests.cpp\n\n@@ -185,7 +185,7 @@ struct SnapshotTestSetup : TestChain100Setup {\n         Chainstate& validation_chainstate = chainman.ActiveChainstate();\n \n         // Snapshot should refuse to load at this height.\n-        BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(m_node, m_path_root));\n+        BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(this));\n         BOOST_CHECK(!chainman.ActiveChainstate().m_from_snapshot_blockhash);\n         BOOST_CHECK(!chainman.SnapshotBlockhash());\n \n@@ -198,7 +198,7 @@ struct SnapshotTestSetup : TestChain100Setup {\n \n         // Should not load malleated snapshots\n         BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n-            m_node, m_path_root, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n+            this, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n                 // A UTXO is missing but count is correct\n                 metadata.m_coins_count -= 1;\n \n@@ -209,27 +209,27 @@ struct SnapshotTestSetup : TestChain100Setup {\n                 auto_infile >> coin;\n         }));\n         BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n-            m_node, m_path_root, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n+            this, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n                 // Coins count is larger than coins in file\n                 metadata.m_coins_count += 1;\n         }));\n         BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n-            m_node, m_path_root, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n+            this, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n                 // Coins count is smaller than coins in file\n                 metadata.m_coins_count -= 1;\n         }));\n         BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n-            m_node, m_path_root, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n+            this, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n                 // Wrong hash\n                 metadata.m_base_blockhash = uint256::ZERO;\n         }));\n         BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(\n-            m_node, m_path_root, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n+            this, [](AutoFile& auto_infile, SnapshotMetadata& metadata) {\n                 // Wrong hash\n                 metadata.m_base_blockhash = uint256::ONE;\n         }));\n \n-        BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(m_node, m_path_root));\n+        BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(this));\n \n         // Ensure our active chain is the snapshot chainstate.\n         BOOST_CHECK(!chainman.ActiveChainstate().m_from_snapshot_blockhash->IsNull());\n@@ -320,7 +320,7 @@ struct SnapshotTestSetup : TestChain100Setup {\n         }\n \n         // Snapshot should refuse to load after one has already loaded.\n-        BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(m_node, m_path_root));\n+        BOOST_REQUIRE(!CreateAndActivateUTXOSnapshot(this));\n \n         // Snapshot blockhash should be unchanged.\n         BOOST_CHECK_EQUAL(\n\n\n###\n\n", "completion": "test: add reset_chainstate parameter for snapshot unittests"}
{"prompt": " file path A: src/Makefile.am | file path B: src/Makefile.am\n\n@@ -23,7 +23,7 @@ noinst_PROGRAMS =\n TESTS =\n BENCHMARKS =\n \n-BITCOIN_INCLUDES=-I$(builddir) -I$(srcdir)/$(MINISKETCH_INCLUDE_DIR_INT) -I$(srcdir)/secp256k1/include -I$(srcdir)/$(UNIVALUE_INCLUDE_DIR_INT) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS)\n+BITCOIN_INCLUDES=-I$(builddir) -I$(srcdir)/$(MINISKETCH_INCLUDE_DIR_INT) -I$(srcdir)/secp256k1/include -I$(srcdir)/$(UNIVALUE_INCLUDE_DIR_INT) $(LEVELDB_CPPFLAGS)\n \n LIBBITCOIN_NODE=libbitcoin_node.a\n LIBBITCOIN_COMMON=libbitcoin_common.a\n@@ -349,7 +349,7 @@ libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n # Contains code accessing mempool and chain state that is meant to be separated\n # from wallet and gui code (see node/README.md). Shared code should go in\n # libbitcoin_common or libbitcoin_util libraries, instead.\n-libbitcoin_node_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libbitcoin_node_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_node_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_node_a_SOURCES = \\\n   addrdb.cpp \\\n@@ -439,7 +439,7 @@ libbitcoin_node_a_SOURCES += dummywallet.cpp\n endif\n \n if ENABLE_ZMQ\n-libbitcoin_zmq_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(ZMQ_CFLAGS)\n+libbitcoin_zmq_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(ZMQ_CFLAGS)\n libbitcoin_zmq_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_zmq_a_SOURCES = \\\n   zmq/zmqabstractnotifier.cpp \\\n@@ -452,7 +452,7 @@ endif\n \n # wallet: shared between bitcoind and bitcoin-qt, but only linked\n # when wallet enabled\n-libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BDB_CPPFLAGS) $(SQLITE_CFLAGS)\n+libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(BDB_CPPFLAGS) $(SQLITE_CFLAGS)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_wallet_a_SOURCES = \\\n   wallet/coincontrol.cpp \\\n@@ -491,7 +491,7 @@ if USE_BDB\n libbitcoin_wallet_a_SOURCES += wallet/bdb.cpp wallet/salvage.cpp\n endif\n \n-libbitcoin_wallet_tool_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+libbitcoin_wallet_tool_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libbitcoin_wallet_tool_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_wallet_tool_a_SOURCES = \\\n   wallet/wallettool.cpp \\\n@@ -655,7 +655,7 @@ libbitcoin_common_a_SOURCES = \\\n   $(BITCOIN_CORE_H)\n \n # util: shared between all executables.\n-libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_util_a_SOURCES = \\\n   support/lockedpool.cpp \\\n@@ -772,7 +772,7 @@ bitcoin_cli_LDADD += $(EVENT_LIBS)\n \n # bitcoin-tx binary #\n bitcoin_tx_SOURCES = bitcoin-tx.cpp\n-bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n \n@@ -833,7 +833,7 @@ bitcoin_util_LDADD = \\\n \n # bitcoin-chainstate binary #\n bitcoin_chainstate_SOURCES = bitcoin-chainstate.cpp\n-bitcoin_chainstate_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+bitcoin_chainstate_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n bitcoin_chainstate_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n # $(LIBTOOL_APP_LDFLAGS) deliberately omitted here so that we can test linking\n\n---\n file path A: src/Makefile.bench.include | file path B: src/Makefile.bench.include\n\n@@ -51,7 +51,7 @@ bench_bench_bitcoin_SOURCES = \\\n \n nodist_bench_bench_bitcoin_SOURCES = $(GENERATED_BENCH_FILES)\n \n-bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n+bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bench_bench_bitcoin_LDADD = \\\n   $(LIBTEST_UTIL) \\\n\n---\n file path A: src/Makefile.qt.include | file path B: src/Makefile.qt.include\n\n@@ -295,7 +295,7 @@ BITCOIN_QT_RC = qt/res/bitcoin-qt-res.rc\n BITCOIN_QT_INCLUDES = -DQT_NO_KEYWORDS -DQT_USE_QSTRINGBUILDER\n \n qt_libbitcoinqt_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n-  $(QT_INCLUDES) $(QT_DBUS_INCLUDES) $(QR_CFLAGS)\n+  $(QT_INCLUDES) $(QT_DBUS_INCLUDES) $(QR_CFLAGS) $(BOOST_CPPFLAGS)\n qt_libbitcoinqt_a_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n qt_libbitcoinqt_a_OBJCXXFLAGS = $(AM_OBJCXXFLAGS) $(QT_PIE_FLAGS)\n \n\n---\n file path A: src/Makefile.qttest.include | file path B: src/Makefile.qttest.include\n\n@@ -27,7 +27,7 @@ TEST_QT_H = \\\n   qt/test/wallettests.h\n \n qt_test_test_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n-  $(QT_INCLUDES) $(QT_TEST_INCLUDES)\n+  $(QT_INCLUDES) $(QT_TEST_INCLUDES) $(BOOST_CPPFLAGS)\n \n qt_test_test_bitcoin_qt_SOURCES = \\\n   init/bitcoin-qt.cpp \\\n\n---\n file path A: src/Makefile.test.include | file path B: src/Makefile.test.include\n\n@@ -203,7 +203,7 @@ BITCOIN_TEST_SUITE += \\\n endif # ENABLE_WALLET\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TEST_SUITE) $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n-test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(TESTDEFS) $(EVENT_CFLAGS)\n+test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(TESTDEFS) $(BOOST_CPPFLAGS) $(EVENT_CFLAGS)\n test_test_bitcoin_LDADD = $(LIBTEST_UTIL)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n@@ -223,7 +223,7 @@ FUZZ_SUITE_LD_COMMON += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n \n if ENABLE_FUZZ_BINARY\n-test_fuzz_fuzz_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_fuzz_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS)\n test_fuzz_fuzz_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_fuzz_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_fuzz_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS) $(RUNTIME_LDFLAGS)\n\n---\n file path A: src/Makefile.test_fuzz.include | file path B: src/Makefile.test_fuzz.include\n\n@@ -13,7 +13,7 @@ TEST_FUZZ_H = \\\n     test/fuzz/mempool_utils.h \\\n     test/fuzz/util.h\n \n-libtest_fuzz_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libtest_fuzz_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libtest_fuzz_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libtest_fuzz_a_SOURCES = \\\n   test/fuzz/fuzz.cpp \\\n\n---\n file path A: src/Makefile.test_util.include | file path B: src/Makefile.test_util.include\n\n@@ -20,7 +20,7 @@ TEST_UTIL_H = \\\n     test/util/validation.h \\\n     test/util/wallet.h\n \n-libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n+libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libtest_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libtest_util_a_SOURCES = \\\n   test/util/blockfilter.cpp \\\n\n\n###\n\n", "completion": "build: extract $(BOOST_CPPFLAGS) from $(BITCOIN_INCLUDES)"}
{"prompt": " file path A: depends/packages/bdb.mk | file path B: depends/packages/bdb.mk\n\n@@ -15,6 +15,9 @@ $(package)_config_opts_netbsd=--with-pic\n $(package)_config_opts_openbsd=--with-pic\n $(package)_config_opts_android=--with-pic\n $(package)_cflags+=-Wno-error=implicit-function-declaration -Wno-error=format-security\n+$(package)_cppflags_freebsd=-D_XOPEN_SOURCE=600\n+$(package)_cppflags_netbsd=-D_XOPEN_SOURCE=600\n+$(package)_cppflags_openbsd=-D_XOPEN_SOURCE=600\n $(package)_cppflags_mingw32=-DUNICODE -D_UNICODE\n endef\n \n\n\n###\n\n", "completion": "build: fix depends bdb compilation for BSDs"}
{"prompt": " file path A: configure.ac | file path B: configure.ac\n\n@@ -746,6 +746,16 @@ case $host in\n          dnl It's safe to add these paths even if the functionality is disabled by\n          dnl the user (--without-wallet or --without-gui for example).\n \n+         dnl Homebrew may create symlinks in /usr/local/include for some packages.\n+         dnl Because MacOS's clang internally adds \"-I /usr/local/include\" to its search\n+         dnl paths, this will negate efforts to use -isystem for those packages, as they\n+         dnl will be found first in /usr/local. Use the internal \"-internal-isystem\"\n+         dnl option to system-ify all /usr/local/include paths without adding it to the list\n+         dnl of search paths in case it's not already there.\n+         if test \"$suppress_external_warnings\" != \"no\"; then\n+           AX_CHECK_PREPROC_FLAG([-Xclang -internal-isystem/usr/local/include], [CORE_CPPFLAGS=\"$CORE_CPPFLAGS -Xclang -internal-isystem/usr/local/include\"], [], [$CXXFLAG_WERROR])\n+         fi\n+\n          if test \"$use_bdb\" != \"no\" && $BREW list --versions berkeley-db@4 >/dev/null && test \"$BDB_CFLAGS\" = \"\" && test \"$BDB_LIBS\" = \"\"; then\n            bdb_prefix=$($BREW --prefix berkeley-db@4 2>/dev/null)\n            dnl This must precede the call to BITCOIN_FIND_BDB48 below.\n\n\n###\n\n", "completion": "build: quiet warnings in system headers installed from homebrew"}
{"prompt": " file path A: depends/packages/qt.mk | file path B: depends/packages/qt.mk\n\n@@ -56,6 +56,7 @@ $(package)_config_opts += -no-linuxfb\n $(package)_config_opts += -no-libjpeg\n $(package)_config_opts += -no-libproxy\n $(package)_config_opts += -no-libudev\n+$(package)_config_opts += -no-mimetype-database\n $(package)_config_opts += -no-mtdev\n $(package)_config_opts += -no-openssl\n $(package)_config_opts += -no-openvg\n\n\n###\n\n", "completion": "build: Add `-no-mimetype-database` option to qt package in depends"}
{"prompt": " file path A: test/functional/rpc_invalidateblock.py | file path B: test/functional/rpc_invalidateblock.py\n\n@@ -85,9 +85,8 @@ class InvalidateTest(BitcoinTestFramework):\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n \n         self.log.info(\"Verify that invalidating an unknown block throws an error\")\n-        chain_tips = self.nodes[1].getchaintips()\n         assert_raises_rpc_error(-5, \"Block not found\", self.nodes[1].invalidateblock, \"00\" * 32)\n-        assert_equal(chain_tips, self.nodes[1].getchaintips())\n+        assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n \n \n if __name__ == '__main__':\n\n\n###\n\n", "completion": "test: verify best blockhash after invalidating an unknown block"}
{"prompt": " file path A: test/functional/rpc_invalidateblock.py | file path B: test/functional/rpc_invalidateblock.py\n\n@@ -8,6 +8,7 @@ from test_framework.test_framework import BitcoinTestFramework\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR\n from test_framework.util import (\n     assert_equal,\n+    assert_raises_rpc_error,\n )\n \n \n@@ -83,6 +84,11 @@ class InvalidateTest(BitcoinTestFramework):\n         # Should be back at the tip by now\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n \n+        self.log.info(\"Verify that invalidating an unknown block throws an error\")\n+        chain_tips = self.nodes[1].getchaintips()\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[1].invalidateblock, \"00\" * 32)\n+        assert_equal(chain_tips, self.nodes[1].getchaintips())\n+\n \n if __name__ == '__main__':\n     InvalidateTest().main()\n\n\n###\n\n", "completion": "test: invalidating an unknown block throws an error"}
{"prompt": " file path A: test/functional/test_runner.py | file path B: test/functional/test_runner.py\n\n@@ -555,14 +555,14 @@ def run_tests(*, test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=\n     while i < test_count:\n         if failfast and not all_passed:\n             break\n-        for test_result, testdir, stdout, stderr in job_queue.get_next():\n+        for test_result, testdir, stdout, stderr, skip_reason in job_queue.get_next():\n             test_results.append(test_result)\n             i += 1\n             done_str = \"{}/{} - {}{}{}\".format(i, test_count, BOLD[1], test_result.name, BOLD[0])\n             if test_result.status == \"Passed\":\n                 logging.debug(\"%s passed, Duration: %s s\" % (done_str, test_result.time))\n             elif test_result.status == \"Skipped\":\n-                logging.debug(\"%s skipped\" % (done_str))\n+                logging.debug(f\"{done_str} skipped ({skip_reason})\")\n             else:\n                 all_passed = False\n                 print(\"%s failed, Duration: %s s\\n\" % (done_str, test_result.time))\n@@ -686,10 +686,12 @@ class TestHandler:\n                     log_out.seek(0), log_err.seek(0)\n                     [stdout, stderr] = [log_file.read().decode('utf-8') for log_file in (log_out, log_err)]\n                     log_out.close(), log_err.close()\n+                    skip_reason = None\n                     if proc.returncode == TEST_EXIT_PASSED and stderr == \"\":\n                         status = \"Passed\"\n                     elif proc.returncode == TEST_EXIT_SKIPPED:\n                         status = \"Skipped\"\n+                        skip_reason = re.search(r\"Test Skipped: (.*)\", stdout).group(1)\n                     else:\n                         status = \"Failed\"\n                     self.num_running -= 1\n@@ -698,7 +700,7 @@ class TestHandler:\n                         clearline = '\\r' + (' ' * dot_count) + '\\r'\n                         print(clearline, end='', flush=True)\n                     dot_count = 0\n-                    ret.append((TestResult(name, status, int(time.time() - start_time)), testdir, stdout, stderr))\n+                    ret.append((TestResult(name, status, int(time.time() - start_time)), testdir, stdout, stderr, skip_reason))\n             if ret:\n                 return ret\n             if self.use_term_control:\n\n\n###\n\n", "completion": "test: Display skipped tests reason"}
{"prompt": " file path A: test/functional/wallet_listsinceblock.py | file path B: test/functional/wallet_listsinceblock.py\n\n@@ -42,7 +42,8 @@ class ListSinceBlockTest(BitcoinTestFramework):\n         self.test_double_send()\n         self.double_spends_filtered()\n         self.test_targetconfirmations()\n-        self.test_desc()\n+        if self.options.descriptors:\n+            self.test_desc()\n         self.test_send_to_self()\n \n     def test_no_blockhash(self):\n\n\n###\n\n", "completion": "test: Fix `wallet_listsinceblock.py` for BDB-only wallets"}
{"prompt": " file path A: test/functional/wallet_basic.py | file path B: test/functional/wallet_basic.py\n\n@@ -695,37 +695,38 @@ class WalletTest(BitcoinTestFramework):\n         txid_feeReason_four = self.nodes[2].sendmany(dummy='', amounts={address: 5}, verbose=False)\n         assert_equal(self.nodes[2].gettransaction(txid_feeReason_four)['txid'], txid_feeReason_four)\n \n-        self.log.info(\"Testing 'listunspent' outputs the parent descriptor(s) of coins\")\n-        # Create two multisig descriptors, and send a UTxO each.\n-        multi_a = descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4YBNjUo96Jxd1u4XKWgnoc7LsA1jz3Yc2NiDbhtfBhaBtemB73n9V5vtJHwU6FVXwggTbeoJWQ1rzdz8ysDuQkpnaHyvnvzR/*,tpubD6NzVbkrYhZ4YHdDGMAYGaWxMSC1B6tPRTHuU5t3BcfcS3nrF523iFm5waFd1pP3ZvJt4Jr8XmCmsTBNx5suhcSgtzpGjGMASR3tau1hJz4/*))\")\n-        multi_b = descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4YHdDGMAYGaWxMSC1B6tPRTHuU5t3BcfcS3nrF523iFm5waFd1pP3ZvJt4Jr8XmCmsTBNx5suhcSgtzpGjGMASR3tau1hJz4/*,tpubD6NzVbkrYhZ4Y2RLiuEzNQkntjmsLpPYDm3LTRBYynUQtDtpzeUKAcb9sYthSFL3YR74cdFgF5mW8yKxv2W2CWuZDFR2dUpE5PF9kbrVXNZ/*))\")\n-        addr_a = self.nodes[0].deriveaddresses(multi_a, 0)[0]\n-        addr_b = self.nodes[0].deriveaddresses(multi_b, 0)[0]\n-        txid_a = self.nodes[0].sendtoaddress(addr_a, 0.01)\n-        txid_b = self.nodes[0].sendtoaddress(addr_b, 0.01)\n-        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n-        # Now import the descriptors, make sure we can identify on which descriptor each coin was received.\n-        self.nodes[0].createwallet(wallet_name=\"wo\", descriptors=True, disable_private_keys=True)\n-        wo_wallet = self.nodes[0].get_wallet_rpc(\"wo\")\n-        wo_wallet.importdescriptors([\n-            {\n-                \"desc\": multi_a,\n-                \"active\": False,\n-                \"timestamp\": \"now\",\n-            },\n-            {\n-                \"desc\": multi_b,\n-                \"active\": False,\n-                \"timestamp\": \"now\",\n-            },\n-        ])\n-        coins = wo_wallet.listunspent(minconf=0)\n-        assert_equal(len(coins), 2)\n-        coin_a = next(c for c in coins if c[\"txid\"] == txid_a)\n-        assert_equal(coin_a[\"parent_descs\"][0], multi_a)\n-        coin_b = next(c for c in coins if c[\"txid\"] == txid_b)\n-        assert_equal(coin_b[\"parent_descs\"][0], multi_b)\n-        self.nodes[0].unloadwallet(\"wo\")\n+        if self.options.descriptors:\n+            self.log.info(\"Testing 'listunspent' outputs the parent descriptor(s) of coins\")\n+            # Create two multisig descriptors, and send a UTxO each.\n+            multi_a = descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4YBNjUo96Jxd1u4XKWgnoc7LsA1jz3Yc2NiDbhtfBhaBtemB73n9V5vtJHwU6FVXwggTbeoJWQ1rzdz8ysDuQkpnaHyvnvzR/*,tpubD6NzVbkrYhZ4YHdDGMAYGaWxMSC1B6tPRTHuU5t3BcfcS3nrF523iFm5waFd1pP3ZvJt4Jr8XmCmsTBNx5suhcSgtzpGjGMASR3tau1hJz4/*))\")\n+            multi_b = descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4YHdDGMAYGaWxMSC1B6tPRTHuU5t3BcfcS3nrF523iFm5waFd1pP3ZvJt4Jr8XmCmsTBNx5suhcSgtzpGjGMASR3tau1hJz4/*,tpubD6NzVbkrYhZ4Y2RLiuEzNQkntjmsLpPYDm3LTRBYynUQtDtpzeUKAcb9sYthSFL3YR74cdFgF5mW8yKxv2W2CWuZDFR2dUpE5PF9kbrVXNZ/*))\")\n+            addr_a = self.nodes[0].deriveaddresses(multi_a, 0)[0]\n+            addr_b = self.nodes[0].deriveaddresses(multi_b, 0)[0]\n+            txid_a = self.nodes[0].sendtoaddress(addr_a, 0.01)\n+            txid_b = self.nodes[0].sendtoaddress(addr_b, 0.01)\n+            self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n+            # Now import the descriptors, make sure we can identify on which descriptor each coin was received.\n+            self.nodes[0].createwallet(wallet_name=\"wo\", descriptors=True, disable_private_keys=True)\n+            wo_wallet = self.nodes[0].get_wallet_rpc(\"wo\")\n+            wo_wallet.importdescriptors([\n+                {\n+                    \"desc\": multi_a,\n+                    \"active\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {\n+                    \"desc\": multi_b,\n+                    \"active\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            coins = wo_wallet.listunspent(minconf=0)\n+            assert_equal(len(coins), 2)\n+            coin_a = next(c for c in coins if c[\"txid\"] == txid_a)\n+            assert_equal(coin_a[\"parent_descs\"][0], multi_a)\n+            coin_b = next(c for c in coins if c[\"txid\"] == txid_b)\n+            assert_equal(coin_b[\"parent_descs\"][0], multi_b)\n+            self.nodes[0].unloadwallet(\"wo\")\n \n \n if __name__ == '__main__':\n\n\n###\n\n", "completion": "test: Fix `wallet_basic.py` for BDB-only wallets"}
{"prompt": " file path A: src/wallet/test/coinselector_tests.cpp | file path B: src/wallet/test/coinselector_tests.cpp\n\n@@ -301,6 +301,8 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     coin_selection_params_bnb.m_change_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_output_size);\n     coin_selection_params_bnb.m_cost_of_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size) + coin_selection_params_bnb.m_change_fee;\n     coin_selection_params_bnb.min_viable_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size);\n+    coin_selection_params_bnb.m_subtract_fee_outputs = true;\n+\n     {\n         std::unique_ptr<CWallet> wallet = std::make_unique<CWallet>(m_node.chain.get(), \"\", m_args, CreateMockWalletDatabase());\n         wallet->LoadWallet();\n@@ -318,7 +320,6 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         available_coins.Clear();\n         add_coin(available_coins, *wallet, 1 * CENT, coin_selection_params_bnb.m_effective_feerate);\n         available_coins.All().at(0).input_bytes = 40;\n-        coin_selection_params_bnb.m_subtract_fee_outputs = true;\n         const auto result9 = SelectCoinsBnB(GroupCoins(available_coins.All()), 1 * CENT, coin_selection_params_bnb.m_cost_of_change);\n         BOOST_CHECK(result9);\n         BOOST_CHECK_EQUAL(result9->GetSelectedValue(), 1 * CENT);\n\n\n###\n\n", "completion": "test: Change coinselection parameter location to make tests independent"}
{"prompt": " file path A: src/test/util/chainstate.h | file path B: src/test/util/chainstate.h\n\n@@ -7,6 +7,7 @@\n \n #include <clientversion.h>\n #include <fs.h>\n+#include <logging.h>\n #include <node/context.h>\n #include <node/utxo_snapshot.h>\n #include <rpc/blockchain.h>\n@@ -14,8 +15,6 @@\n \n #include <univalue.h>\n \n-#include <boost/test/unit_test.hpp>\n-\n const auto NoMalleation = [](AutoFile& file, node::SnapshotMetadata& meta){};\n \n /**\n@@ -36,8 +35,8 @@ CreateAndActivateUTXOSnapshot(node::NodeContext& node, const fs::path root, F ma\n \n     UniValue result = CreateUTXOSnapshot(\n         node, node.chainman->ActiveChainstate(), auto_outfile, snapshot_path, snapshot_path);\n-    BOOST_TEST_MESSAGE(\n-        \"Wrote UTXO snapshot to \" << fs::PathToString(snapshot_path.make_preferred()) << \": \" << result.write());\n+    LogPrintf(\n+        \"Wrote UTXO snapshot to %s: %s\", fs::PathToString(snapshot_path.make_preferred()), result.write());\n \n     // Read the written snapshot in and then activate it.\n     //\n\n\n###\n\n", "completion": "test: remove Boost Test from libtest util"}
{"prompt": " file path A: configure.ac | file path B: configure.ac\n\n@@ -1695,11 +1695,12 @@ AM_CONDITIONAL([BUILD_BITCOIN_UTIL], [test $build_bitcoin_util = \"yes\"])\n AC_MSG_RESULT($build_bitcoin_util)\n \n AC_MSG_CHECKING([whether to build experimental bitcoin-chainstate])\n-if test \"$build_experimental_kernel_lib\" = \"no\"; then\n-AC_MSG_ERROR([experimental bitcoin-chainstate cannot be built without the experimental bitcoinkernel library. Use --with-experimental-kernel-lib]);\n-else\n-  AM_CONDITIONAL([BUILD_BITCOIN_CHAINSTATE], [test $build_bitcoin_chainstate = \"yes\"])\n+if test \"$build_bitcoin_chainstate\" = \"yes\"; then\n+  if test \"$build_experimental_kernel_lib\" = \"no\"; then\n+    AC_MSG_ERROR([experimental bitcoin-chainstate cannot be built without the experimental bitcoinkernel library. Use --with-experimental-kernel-lib]);\n+  fi\n fi\n+AM_CONDITIONAL([BUILD_BITCOIN_CHAINSTATE], [test $build_bitcoin_chainstate = \"yes\"])\n AC_MSG_RESULT($build_bitcoin_chainstate)\n \n AC_MSG_CHECKING([whether to build libraries])\n\n\n###\n\n", "completion": "build: fix configuring with --without-experimental-kernel-lib"}
{"prompt": " file path A: build-aux/m4/ax_boost_base.m4 | file path B: build-aux/m4/ax_boost_base.m4\n\n@@ -11,9 +11,9 @@\n #   Test for the Boost C++ libraries of a particular version (or newer)\n #\n #   If no path to the installed boost library is given the macro searchs\n-#   under /usr, /usr/local, /opt, /opt/local and /opt/homebrew and evaluates the\n-#   $BOOST_ROOT environment variable. Further documentation is available at\n-#   <http://randspringer.de/boost/index.html>.\n+#   under /usr, /usr/local, /opt, /opt/local and /opt/homebrew and evaluates\n+#   the $BOOST_ROOT environment variable. Further documentation is available\n+#   at <http://randspringer.de/boost/index.html>.\n #\n #   This macro calls:\n #\n@@ -33,7 +33,7 @@\n #   and this notice are preserved. This file is offered as-is, without any\n #   warranty.\n \n-#serial 48\n+#serial 51\n \n # example boost program (need to pass version)\n m4_define([_AX_BOOST_BASE_PROGRAM],\n@@ -114,7 +114,7 @@ AC_DEFUN([_AX_BOOST_BASE_RUNDETECT],[\n     AS_CASE([${host_cpu}],\n       [x86_64],[libsubdirs=\"lib64 libx32 lib lib64\"],\n       [mips*64*],[libsubdirs=\"lib64 lib32 lib lib64\"],\n-      [ppc64|powerpc64|s390x|sparc64|aarch64|ppc64le|powerpc64le|riscv64],[libsubdirs=\"lib64 lib lib64\"],\n+      [ppc64|powerpc64|s390x|sparc64|aarch64|ppc64le|powerpc64le|riscv64|e2k],[libsubdirs=\"lib64 lib lib64\"],\n       [libsubdirs=\"lib\"]\n     )\n \n@@ -128,7 +128,7 @@ AC_DEFUN([_AX_BOOST_BASE_RUNDETECT],[\n     )\n \n     dnl first we check the system location for boost libraries\n-    dnl this location ist chosen if boost libraries are installed with the --layout=system option\n+    dnl this location is chosen if boost libraries are installed with the --layout=system option\n     dnl or if you install boost with RPM\n     AS_IF([test \"x$_AX_BOOST_BASE_boost_path\" != \"x\"],[\n         AC_MSG_CHECKING([for boostlib >= $1 ($WANT_BOOST_VERSION) includes in \"$_AX_BOOST_BASE_boost_path/include\"])\n@@ -151,7 +151,7 @@ AC_DEFUN([_AX_BOOST_BASE_RUNDETECT],[\n         else\n             search_libsubdirs=\"$multiarch_libsubdir $libsubdirs\"\n         fi\n-        for _AX_BOOST_BASE_boost_path_tmp in /usr /usr/local /opt /opt/local /opt/homebrew/; do\n+        for _AX_BOOST_BASE_boost_path_tmp in /usr /usr/local /opt /opt/local /opt/homebrew ; do\n             if test -d \"$_AX_BOOST_BASE_boost_path_tmp/include/boost\" && test -r \"$_AX_BOOST_BASE_boost_path_tmp/include/boost\" ; then\n                 for libsubdir in $search_libsubdirs ; do\n                     if ls \"$_AX_BOOST_BASE_boost_path_tmp/$libsubdir/libboost_\"* >/dev/null 2>&1 ; then break; fi\n\n\n###\n\n", "completion": "build: sync ax_boost_base from upstream"}
{"prompt": " file path A: test/functional/wallet_groups.py | file path B: test/functional/wallet_groups.py\n\n@@ -26,9 +26,10 @@ class WalletGroupTest(BitcoinTestFramework):\n             [\"-maxapsfee=0.00002719\"],\n             [\"-maxapsfee=0.00002720\"],\n         ]\n-        # whitelist peers to speed up tx relay / mempool sync\n+\n         for args in self.extra_args:\n-            args.append(\"-whitelist=noban@127.0.0.1\")\n+            args.append(\"-whitelist=noban@127.0.0.1\")   # whitelist peers to speed up tx relay / mempool sync\n+            args.append(f\"-paytxfee={20 * 1e3 / 1e8}\")  # apply feerate of 20 sats/vB across all nodes\n \n         self.rpc_timeout = 480\n \n\n\n###\n\n", "completion": "test: apply fixed feerate to avoid variable dynamic fees"}
{"prompt": " file path A: test/functional/p2p_headers_sync_with_minchainwork.py | file path B: test/functional/p2p_headers_sync_with_minchainwork.py\n\n@@ -49,7 +49,7 @@ class RejectLowDifficultyHeadersTest(BitcoinTestFramework):\n \n     def test_chains_sync_when_long_enough(self):\n         self.log.info(\"Generate blocks on the node with no required chainwork, and verify nodes 1 and 2 have no new headers in their headers tree\")\n-        with self.nodes[1].assert_debug_log(expected_msgs=[\"[net] Ignoring low-work chain (height=14)\"]), self.nodes[2].assert_debug_log(expected_msgs=[\"[net] Ignoring low-work chain (height=14)\"]):\n+        with self.nodes[1].assert_debug_log(expected_msgs=[\"[net] Ignoring low-work chain (height=14)\"]), self.nodes[2].assert_debug_log(expected_msgs=[\"[net] Ignoring low-work chain (height=14)\"]), self.nodes[3].assert_debug_log(expected_msgs=[\"Synchronizing blockheaders, height: 14\"]):\n             self.generate(self.nodes[0], NODE1_BLOCKS_REQUIRED-1, sync_fun=self.no_op)\n \n         # Node3 should always allow headers due to noban permissions\n@@ -78,7 +78,7 @@ class RejectLowDifficultyHeadersTest(BitcoinTestFramework):\n             } in chaintips\n \n         self.log.info(\"Generate more blocks to satisfy node1's minchainwork requirement, and verify node2 still has no new headers in headers tree\")\n-        with self.nodes[2].assert_debug_log(expected_msgs=[\"[net] Ignoring low-work chain (height=15)\"]):\n+        with self.nodes[2].assert_debug_log(expected_msgs=[\"[net] Ignoring low-work chain (height=15)\"]), self.nodes[3].assert_debug_log(expected_msgs=[\"Synchronizing blockheaders, height: 15\"]):\n             self.generate(self.nodes[0], NODE1_BLOCKS_REQUIRED - self.nodes[0].getblockcount(), sync_fun=self.no_op)\n         self.sync_blocks(self.nodes[0:2]) # node3 will sync headers (noban permissions) but not blocks (due to minchainwork)\n \n\n\n###\n\n", "completion": "test: fix non-determinism in p2p_headers_sync_with_minchainwork.py"}
{"prompt": " file path A: src/blockfilter.h | file path B: src/blockfilter.h\n\n@@ -11,6 +11,7 @@\n #include <unordered_set>\n #include <vector>\n \n+#include <attributes.h>\n #include <primitives/block.h>\n #include <serialize.h>\n #include <uint256.h>\n@@ -65,8 +66,8 @@ public:\n     GCSFilter(const Params& params, const ElementSet& elements);\n \n     uint32_t GetN() const { return m_N; }\n-    const Params& GetParams() const { return m_params; }\n-    const std::vector<unsigned char>& GetEncoded() const { return m_encoded; }\n+    const Params& GetParams() const LIFETIMEBOUND { return m_params; }\n+    const std::vector<unsigned char>& GetEncoded() const LIFETIMEBOUND { return m_encoded; }\n \n     /**\n      * Checks if the element may be in the set. False positives are possible\n@@ -128,10 +129,10 @@ public:\n     BlockFilter(BlockFilterType filter_type, const CBlock& block, const CBlockUndo& block_undo);\n \n     BlockFilterType GetFilterType() const { return m_filter_type; }\n-    const uint256& GetBlockHash() const { return m_block_hash; }\n-    const GCSFilter& GetFilter() const { return m_filter; }\n+    const uint256& GetBlockHash() const LIFETIMEBOUND { return m_block_hash; }\n+    const GCSFilter& GetFilter() const LIFETIMEBOUND { return m_filter; }\n \n-    const std::vector<unsigned char>& GetEncodedFilter() const\n+    const std::vector<unsigned char>& GetEncodedFilter() const LIFETIMEBOUND\n     {\n         return m_filter.GetEncoded();\n     }\n\n---\n file path A: src/index/blockfilterindex.h | file path B: src/index/blockfilterindex.h\n\n@@ -5,6 +5,7 @@\n #ifndef BITCOIN_INDEX_BLOCKFILTERINDEX_H\n #define BITCOIN_INDEX_BLOCKFILTERINDEX_H\n \n+#include <attributes.h>\n #include <blockfilter.h>\n #include <chain.h>\n #include <flatfile.h>\n@@ -49,9 +50,9 @@ protected:\n \n     bool CustomRewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip) override;\n \n-    BaseIndex::DB& GetDB() const override { return *m_db; }\n+    BaseIndex::DB& GetDB() const LIFETIMEBOUND override { return *m_db; }\n \n-    const char* GetName() const override { return m_name.c_str(); }\n+    const char* GetName() const LIFETIMEBOUND override { return m_name.c_str(); }\n \n public:\n     /** Constructs the index, which becomes available to be queried. */\n\n\n###\n\n", "completion": "refactor: add LIFETIMEBOUND to blockfilter where needed"}
{"prompt": " file path A: test/functional/wallet_basic.py | file path B: test/functional/wallet_basic.py\n\n@@ -585,15 +585,9 @@ class WalletTest(BitcoinTestFramework):\n \n         # ==Check that wallet prefers to use coins that don't exceed mempool limits =====\n \n-        # Get all non-zero utxos together\n+        # Get all non-zero utxos together and split into two chains\n         chain_addrs = [self.nodes[0].getnewaddress(), self.nodes[0].getnewaddress()]\n-        singletxid = self.nodes[0].sendall(recipients=[chain_addrs[0]])['txid']\n-        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n-        node0_balance = self.nodes[0].getbalance()\n-        # Split into two chains\n-        rawtx = self.nodes[0].createrawtransaction([{\"txid\": singletxid, \"vout\": 0}], {chain_addrs[0]: node0_balance / 2 - Decimal('0.01'), chain_addrs[1]: node0_balance / 2 - Decimal('0.01')})\n-        signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx)\n-        singletxid = self.nodes[0].sendrawtransaction(hexstring=signedtx[\"hex\"], maxfeerate=0)\n+        self.nodes[0].sendall(recipients=chain_addrs)\n         self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n \n         # Make a long chain of unconfirmed payments without hitting mempool limit\n\n\n###\n\n", "completion": "test: simplify splitment with `sendall` in wallet_basic"}
{"prompt": " file path A: src/test/util_tests.cpp | file path B: src/test/util_tests.cpp\n\n@@ -2510,13 +2510,13 @@ BOOST_AUTO_TEST_CASE(test_tracked_vector)\n \n     auto v2 = Vector(std::move(t2));\n     BOOST_CHECK_EQUAL(v2.size(), 1U);\n-    BOOST_CHECK(v2[0].origin == &t2);\n+    BOOST_CHECK(v2[0].origin == &t2); // NOLINT(*-use-after-move)\n     BOOST_CHECK_EQUAL(v2[0].copies, 0);\n \n     auto v3 = Vector(t1, std::move(t2));\n     BOOST_CHECK_EQUAL(v3.size(), 2U);\n     BOOST_CHECK(v3[0].origin == &t1);\n-    BOOST_CHECK(v3[1].origin == &t2);\n+    BOOST_CHECK(v3[1].origin == &t2); // NOLINT(*-use-after-move)\n     BOOST_CHECK_EQUAL(v3[0].copies, 1);\n     BOOST_CHECK_EQUAL(v3[1].copies, 0);\n \n@@ -2524,7 +2524,7 @@ BOOST_AUTO_TEST_CASE(test_tracked_vector)\n     BOOST_CHECK_EQUAL(v4.size(), 3U);\n     BOOST_CHECK(v4[0].origin == &t1);\n     BOOST_CHECK(v4[1].origin == &t2);\n-    BOOST_CHECK(v4[2].origin == &t3);\n+    BOOST_CHECK(v4[2].origin == &t3); // NOLINT(*-use-after-move)\n     BOOST_CHECK_EQUAL(v4[0].copies, 1);\n     BOOST_CHECK_EQUAL(v4[1].copies, 1);\n     BOOST_CHECK_EQUAL(v4[2].copies, 0);\n\n\n###\n\n", "completion": "test: work around bugprone-use-after-move warnings in util tests"}
{"prompt": " file path A: test/functional/rpc_fundrawtransaction.py | file path B: test/functional/rpc_fundrawtransaction.py\n\n@@ -635,7 +635,7 @@ class RawTransactionsTest(BitcoinTestFramework):\n         self.log.info(\"Test fundrawtxn fee with many inputs\")\n \n         # Empty node1, send some small coins from node0 to node1.\n-        self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n+        self.nodes[1].sendall(recipients=[self.nodes[0].getnewaddress()])\n         self.generate(self.nodes[1], 1)\n \n         for _ in range(20):\n@@ -661,7 +661,7 @@ class RawTransactionsTest(BitcoinTestFramework):\n         self.log.info(\"Test fundrawtxn sign+send with many inputs\")\n \n         # Again, empty node1, send some small coins from node0 to node1.\n-        self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n+        self.nodes[1].sendall(recipients=[self.nodes[0].getnewaddress()])\n         self.generate(self.nodes[1], 1)\n \n         for _ in range(20):\n\n---\n file path A: test/functional/wallet_basic.py | file path B: test/functional/wallet_basic.py\n\n@@ -587,7 +587,7 @@ class WalletTest(BitcoinTestFramework):\n \n         # Get all non-zero utxos together\n         chain_addrs = [self.nodes[0].getnewaddress(), self.nodes[0].getnewaddress()]\n-        singletxid = self.nodes[0].sendtoaddress(chain_addrs[0], self.nodes[0].getbalance(), \"\", \"\", True)\n+        singletxid = self.nodes[0].sendall(recipients=[chain_addrs[0]])['txid']\n         self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         node0_balance = self.nodes[0].getbalance()\n         # Split into two chains\n\n---\n file path A: test/functional/wallet_bumpfee.py | file path B: test/functional/wallet_bumpfee.py\n\n@@ -624,7 +624,7 @@ def test_no_more_inputs_fails(self, rbf_node, dest_address):\n     # feerate rbf requires confirmed outputs when change output doesn't exist or is insufficient\n     self.generatetoaddress(rbf_node, 1, dest_address)\n     # spend all funds, no change output\n-    rbfid = rbf_node.sendtoaddress(rbf_node.getnewaddress(), rbf_node.getbalance(), \"\", \"\", True)\n+    rbfid = rbf_node.sendall(recipients=[rbf_node.getnewaddress()])['txid']\n     assert_raises_rpc_error(-4, \"Unable to create transaction. Insufficient funds\", rbf_node.bumpfee, rbfid)\n     self.clear_mempool()\n \n\n---\n file path A: test/functional/wallet_groups.py | file path B: test/functional/wallet_groups.py\n\n@@ -154,7 +154,7 @@ class WalletGroupTest(BitcoinTestFramework):\n         assert_equal(2, len(tx6[\"vout\"]))\n \n         # Empty out node2's wallet\n-        self.nodes[2].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=self.nodes[2].getbalance(), subtractfeefromamount=True)\n+        self.nodes[2].sendall(recipients=[self.nodes[0].getnewaddress()])\n         self.sync_all()\n         self.generate(self.nodes[0], 1)\n \n\n\n###\n\n", "completion": "test: use `sendall` when emptying wallet"}
{"prompt": " file path A: test/functional/mempool_expiry.py | file path B: test/functional/mempool_expiry.py\n\n@@ -13,6 +13,7 @@ definable expiry timeout via the '-mempoolexpiry=<n>' command line argument\n from datetime import timedelta\n \n from test_framework.blocktools import COINBASE_MATURITY\n+from test_framework.messages import DEFAULT_MEMPOOL_EXPIRY_HOURS\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -20,7 +21,6 @@ from test_framework.util import (\n )\n from test_framework.wallet import MiniWallet\n \n-DEFAULT_MEMPOOL_EXPIRY_HOURS = 336  # hours\n CUSTOM_MEMPOOL_EXPIRY = 10  # hours\n \n \n\n---\n file path A: test/functional/test_framework/messages.py | file path B: test/functional/test_framework/messages.py\n\n@@ -71,6 +71,7 @@ DEFAULT_DESCENDANT_LIMIT = 25  # default max number of in-mempool descendants\n # Default setting for -datacarriersize. 80 bytes of data, +1 for OP_RETURN, +2 for the pushdata opcodes.\n MAX_OP_RETURN_RELAY = 83\n \n+DEFAULT_MEMPOOL_EXPIRY_HOURS = 336  # hours\n \n def sha256(s):\n     return hashlib.sha256(s).digest()\n\n---\n file path A: test/functional/wallet_resendwallettransactions.py | file path B: test/functional/wallet_resendwallettransactions.py\n\n@@ -9,10 +9,13 @@ from test_framework.blocktools import (\n     create_block,\n     create_coinbase,\n )\n+from test_framework.messages import DEFAULT_MEMPOOL_EXPIRY_HOURS\n from test_framework.p2p import P2PTxInvStore\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n-\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n \n class ResendWalletTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -27,7 +30,9 @@ class ResendWalletTransactionsTest(BitcoinTestFramework):\n         peer_first = node.add_p2p_connection(P2PTxInvStore())\n \n         self.log.info(\"Create a new transaction and wait until it's broadcast\")\n-        txid = node.sendtoaddress(node.getnewaddress(), 1)\n+        parent_utxo, indep_utxo = node.listunspent()[:2]\n+        addr = node.getnewaddress()\n+        txid = node.send(outputs=[{addr: 1}], options={\"inputs\": [parent_utxo]})[\"txid\"]\n \n         # Can take a few seconds due to transaction trickling\n         peer_first.wait_for_broadcast([txid])\n@@ -68,6 +73,49 @@ class ResendWalletTransactionsTest(BitcoinTestFramework):\n         node.setmocktime(now + 36 * 60 * 60 + 600)\n         peer_second.wait_for_broadcast([txid])\n \n+        self.log.info(\"Chain of unconfirmed not-in-mempool txs are rebroadcast\")\n+        # This tests that the node broadcasts the parent transaction before the child transaction.\n+        # To test that scenario, we need a method to reliably get a child transaction placed\n+        # in mapWallet positioned before the parent. We cannot predict the position in mapWallet,\n+        # but we can observe it using listreceivedbyaddress and other related RPCs.\n+        #\n+        # So we will create the child transaction, use listreceivedbyaddress to see what the\n+        # ordering of mapWallet is, if the child is not before the parent, we will create a new\n+        # child (via bumpfee) and remove the old child (via removeprunedfunds) until we get the\n+        # ordering of child before parent.\n+        child_txid = node.send(outputs=[{addr: 0.5}], options={\"inputs\": [{\"txid\":txid, \"vout\":0}]})[\"txid\"]\n+        while True:\n+            txids = node.listreceivedbyaddress(minconf=0, address_filter=addr)[0][\"txids\"]\n+            if txids == [child_txid, txid]:\n+                break\n+            bumped = node.bumpfee(child_txid)\n+            node.removeprunedfunds(child_txid)\n+            child_txid = bumped[\"txid\"]\n+        entry_time = node.getmempoolentry(child_txid)[\"time\"]\n+\n+        block_time = entry_time + 6 * 60\n+        node.setmocktime(block_time)\n+        block = create_block(int(node.getbestblockhash(), 16), create_coinbase(node.getblockcount() + 1), block_time)\n+        block.solve()\n+        node.submitblock(block.serialize().hex())\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # Evict these txs from the mempool\n+        evict_time = block_time + 60 * 60 * DEFAULT_MEMPOOL_EXPIRY_HOURS + 5\n+        node.setmocktime(evict_time)\n+        indep_send = node.send(outputs=[{node.getnewaddress(): 1}], options={\"inputs\": [indep_utxo]})\n+        node.syncwithvalidationinterfacequeue()\n+        node.getmempoolentry(indep_send[\"txid\"])\n+        assert_raises_rpc_error(-5, \"Transaction not in mempool\", node.getmempoolentry, txid)\n+        assert_raises_rpc_error(-5, \"Transaction not in mempool\", node.getmempoolentry, child_txid)\n+\n+        # Rebroadcast and check that parent and child are both in the mempool\n+        with node.assert_debug_log(['resubmit 2 unconfirmed transactions']):\n+            node.setmocktime(evict_time + 36 * 60 * 60) # 36 hrs is the upper limit of the resend timer\n+            node.mockscheduler(60)\n+        node.getmempoolentry(txid)\n+        node.getmempoolentry(child_txid)\n+\n \n if __name__ == '__main__':\n     ResendWalletTransactionsTest().main()\n\n\n###\n\n", "completion": "test: Test that an unconfirmed not-in-mempool chain is rebroadcast"}
{"prompt": " file path A: test/functional/wallet_balance.py | file path B: test/functional/wallet_balance.py\n\n@@ -266,7 +266,6 @@ class WalletTest(BitcoinTestFramework):\n         self.nodes[1].invalidateblock(block_reorg)\n         assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted\n         self.generatetoaddress(self.nodes[0], 1, ADDRESS_WATCHONLY, sync_fun=self.no_op)\n-        assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted\n \n         # Now confirm tx_orig\n         self.restart_node(1, ['-persistmempool=0'])\n\n\n###\n\n", "completion": "test: Fix wallet_balance intermittent issue"}
{"prompt": " file path A: test/functional/wallet_resendwallettransactions.py | file path B: test/functional/wallet_resendwallettransactions.py\n\n@@ -31,7 +31,7 @@ class ResendWalletTransactionsTest(BitcoinTestFramework):\n \n         # Wallet rebroadcast is first scheduled 1 min sec after startup (see\n         # nNextResend in ResendWalletTransactions()). Tell scheduler to call\n-        # MaybeResendWalletTxn now to initialize nNextResend before the first\n+        # MaybeResendWalletTxs now to initialize nNextResend before the first\n         # setmocktime call below.\n         node.mockscheduler(60)\n \n@@ -60,7 +60,7 @@ class ResendWalletTransactionsTest(BitcoinTestFramework):\n         twelve_hrs = 12 * 60 * 60\n         two_min = 2 * 60\n         node.setmocktime(now + twelve_hrs - two_min)\n-        node.mockscheduler(60)  # Tell scheduler to call MaybeResendWalletTxn now\n+        node.mockscheduler(60)  # Tell scheduler to call MaybeResendWalletTxs now\n         assert_equal(int(txid, 16) in peer_second.get_invs(), False)\n \n         self.log.info(\"Bump time & check that transaction is rebroadcast\")\n@@ -68,7 +68,7 @@ class ResendWalletTransactionsTest(BitcoinTestFramework):\n         # but can range from 12-36. So bump 36 hours to be sure.\n         with node.assert_debug_log(['ResendWalletTransactions: resubmit 1 unconfirmed transactions']):\n             node.setmocktime(now + 36 * 60 * 60)\n-            # Tell scheduler to call MaybeResendWalletTxn now.\n+            # Tell scheduler to call MaybeResendWalletTxs now.\n             node.mockscheduler(60)\n         # Give some time for trickle to occur\n         node.setmocktime(now + 36 * 60 * 60 + 600)\n\n\n###\n\n", "completion": "test: fix typo for MaybeResendWalletTxs"}
{"prompt": " file path A: .cirrus.yml | file path B: .cirrus.yml\n\n@@ -97,8 +97,8 @@ task:\n   name: \"Win64 native [vs2022]\"\n   << : *FILTER_TEMPLATE\n   windows_container:\n-    cpu: 4\n-    memory: 8G\n+    cpu: 6\n+    memory: 12G\n     image: cirrusci/windowsservercore:visualstudio2022\n   timeout_in: 120m\n   env:\n\n\n###\n\n", "completion": "ci: Increase `windows_container` resources"}
